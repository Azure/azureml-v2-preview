# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Dict, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._azure_machine_learning_workspaces_enums import *


class AccountKeySection(msrest.serialization.Model):
    """AccountKeySection.

    :param key: Storage account key.
    :type key: str
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key: Optional[str] = None,
        **kwargs
    ):
        super(AccountKeySection, self).__init__(**kwargs)
        self.key = key


class ComputeConfiguration(msrest.serialization.Model):
    """ComputeConfiguration.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AciComputeConfiguration, AksComputeConfiguration, MirComputeConfiguration, BatchEndpointComputeConfiguration, OnlineEndpointPropertiesComputeConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'ACI': 'AciComputeConfiguration', 'AKS': 'AksComputeConfiguration', 'AMLCompute': 'MirComputeConfiguration', 'BatchEndpoint-computeConfiguration': 'BatchEndpointComputeConfiguration', 'OnlineEndpointProperties-computeConfiguration': 'OnlineEndpointPropertiesComputeConfiguration'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = None  # type: Optional[str]


class AciComputeConfiguration(ComputeConfiguration):
    """AciComputeConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param ssl_configuration:
    :type ssl_configuration: ~azure_machine_learning_workspaces.models.SSLConfiguration
    :param vnet_configuration:
    :type vnet_configuration: ~azure_machine_learning_workspaces.models.VnetConfiguration
    :param encryption_properties:
    :type encryption_properties: ~azure_machine_learning_workspaces.models.EncryptionProperties
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'ssl_configuration': {'key': 'sslConfiguration', 'type': 'SSLConfiguration'},
        'vnet_configuration': {'key': 'vnetConfiguration', 'type': 'VnetConfiguration'},
        'encryption_properties': {'key': 'encryptionProperties', 'type': 'EncryptionProperties'},
    }

    def __init__(
        self,
        *,
        ssl_configuration: Optional["SSLConfiguration"] = None,
        vnet_configuration: Optional["VnetConfiguration"] = None,
        encryption_properties: Optional["EncryptionProperties"] = None,
        **kwargs
    ):
        super(AciComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = 'ACI'  # type: str
        self.ssl_configuration = ssl_configuration
        self.vnet_configuration = vnet_configuration
        self.encryption_properties = encryption_properties


class DeploymentConfigurationBase(msrest.serialization.Model):
    """DeploymentConfigurationBase.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AciDeploymentConfiguration, AksDeploymentConfiguration, AmlComputeDeploymentConfiguration, OnlineDeploymentPropertiesDeploymentConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param app_insights_enabled:
    :type app_insights_enabled: bool
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
    }

    _subtype_map = {
        'compute_type': {'ACI': 'AciDeploymentConfiguration', 'AKS': 'AksDeploymentConfiguration', 'AMLCompute': 'AmlComputeDeploymentConfiguration', 'OnlineDeploymentProperties-deploymentConfiguration': 'OnlineDeploymentPropertiesDeploymentConfiguration'}
    }

    def __init__(
        self,
        *,
        app_insights_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(DeploymentConfigurationBase, self).__init__(**kwargs)
        self.compute_type = None  # type: Optional[str]
        self.app_insights_enabled = app_insights_enabled


class AciDeploymentConfiguration(DeploymentConfigurationBase):
    """AciDeploymentConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param app_insights_enabled:
    :type app_insights_enabled: bool
    :param model_data_collection: The Model data collection properties.
    :type model_data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param container_resource_requirements:
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirementsautogenerated
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'model_data_collection': {'key': 'modelDataCollection', 'type': 'ModelDataCollection'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirementsautogenerated'},
    }

    def __init__(
        self,
        *,
        app_insights_enabled: Optional[bool] = None,
        model_data_collection: Optional["ModelDataCollection"] = None,
        container_resource_requirements: Optional["ContainerResourceRequirementsautogenerated"] = None,
        **kwargs
    ):
        super(AciDeploymentConfiguration, self).__init__(app_insights_enabled=app_insights_enabled, **kwargs)
        self.compute_type = 'ACI'  # type: str
        self.model_data_collection = model_data_collection
        self.container_resource_requirements = container_resource_requirements


class CreateServiceRequest(msrest.serialization.Model):
    """The base class for creating a service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AciServiceCreateRequest, CreateEndpointVariantRequest.

    All required parameters must be populated in order to send to Azure.

    :param description: The description of the service.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service properties dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :param keys: The authentication keys.
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param environment_image_request: The Environment, models and assets needed for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageRequest
    :param location: The name of the Azure location/region.
    :type location: str
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageRequest'},
        'location': {'key': 'location', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'ACI': 'AciServiceCreateRequest', 'Custom': 'CreateEndpointVariantRequest'}
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        keys: Optional["AuthKeys"] = None,
        environment_image_request: Optional["EnvironmentImageRequest"] = None,
        location: Optional[str] = None,
        **kwargs
    ):
        super(CreateServiceRequest, self).__init__(**kwargs)
        self.description = description
        self.kv_tags = kv_tags
        self.properties = properties
        self.keys = keys
        self.compute_type = None  # type: Optional[str]
        self.environment_image_request = environment_image_request
        self.location = location


class AciServiceCreateRequest(CreateServiceRequest):
    """AciServiceCreateRequest.

    All required parameters must be populated in order to send to Azure.

    :param description: The description of the service.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service properties dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :param keys: The authentication keys.
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param environment_image_request: The Environment, models and assets needed for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageRequest
    :param location: The name of the Azure location/region.
    :type location: str
    :param container_resource_requirements: The container resource requirements.
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirements
    :param auth_enabled: Whether or not authentication is enabled on the service.
    :type auth_enabled: bool
    :param ssl_enabled: Whether or not SSL is enabled.
    :type ssl_enabled: bool
    :param app_insights_enabled: Whether or not Application Insights is enabled.
    :type app_insights_enabled: bool
    :param data_collection: Details of the data collection options specified.
    :type data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param ssl_certificate: The public SSL certificate in PEM format to use if SSL is enabled.
    :type ssl_certificate: str
    :param ssl_key: The public SSL key in PEM format for the certificate.
    :type ssl_key: str
    :param cname: The CName for the service.
    :type cname: str
    :param dns_name_label: The Dns label for the service.
    :type dns_name_label: str
    :param vnet_configuration: The virtual network configuration.
    :type vnet_configuration:
     ~azure_machine_learning_workspaces.models.VnetConfigurationautogenerated
    :param encryption_properties: The encryption properties.
    :type encryption_properties:
     ~azure_machine_learning_workspaces.models.EncryptionPropertiesautogenerated
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageRequest'},
        'location': {'key': 'location', 'type': 'str'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirements'},
        'auth_enabled': {'key': 'authEnabled', 'type': 'bool'},
        'ssl_enabled': {'key': 'sslEnabled', 'type': 'bool'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'data_collection': {'key': 'dataCollection', 'type': 'ModelDataCollection'},
        'ssl_certificate': {'key': 'sslCertificate', 'type': 'str'},
        'ssl_key': {'key': 'sslKey', 'type': 'str'},
        'cname': {'key': 'cname', 'type': 'str'},
        'dns_name_label': {'key': 'dnsNameLabel', 'type': 'str'},
        'vnet_configuration': {'key': 'vnetConfiguration', 'type': 'VnetConfigurationautogenerated'},
        'encryption_properties': {'key': 'encryptionProperties', 'type': 'EncryptionPropertiesautogenerated'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        keys: Optional["AuthKeys"] = None,
        environment_image_request: Optional["EnvironmentImageRequest"] = None,
        location: Optional[str] = None,
        container_resource_requirements: Optional["ContainerResourceRequirements"] = None,
        auth_enabled: Optional[bool] = False,
        ssl_enabled: Optional[bool] = False,
        app_insights_enabled: Optional[bool] = False,
        data_collection: Optional["ModelDataCollection"] = None,
        ssl_certificate: Optional[str] = None,
        ssl_key: Optional[str] = None,
        cname: Optional[str] = None,
        dns_name_label: Optional[str] = None,
        vnet_configuration: Optional["VnetConfigurationautogenerated"] = None,
        encryption_properties: Optional["EncryptionPropertiesautogenerated"] = None,
        **kwargs
    ):
        super(AciServiceCreateRequest, self).__init__(description=description, kv_tags=kv_tags, properties=properties, keys=keys, environment_image_request=environment_image_request, location=location, **kwargs)
        self.compute_type = 'ACI'  # type: str
        self.container_resource_requirements = container_resource_requirements
        self.auth_enabled = auth_enabled
        self.ssl_enabled = ssl_enabled
        self.app_insights_enabled = app_insights_enabled
        self.data_collection = data_collection
        self.ssl_certificate = ssl_certificate
        self.ssl_key = ssl_key
        self.cname = cname
        self.dns_name_label = dns_name_label
        self.vnet_configuration = vnet_configuration
        self.encryption_properties = encryption_properties


class ModelDataCollection(msrest.serialization.Model):
    """The Model data collection properties.

    :param event_hub_enabled: Option for enabling/disabling Event Hub.
    :type event_hub_enabled: bool
    :param storage_enabled: Option for enabling/disabling storage.
    :type storage_enabled: bool
    """

    _attribute_map = {
        'event_hub_enabled': {'key': 'eventHubEnabled', 'type': 'bool'},
        'storage_enabled': {'key': 'storageEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        event_hub_enabled: Optional[bool] = None,
        storage_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(ModelDataCollection, self).__init__(**kwargs)
        self.event_hub_enabled = event_hub_enabled
        self.storage_enabled = storage_enabled


class AciServiceCreateRequestDataCollection(ModelDataCollection):
    """Details of the data collection options specified.

    :param event_hub_enabled: Option for enabling/disabling Event Hub.
    :type event_hub_enabled: bool
    :param storage_enabled: Option for enabling/disabling storage.
    :type storage_enabled: bool
    """

    _attribute_map = {
        'event_hub_enabled': {'key': 'eventHubEnabled', 'type': 'bool'},
        'storage_enabled': {'key': 'storageEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        event_hub_enabled: Optional[bool] = None,
        storage_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(AciServiceCreateRequestDataCollection, self).__init__(event_hub_enabled=event_hub_enabled, storage_enabled=storage_enabled, **kwargs)


class EncryptionPropertiesautogenerated(msrest.serialization.Model):
    """EncryptionPropertiesautogenerated.

    All required parameters must be populated in order to send to Azure.

    :param vault_base_url: Required. vault base Url.
    :type vault_base_url: str
    :param key_name: Required. Encryption Key name.
    :type key_name: str
    :param key_version: Required. Encryption Key Version.
    :type key_version: str
    """

    _validation = {
        'vault_base_url': {'required': True},
        'key_name': {'required': True},
        'key_version': {'required': True},
    }

    _attribute_map = {
        'vault_base_url': {'key': 'vaultBaseUrl', 'type': 'str'},
        'key_name': {'key': 'keyName', 'type': 'str'},
        'key_version': {'key': 'keyVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        **kwargs
    ):
        super(EncryptionPropertiesautogenerated, self).__init__(**kwargs)
        self.vault_base_url = vault_base_url
        self.key_name = key_name
        self.key_version = key_version


class AciServiceCreateRequestEncryptionProperties(EncryptionPropertiesautogenerated):
    """The encryption properties.

    All required parameters must be populated in order to send to Azure.

    :param vault_base_url: Required. vault base Url.
    :type vault_base_url: str
    :param key_name: Required. Encryption Key name.
    :type key_name: str
    :param key_version: Required. Encryption Key Version.
    :type key_version: str
    """

    _validation = {
        'vault_base_url': {'required': True},
        'key_name': {'required': True},
        'key_version': {'required': True},
    }

    _attribute_map = {
        'vault_base_url': {'key': 'vaultBaseUrl', 'type': 'str'},
        'key_name': {'key': 'keyName', 'type': 'str'},
        'key_version': {'key': 'keyVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        **kwargs
    ):
        super(AciServiceCreateRequestEncryptionProperties, self).__init__(vault_base_url=vault_base_url, key_name=key_name, key_version=key_version, **kwargs)


class VnetConfigurationautogenerated(msrest.serialization.Model):
    """VnetConfigurationautogenerated.

    :param vnet_name: The name of the virtual network.
    :type vnet_name: str
    :param subnet_name: The name of the virtual network subnet.
    :type subnet_name: str
    """

    _attribute_map = {
        'vnet_name': {'key': 'vnetName', 'type': 'str'},
        'subnet_name': {'key': 'subnetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vnet_name: Optional[str] = None,
        subnet_name: Optional[str] = None,
        **kwargs
    ):
        super(VnetConfigurationautogenerated, self).__init__(**kwargs)
        self.vnet_name = vnet_name
        self.subnet_name = subnet_name


class AciServiceCreateRequestVnetConfiguration(VnetConfigurationautogenerated):
    """The virtual network configuration.

    :param vnet_name: The name of the virtual network.
    :type vnet_name: str
    :param subnet_name: The name of the virtual network subnet.
    :type subnet_name: str
    """

    _attribute_map = {
        'vnet_name': {'key': 'vnetName', 'type': 'str'},
        'subnet_name': {'key': 'subnetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vnet_name: Optional[str] = None,
        subnet_name: Optional[str] = None,
        **kwargs
    ):
        super(AciServiceCreateRequestVnetConfiguration, self).__init__(vnet_name=vnet_name, subnet_name=subnet_name, **kwargs)


class ServiceResponseBase(msrest.serialization.Model):
    """The base service response. The correct inherited response based on computeType will be returned (ex. ACIServiceResponse).

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AciServiceResponse, AksVariantResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param description: The service description.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service property dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :ivar state: The current state of the service. Possible values include: "Transitioning",
     "Healthy", "Unhealthy", "Failed", "Unschedulable".
    :vartype state: str or ~azure_machine_learning_workspaces.models.WebServiceState
    :ivar error: The error details.
    :vartype error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param deployment_type: The deployment type for the service. Possible values include:
     "GRPCRealtimeEndpoint", "HttpRealtimeEndpoint", "Batch".
    :type deployment_type: str or ~azure_machine_learning_workspaces.models.DeploymentType
    """

    _validation = {
        'state': {'readonly': True},
        'error': {'readonly': True},
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'state': {'key': 'state', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'deployment_type': {'key': 'deploymentType', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'ACI': 'AciServiceResponse', 'Custom': 'AksVariantResponse'}
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        deployment_type: Optional[Union[str, "DeploymentType"]] = None,
        **kwargs
    ):
        super(ServiceResponseBase, self).__init__(**kwargs)
        self.description = description
        self.kv_tags = kv_tags
        self.properties = properties
        self.state = None
        self.error = None
        self.compute_type = None  # type: Optional[str]
        self.deployment_type = deployment_type


class AciServiceResponse(ServiceResponseBase):
    """The response for an ACI service.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param description: The service description.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service property dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :ivar state: The current state of the service. Possible values include: "Transitioning",
     "Healthy", "Unhealthy", "Failed", "Unschedulable".
    :vartype state: str or ~azure_machine_learning_workspaces.models.WebServiceState
    :ivar error: The error details.
    :vartype error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param deployment_type: The deployment type for the service. Possible values include:
     "GRPCRealtimeEndpoint", "HttpRealtimeEndpoint", "Batch".
    :type deployment_type: str or ~azure_machine_learning_workspaces.models.DeploymentType
    :param container_resource_requirements: The container resource requirements.
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirements
    :ivar scoring_uri: The Uri for sending scoring requests.
    :vartype scoring_uri: str
    :param location: The name of the Azure location/region.
    :type location: str
    :param auth_enabled: Whether or not authentication is enabled on the service.
    :type auth_enabled: bool
    :param ssl_enabled: Whether or not SSL is enabled.
    :type ssl_enabled: bool
    :param app_insights_enabled: Whether or not Application Insights is enabled.
    :type app_insights_enabled: bool
    :param data_collection: Details of the data collection options specified.
    :type data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param ssl_certificate: The public SSL certificate in PEM format to use if SSL is enabled.
    :type ssl_certificate: str
    :param ssl_key: The public SSL key in PEM format for the certificate.
    :type ssl_key: str
    :param cname: The CName for the service.
    :type cname: str
    :param public_ip: The public IP address for the service.
    :type public_ip: str
    :param public_fqdn: The public Fqdn for the service.
    :type public_fqdn: str
    :ivar swagger_uri: The Uri for sending swagger requests.
    :vartype swagger_uri: str
    :ivar model_config_map: Details on the models and configurations.
    :vartype model_config_map: dict[str, object]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment_image_request: The Environment, models and assets used for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageResponse
    :param vnet_configuration: The virtual network configuration.
    :type vnet_configuration:
     ~azure_machine_learning_workspaces.models.VnetConfigurationautogenerated
    :param encryption_properties: The encryption properties.
    :type encryption_properties:
     ~azure_machine_learning_workspaces.models.EncryptionPropertiesautogenerated
    """

    _validation = {
        'state': {'readonly': True},
        'error': {'readonly': True},
        'compute_type': {'required': True},
        'scoring_uri': {'readonly': True},
        'swagger_uri': {'readonly': True},
        'model_config_map': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'state': {'key': 'state', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'deployment_type': {'key': 'deploymentType', 'type': 'str'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirements'},
        'scoring_uri': {'key': 'scoringUri', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'auth_enabled': {'key': 'authEnabled', 'type': 'bool'},
        'ssl_enabled': {'key': 'sslEnabled', 'type': 'bool'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'data_collection': {'key': 'dataCollection', 'type': 'ModelDataCollection'},
        'ssl_certificate': {'key': 'sslCertificate', 'type': 'str'},
        'ssl_key': {'key': 'sslKey', 'type': 'str'},
        'cname': {'key': 'cname', 'type': 'str'},
        'public_ip': {'key': 'publicIp', 'type': 'str'},
        'public_fqdn': {'key': 'publicFqdn', 'type': 'str'},
        'swagger_uri': {'key': 'swaggerUri', 'type': 'str'},
        'model_config_map': {'key': 'modelConfigMap', 'type': '{object}'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageResponse'},
        'vnet_configuration': {'key': 'vnetConfiguration', 'type': 'VnetConfigurationautogenerated'},
        'encryption_properties': {'key': 'encryptionProperties', 'type': 'EncryptionPropertiesautogenerated'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        deployment_type: Optional[Union[str, "DeploymentType"]] = None,
        container_resource_requirements: Optional["ContainerResourceRequirements"] = None,
        location: Optional[str] = None,
        auth_enabled: Optional[bool] = None,
        ssl_enabled: Optional[bool] = None,
        app_insights_enabled: Optional[bool] = None,
        data_collection: Optional["ModelDataCollection"] = None,
        ssl_certificate: Optional[str] = None,
        ssl_key: Optional[str] = None,
        cname: Optional[str] = None,
        public_ip: Optional[str] = None,
        public_fqdn: Optional[str] = None,
        models: Optional[List["Model"]] = None,
        environment_image_request: Optional["EnvironmentImageResponse"] = None,
        vnet_configuration: Optional["VnetConfigurationautogenerated"] = None,
        encryption_properties: Optional["EncryptionPropertiesautogenerated"] = None,
        **kwargs
    ):
        super(AciServiceResponse, self).__init__(description=description, kv_tags=kv_tags, properties=properties, deployment_type=deployment_type, **kwargs)
        self.compute_type = 'ACI'  # type: str
        self.container_resource_requirements = container_resource_requirements
        self.scoring_uri = None
        self.location = location
        self.auth_enabled = auth_enabled
        self.ssl_enabled = ssl_enabled
        self.app_insights_enabled = app_insights_enabled
        self.data_collection = data_collection
        self.ssl_certificate = ssl_certificate
        self.ssl_key = ssl_key
        self.cname = cname
        self.public_ip = public_ip
        self.public_fqdn = public_fqdn
        self.swagger_uri = None
        self.model_config_map = None
        self.models = models
        self.environment_image_request = environment_image_request
        self.vnet_configuration = vnet_configuration
        self.encryption_properties = encryption_properties


class AciServiceResponseDataCollection(ModelDataCollection):
    """Details of the data collection options specified.

    :param event_hub_enabled: Option for enabling/disabling Event Hub.
    :type event_hub_enabled: bool
    :param storage_enabled: Option for enabling/disabling storage.
    :type storage_enabled: bool
    """

    _attribute_map = {
        'event_hub_enabled': {'key': 'eventHubEnabled', 'type': 'bool'},
        'storage_enabled': {'key': 'storageEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        event_hub_enabled: Optional[bool] = None,
        storage_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(AciServiceResponseDataCollection, self).__init__(event_hub_enabled=event_hub_enabled, storage_enabled=storage_enabled, **kwargs)


class AciServiceResponseEncryptionProperties(EncryptionPropertiesautogenerated):
    """The encryption properties.

    All required parameters must be populated in order to send to Azure.

    :param vault_base_url: Required. vault base Url.
    :type vault_base_url: str
    :param key_name: Required. Encryption Key name.
    :type key_name: str
    :param key_version: Required. Encryption Key Version.
    :type key_version: str
    """

    _validation = {
        'vault_base_url': {'required': True},
        'key_name': {'required': True},
        'key_version': {'required': True},
    }

    _attribute_map = {
        'vault_base_url': {'key': 'vaultBaseUrl', 'type': 'str'},
        'key_name': {'key': 'keyName', 'type': 'str'},
        'key_version': {'key': 'keyVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        **kwargs
    ):
        super(AciServiceResponseEncryptionProperties, self).__init__(vault_base_url=vault_base_url, key_name=key_name, key_version=key_version, **kwargs)


class EnvironmentImageResponse(msrest.serialization.Model):
    """Request to create a Docker image based on Environment.

    :param driver_program: The name of the driver file.
    :type driver_program: str
    :param assets: The list of assets.
    :type assets: list[~azure_machine_learning_workspaces.models.ImageAsset]
    :param model_ids: The list of model Ids.
    :type model_ids: list[str]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment: The details of the AZURE ML environment.
    :type environment: ~azure_machine_learning_workspaces.models.ModelEnvironmentDefinitionResponse
    :param environment_reference: The unique identifying details of the AZURE ML environment.
    :type environment_reference: ~azure_machine_learning_workspaces.models.EnvironmentReference
    """

    _attribute_map = {
        'driver_program': {'key': 'driverProgram', 'type': 'str'},
        'assets': {'key': 'assets', 'type': '[ImageAsset]'},
        'model_ids': {'key': 'modelIds', 'type': '[str]'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment': {'key': 'environment', 'type': 'ModelEnvironmentDefinitionResponse'},
        'environment_reference': {'key': 'environmentReference', 'type': 'EnvironmentReference'},
    }

    def __init__(
        self,
        *,
        driver_program: Optional[str] = None,
        assets: Optional[List["ImageAsset"]] = None,
        model_ids: Optional[List[str]] = None,
        models: Optional[List["Model"]] = None,
        environment: Optional["ModelEnvironmentDefinitionResponse"] = None,
        environment_reference: Optional["EnvironmentReference"] = None,
        **kwargs
    ):
        super(EnvironmentImageResponse, self).__init__(**kwargs)
        self.driver_program = driver_program
        self.assets = assets
        self.model_ids = model_ids
        self.models = models
        self.environment = environment
        self.environment_reference = environment_reference


class AciServiceResponseEnvironmentImageRequest(EnvironmentImageResponse):
    """The Environment, models and assets used for inferencing.

    :param driver_program: The name of the driver file.
    :type driver_program: str
    :param assets: The list of assets.
    :type assets: list[~azure_machine_learning_workspaces.models.ImageAsset]
    :param model_ids: The list of model Ids.
    :type model_ids: list[str]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment: The details of the AZURE ML environment.
    :type environment: ~azure_machine_learning_workspaces.models.ModelEnvironmentDefinitionResponse
    :param environment_reference: The unique identifying details of the AZURE ML environment.
    :type environment_reference: ~azure_machine_learning_workspaces.models.EnvironmentReference
    """

    _attribute_map = {
        'driver_program': {'key': 'driverProgram', 'type': 'str'},
        'assets': {'key': 'assets', 'type': '[ImageAsset]'},
        'model_ids': {'key': 'modelIds', 'type': '[str]'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment': {'key': 'environment', 'type': 'ModelEnvironmentDefinitionResponse'},
        'environment_reference': {'key': 'environmentReference', 'type': 'EnvironmentReference'},
    }

    def __init__(
        self,
        *,
        driver_program: Optional[str] = None,
        assets: Optional[List["ImageAsset"]] = None,
        model_ids: Optional[List[str]] = None,
        models: Optional[List["Model"]] = None,
        environment: Optional["ModelEnvironmentDefinitionResponse"] = None,
        environment_reference: Optional["EnvironmentReference"] = None,
        **kwargs
    ):
        super(AciServiceResponseEnvironmentImageRequest, self).__init__(driver_program=driver_program, assets=assets, model_ids=model_ids, models=models, environment=environment, environment_reference=environment_reference, **kwargs)


class AciServiceResponseVnetConfiguration(VnetConfigurationautogenerated):
    """The virtual network configuration.

    :param vnet_name: The name of the virtual network.
    :type vnet_name: str
    :param subnet_name: The name of the virtual network subnet.
    :type subnet_name: str
    """

    _attribute_map = {
        'vnet_name': {'key': 'vnetName', 'type': 'str'},
        'subnet_name': {'key': 'subnetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vnet_name: Optional[str] = None,
        subnet_name: Optional[str] = None,
        **kwargs
    ):
        super(AciServiceResponseVnetConfiguration, self).__init__(vnet_name=vnet_name, subnet_name=subnet_name, **kwargs)


class Compute(msrest.serialization.Model):
    """Machine Learning compute object.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: Aks, AmlCompute, DataFactory, DataLakeAnalytics, Databricks, HdInsight, VirtualMachine.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
    }

    _subtype_map = {
        'compute_type': {'AKS': 'Aks', 'AmlCompute': 'AmlCompute', 'DataFactory': 'DataFactory', 'DataLakeAnalytics': 'DataLakeAnalytics', 'Databricks': 'Databricks', 'HDInsight': 'HdInsight', 'VirtualMachine': 'VirtualMachine'}
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ):
        super(Compute, self).__init__(**kwargs)
        self.compute_type = None  # type: Optional[str]
        self.compute_location = compute_location
        self.provisioning_state = None
        self.description = description
        self.created_on = None
        self.modified_on = None
        self.resource_id = resource_id
        self.provisioning_errors = None
        self.is_attached_compute = None


class Aks(Compute):
    """A Machine Learning compute based on AKS.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param properties: AKS properties.
    :type properties: ~azure_machine_learning_workspaces.models.AksProperties
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'properties': {'key': 'properties', 'type': 'AksProperties'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        properties: Optional["AksProperties"] = None,
        **kwargs
    ):
        super(Aks, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'AKS'  # type: str
        self.properties = properties


class AksComputeConfiguration(ComputeConfiguration):
    """AksComputeConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param namespace:
    :type namespace: str
    :param compute_name:
    :type compute_name: str
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'compute_name': {'key': 'computeName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        namespace: Optional[str] = None,
        compute_name: Optional[str] = None,
        **kwargs
    ):
        super(AksComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = 'AKS'  # type: str
        self.namespace = namespace
        self.compute_name = compute_name


class ComputeSecrets(msrest.serialization.Model):
    """Secrets related to a Machine Learning compute. Might differ for every type of compute.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AksComputeSecrets, DatabricksComputeSecrets, VirtualMachineSecrets.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'AKS': 'AksComputeSecrets', 'Databricks': 'DatabricksComputeSecrets', 'VirtualMachine': 'VirtualMachineSecrets'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ComputeSecrets, self).__init__(**kwargs)
        self.compute_type = None  # type: Optional[str]


class AksComputeSecrets(ComputeSecrets):
    """Secrets related to a Machine Learning compute based on AKS.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param user_kube_config: Content of kubeconfig file that can be used to connect to the
     Kubernetes cluster.
    :type user_kube_config: str
    :param admin_kube_config: Content of kubeconfig file that can be used to connect to the
     Kubernetes cluster.
    :type admin_kube_config: str
    :param image_pull_secret_name: Image registry pull secret.
    :type image_pull_secret_name: str
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'user_kube_config': {'key': 'userKubeConfig', 'type': 'str'},
        'admin_kube_config': {'key': 'adminKubeConfig', 'type': 'str'},
        'image_pull_secret_name': {'key': 'imagePullSecretName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        user_kube_config: Optional[str] = None,
        admin_kube_config: Optional[str] = None,
        image_pull_secret_name: Optional[str] = None,
        **kwargs
    ):
        super(AksComputeSecrets, self).__init__(**kwargs)
        self.compute_type = 'AKS'  # type: str
        self.user_kube_config = user_kube_config
        self.admin_kube_config = admin_kube_config
        self.image_pull_secret_name = image_pull_secret_name


class AksDeploymentConfiguration(DeploymentConfigurationBase):
    """AksDeploymentConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param app_insights_enabled:
    :type app_insights_enabled: bool
    :param max_concurrent_requests_per_container:
    :type max_concurrent_requests_per_container: int
    :param max_queue_wait_ms:
    :type max_queue_wait_ms: int
    :param scoring_timeout_ms:
    :type scoring_timeout_ms: int
    :param liveness_probe_requirements:
    :type liveness_probe_requirements:
     ~azure_machine_learning_workspaces.models.LivenessProbeRequirements
    :param model_data_collection: The Model data collection properties.
    :type model_data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param container_resource_requirements:
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirementsautogenerated
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'max_concurrent_requests_per_container': {'key': 'maxConcurrentRequestsPerContainer', 'type': 'int'},
        'max_queue_wait_ms': {'key': 'maxQueueWaitMs', 'type': 'int'},
        'scoring_timeout_ms': {'key': 'scoringTimeoutMs', 'type': 'int'},
        'liveness_probe_requirements': {'key': 'livenessProbeRequirements', 'type': 'LivenessProbeRequirements'},
        'model_data_collection': {'key': 'modelDataCollection', 'type': 'ModelDataCollection'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirementsautogenerated'},
    }

    def __init__(
        self,
        *,
        app_insights_enabled: Optional[bool] = None,
        max_concurrent_requests_per_container: Optional[int] = None,
        max_queue_wait_ms: Optional[int] = None,
        scoring_timeout_ms: Optional[int] = None,
        liveness_probe_requirements: Optional["LivenessProbeRequirements"] = None,
        model_data_collection: Optional["ModelDataCollection"] = None,
        container_resource_requirements: Optional["ContainerResourceRequirementsautogenerated"] = None,
        **kwargs
    ):
        super(AksDeploymentConfiguration, self).__init__(app_insights_enabled=app_insights_enabled, **kwargs)
        self.compute_type = 'AKS'  # type: str
        self.max_concurrent_requests_per_container = max_concurrent_requests_per_container
        self.max_queue_wait_ms = max_queue_wait_ms
        self.scoring_timeout_ms = scoring_timeout_ms
        self.liveness_probe_requirements = liveness_probe_requirements
        self.model_data_collection = model_data_collection
        self.container_resource_requirements = container_resource_requirements


class AksNetworkingConfiguration(msrest.serialization.Model):
    """Advance configuration for AKS networking.

    :param subnet_id: Virtual network subnet resource ID the compute nodes belong to.
    :type subnet_id: str
    :param service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must
     not overlap with any Subnet IP ranges.
    :type service_cidr: str
    :param dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within
     the Kubernetes service address range specified in serviceCidr.
    :type dns_service_ip: str
    :param docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It
     must not overlap with any Subnet IP ranges or the Kubernetes service address range.
    :type docker_bridge_cidr: str
    """

    _validation = {
        'service_cidr': {'pattern': r'^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$'},
        'dns_service_ip': {'pattern': r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'docker_bridge_cidr': {'pattern': r'^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$'},
    }

    _attribute_map = {
        'subnet_id': {'key': 'subnetId', 'type': 'str'},
        'service_cidr': {'key': 'serviceCidr', 'type': 'str'},
        'dns_service_ip': {'key': 'dnsServiceIP', 'type': 'str'},
        'docker_bridge_cidr': {'key': 'dockerBridgeCidr', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        subnet_id: Optional[str] = None,
        service_cidr: Optional[str] = None,
        dns_service_ip: Optional[str] = None,
        docker_bridge_cidr: Optional[str] = None,
        **kwargs
    ):
        super(AksNetworkingConfiguration, self).__init__(**kwargs)
        self.subnet_id = subnet_id
        self.service_cidr = service_cidr
        self.dns_service_ip = dns_service_ip
        self.docker_bridge_cidr = docker_bridge_cidr


class AksProperties(msrest.serialization.Model):
    """AKS properties.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param cluster_fqdn: Cluster full qualified domain name.
    :type cluster_fqdn: str
    :ivar system_services: System services.
    :vartype system_services: list[~azure_machine_learning_workspaces.models.SystemService]
    :param agent_count: Number of agents.
    :type agent_count: int
    :param agent_vm_size: Agent virtual machine size.
    :type agent_vm_size: str
    :param ssl_configuration: SSL configuration.
    :type ssl_configuration:
     ~azure_machine_learning_workspaces.models.SSLConfigurationautogenerated
    :param aks_networking_configuration: AKS networking configuration for vnet.
    :type aks_networking_configuration:
     ~azure_machine_learning_workspaces.models.AksNetworkingConfiguration
    """

    _validation = {
        'system_services': {'readonly': True},
        'agent_count': {'minimum': 1},
    }

    _attribute_map = {
        'cluster_fqdn': {'key': 'clusterFqdn', 'type': 'str'},
        'system_services': {'key': 'systemServices', 'type': '[SystemService]'},
        'agent_count': {'key': 'agentCount', 'type': 'int'},
        'agent_vm_size': {'key': 'agentVMSize', 'type': 'str'},
        'ssl_configuration': {'key': 'sslConfiguration', 'type': 'SSLConfigurationautogenerated'},
        'aks_networking_configuration': {'key': 'aksNetworkingConfiguration', 'type': 'AksNetworkingConfiguration'},
    }

    def __init__(
        self,
        *,
        cluster_fqdn: Optional[str] = None,
        agent_count: Optional[int] = None,
        agent_vm_size: Optional[str] = None,
        ssl_configuration: Optional["SSLConfigurationautogenerated"] = None,
        aks_networking_configuration: Optional["AksNetworkingConfiguration"] = None,
        **kwargs
    ):
        super(AksProperties, self).__init__(**kwargs)
        self.cluster_fqdn = cluster_fqdn
        self.system_services = None
        self.agent_count = agent_count
        self.agent_vm_size = agent_vm_size
        self.ssl_configuration = ssl_configuration
        self.aks_networking_configuration = aks_networking_configuration


class AksReplicaStatus(msrest.serialization.Model):
    """AksReplicaStatus.

    :param desired_replicas: The desired number of replicas.
    :type desired_replicas: int
    :param updated_replicas: The number of updated replicas.
    :type updated_replicas: int
    :param available_replicas: The number of available replicas.
    :type available_replicas: int
    :param error: The error details.
    :type error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    """

    _attribute_map = {
        'desired_replicas': {'key': 'desiredReplicas', 'type': 'int'},
        'updated_replicas': {'key': 'updatedReplicas', 'type': 'int'},
        'available_replicas': {'key': 'availableReplicas', 'type': 'int'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
    }

    def __init__(
        self,
        *,
        desired_replicas: Optional[int] = None,
        updated_replicas: Optional[int] = None,
        available_replicas: Optional[int] = None,
        error: Optional["ErrorResponseautogenerated2"] = None,
        **kwargs
    ):
        super(AksReplicaStatus, self).__init__(**kwargs)
        self.desired_replicas = desired_replicas
        self.updated_replicas = updated_replicas
        self.available_replicas = available_replicas
        self.error = error


class ErrorResponseautogenerated2(msrest.serialization.Model):
    """Error response information.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message.
    :vartype message: str
    :ivar details: An array of error detail objects.
    :vartype details: list[~azure_machine_learning_workspaces.models.ErrorDetail]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'details': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorResponseautogenerated2, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.details = None


class AksReplicaStatusError(ErrorResponseautogenerated2):
    """The error details.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message.
    :vartype message: str
    :ivar details: An array of error detail objects.
    :vartype details: list[~azure_machine_learning_workspaces.models.ErrorDetail]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'details': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AksReplicaStatusError, self).__init__(**kwargs)


class CreateEndpointVariantRequest(CreateServiceRequest):
    """The Variant properties.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AksServiceCreateRequest.

    All required parameters must be populated in order to send to Azure.

    :param description: The description of the service.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service properties dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :param keys: The authentication keys.
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param environment_image_request: The Environment, models and assets needed for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageRequest
    :param location: The name of the Azure location/region.
    :type location: str
    :param is_default: Is this the default variant.
    :type is_default: bool
    :param traffic_percentile: The amount of traffic variant receives.
    :type traffic_percentile: float
    :param type: The type of the variant. Possible values include: "Control", "Treatment".
    :type type: str or ~azure_machine_learning_workspaces.models.VariantType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageRequest'},
        'location': {'key': 'location', 'type': 'str'},
        'is_default': {'key': 'isDefault', 'type': 'bool'},
        'traffic_percentile': {'key': 'trafficPercentile', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'AKS': 'AksServiceCreateRequest'}
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        keys: Optional["AuthKeys"] = None,
        environment_image_request: Optional["EnvironmentImageRequest"] = None,
        location: Optional[str] = None,
        is_default: Optional[bool] = None,
        traffic_percentile: Optional[float] = None,
        type: Optional[Union[str, "VariantType"]] = None,
        **kwargs
    ):
        super(CreateEndpointVariantRequest, self).__init__(description=description, kv_tags=kv_tags, properties=properties, keys=keys, environment_image_request=environment_image_request, location=location, **kwargs)
        self.compute_type = 'Custom'  # type: str
        self.is_default = is_default
        self.traffic_percentile = traffic_percentile
        self.type = type


class AksServiceCreateRequest(CreateEndpointVariantRequest):
    """The request to create an AKS service.

    All required parameters must be populated in order to send to Azure.

    :param description: The description of the service.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service properties dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :param keys: The authentication keys.
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param environment_image_request: The Environment, models and assets needed for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageRequest
    :param location: The name of the Azure location/region.
    :type location: str
    :param is_default: Is this the default variant.
    :type is_default: bool
    :param traffic_percentile: The amount of traffic variant receives.
    :type traffic_percentile: float
    :param type: The type of the variant. Possible values include: "Control", "Treatment".
    :type type: str or ~azure_machine_learning_workspaces.models.VariantType
    :param num_replicas: The number of replicas on the cluster.
    :type num_replicas: int
    :param data_collection: Details of the data collection options specified.
    :type data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param compute_name: The name of the compute resource.
    :type compute_name: str
    :param app_insights_enabled: Whether or not Application Insights is enabled.
    :type app_insights_enabled: bool
    :param auto_scaler: The auto scaler properties.
    :type auto_scaler: ~azure_machine_learning_workspaces.models.AutoScaler
    :param container_resource_requirements: The container resource requirements.
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirements
    :param max_concurrent_requests_per_container: The maximum number of concurrent requests per
     container.
    :type max_concurrent_requests_per_container: int
    :param max_queue_wait_ms: Maximum time a request will wait in the queue (in milliseconds).
     After this time, the service will return 503 (Service Unavailable).
    :type max_queue_wait_ms: int
    :param namespace: Kubernetes namespace for the service.
    :type namespace: str
    :param scoring_timeout_ms: The scoring timeout in milliseconds.
    :type scoring_timeout_ms: int
    :param auth_enabled: Whether or not authentication is enabled.
    :type auth_enabled: bool
    :param liveness_probe_requirements: The liveness probe requirements.
    :type liveness_probe_requirements:
     ~azure_machine_learning_workspaces.models.LivenessProbeRequirements
    :param aad_auth_enabled: Whether or not AAD authentication is enabled.
    :type aad_auth_enabled: bool
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageRequest'},
        'location': {'key': 'location', 'type': 'str'},
        'is_default': {'key': 'isDefault', 'type': 'bool'},
        'traffic_percentile': {'key': 'trafficPercentile', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
        'num_replicas': {'key': 'numReplicas', 'type': 'int'},
        'data_collection': {'key': 'dataCollection', 'type': 'ModelDataCollection'},
        'compute_name': {'key': 'computeName', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'auto_scaler': {'key': 'autoScaler', 'type': 'AutoScaler'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirements'},
        'max_concurrent_requests_per_container': {'key': 'maxConcurrentRequestsPerContainer', 'type': 'int'},
        'max_queue_wait_ms': {'key': 'maxQueueWaitMs', 'type': 'int'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'scoring_timeout_ms': {'key': 'scoringTimeoutMs', 'type': 'int'},
        'auth_enabled': {'key': 'authEnabled', 'type': 'bool'},
        'liveness_probe_requirements': {'key': 'livenessProbeRequirements', 'type': 'LivenessProbeRequirements'},
        'aad_auth_enabled': {'key': 'aadAuthEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        keys: Optional["AuthKeys"] = None,
        environment_image_request: Optional["EnvironmentImageRequest"] = None,
        location: Optional[str] = None,
        is_default: Optional[bool] = None,
        traffic_percentile: Optional[float] = None,
        type: Optional[Union[str, "VariantType"]] = None,
        num_replicas: Optional[int] = None,
        data_collection: Optional["ModelDataCollection"] = None,
        compute_name: Optional[str] = None,
        app_insights_enabled: Optional[bool] = None,
        auto_scaler: Optional["AutoScaler"] = None,
        container_resource_requirements: Optional["ContainerResourceRequirements"] = None,
        max_concurrent_requests_per_container: Optional[int] = None,
        max_queue_wait_ms: Optional[int] = None,
        namespace: Optional[str] = None,
        scoring_timeout_ms: Optional[int] = None,
        auth_enabled: Optional[bool] = None,
        liveness_probe_requirements: Optional["LivenessProbeRequirements"] = None,
        aad_auth_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(AksServiceCreateRequest, self).__init__(description=description, kv_tags=kv_tags, properties=properties, keys=keys, environment_image_request=environment_image_request, location=location, is_default=is_default, traffic_percentile=traffic_percentile, type=type, **kwargs)
        self.compute_type = 'AKS'  # type: str
        self.num_replicas = num_replicas
        self.data_collection = data_collection
        self.compute_name = compute_name
        self.app_insights_enabled = app_insights_enabled
        self.auto_scaler = auto_scaler
        self.container_resource_requirements = container_resource_requirements
        self.max_concurrent_requests_per_container = max_concurrent_requests_per_container
        self.max_queue_wait_ms = max_queue_wait_ms
        self.namespace = namespace
        self.scoring_timeout_ms = scoring_timeout_ms
        self.auth_enabled = auth_enabled
        self.liveness_probe_requirements = liveness_probe_requirements
        self.aad_auth_enabled = aad_auth_enabled


class AutoScaler(msrest.serialization.Model):
    """The Auto Scaler properties.

    :param autoscale_enabled: Option to enable/disable auto scaling.
    :type autoscale_enabled: bool
    :param min_replicas: The minimum number of replicas to scale down to.
    :type min_replicas: int
    :param max_replicas: The maximum number of replicas in the cluster.
    :type max_replicas: int
    :param target_utilization: The target utilization percentage to use for determining whether to
     scale the cluster.
    :type target_utilization: int
    :param refresh_period_in_seconds: The amount of seconds to wait between auto scale updates.
    :type refresh_period_in_seconds: int
    """

    _attribute_map = {
        'autoscale_enabled': {'key': 'autoscaleEnabled', 'type': 'bool'},
        'min_replicas': {'key': 'minReplicas', 'type': 'int'},
        'max_replicas': {'key': 'maxReplicas', 'type': 'int'},
        'target_utilization': {'key': 'targetUtilization', 'type': 'int'},
        'refresh_period_in_seconds': {'key': 'refreshPeriodInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        autoscale_enabled: Optional[bool] = None,
        min_replicas: Optional[int] = None,
        max_replicas: Optional[int] = None,
        target_utilization: Optional[int] = None,
        refresh_period_in_seconds: Optional[int] = None,
        **kwargs
    ):
        super(AutoScaler, self).__init__(**kwargs)
        self.autoscale_enabled = autoscale_enabled
        self.min_replicas = min_replicas
        self.max_replicas = max_replicas
        self.target_utilization = target_utilization
        self.refresh_period_in_seconds = refresh_period_in_seconds


class AksServiceCreateRequestAutoScaler(AutoScaler):
    """The auto scaler properties.

    :param autoscale_enabled: Option to enable/disable auto scaling.
    :type autoscale_enabled: bool
    :param min_replicas: The minimum number of replicas to scale down to.
    :type min_replicas: int
    :param max_replicas: The maximum number of replicas in the cluster.
    :type max_replicas: int
    :param target_utilization: The target utilization percentage to use for determining whether to
     scale the cluster.
    :type target_utilization: int
    :param refresh_period_in_seconds: The amount of seconds to wait between auto scale updates.
    :type refresh_period_in_seconds: int
    """

    _attribute_map = {
        'autoscale_enabled': {'key': 'autoscaleEnabled', 'type': 'bool'},
        'min_replicas': {'key': 'minReplicas', 'type': 'int'},
        'max_replicas': {'key': 'maxReplicas', 'type': 'int'},
        'target_utilization': {'key': 'targetUtilization', 'type': 'int'},
        'refresh_period_in_seconds': {'key': 'refreshPeriodInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        autoscale_enabled: Optional[bool] = None,
        min_replicas: Optional[int] = None,
        max_replicas: Optional[int] = None,
        target_utilization: Optional[int] = None,
        refresh_period_in_seconds: Optional[int] = None,
        **kwargs
    ):
        super(AksServiceCreateRequestAutoScaler, self).__init__(autoscale_enabled=autoscale_enabled, min_replicas=min_replicas, max_replicas=max_replicas, target_utilization=target_utilization, refresh_period_in_seconds=refresh_period_in_seconds, **kwargs)


class AksServiceCreateRequestDataCollection(ModelDataCollection):
    """Details of the data collection options specified.

    :param event_hub_enabled: Option for enabling/disabling Event Hub.
    :type event_hub_enabled: bool
    :param storage_enabled: Option for enabling/disabling storage.
    :type storage_enabled: bool
    """

    _attribute_map = {
        'event_hub_enabled': {'key': 'eventHubEnabled', 'type': 'bool'},
        'storage_enabled': {'key': 'storageEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        event_hub_enabled: Optional[bool] = None,
        storage_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(AksServiceCreateRequestDataCollection, self).__init__(event_hub_enabled=event_hub_enabled, storage_enabled=storage_enabled, **kwargs)


class LivenessProbeRequirements(msrest.serialization.Model):
    """LivenessProbeRequirements.

    :param failure_threshold: The number of failures to allow before returning an unhealthy status.
    :type failure_threshold: int
    :param success_threshold: The number of successful probes before returning a healthy status.
    :type success_threshold: int
    :param timeout_seconds: The probe timeout in seconds.
    :type timeout_seconds: int
    :param period_seconds: The length of time between probes in seconds.
    :type period_seconds: int
    :param initial_delay_seconds: The delay before the first probe in seconds.
    :type initial_delay_seconds: int
    """

    _attribute_map = {
        'failure_threshold': {'key': 'failureThreshold', 'type': 'int'},
        'success_threshold': {'key': 'successThreshold', 'type': 'int'},
        'timeout_seconds': {'key': 'timeoutSeconds', 'type': 'int'},
        'period_seconds': {'key': 'periodSeconds', 'type': 'int'},
        'initial_delay_seconds': {'key': 'initialDelaySeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        success_threshold: Optional[int] = None,
        timeout_seconds: Optional[int] = None,
        period_seconds: Optional[int] = None,
        initial_delay_seconds: Optional[int] = None,
        **kwargs
    ):
        super(LivenessProbeRequirements, self).__init__(**kwargs)
        self.failure_threshold = failure_threshold
        self.success_threshold = success_threshold
        self.timeout_seconds = timeout_seconds
        self.period_seconds = period_seconds
        self.initial_delay_seconds = initial_delay_seconds


class AksServiceCreateRequestLivenessProbeRequirements(LivenessProbeRequirements):
    """The liveness probe requirements.

    :param failure_threshold: The number of failures to allow before returning an unhealthy status.
    :type failure_threshold: int
    :param success_threshold: The number of successful probes before returning a healthy status.
    :type success_threshold: int
    :param timeout_seconds: The probe timeout in seconds.
    :type timeout_seconds: int
    :param period_seconds: The length of time between probes in seconds.
    :type period_seconds: int
    :param initial_delay_seconds: The delay before the first probe in seconds.
    :type initial_delay_seconds: int
    """

    _attribute_map = {
        'failure_threshold': {'key': 'failureThreshold', 'type': 'int'},
        'success_threshold': {'key': 'successThreshold', 'type': 'int'},
        'timeout_seconds': {'key': 'timeoutSeconds', 'type': 'int'},
        'period_seconds': {'key': 'periodSeconds', 'type': 'int'},
        'initial_delay_seconds': {'key': 'initialDelaySeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        success_threshold: Optional[int] = None,
        timeout_seconds: Optional[int] = None,
        period_seconds: Optional[int] = None,
        initial_delay_seconds: Optional[int] = None,
        **kwargs
    ):
        super(AksServiceCreateRequestLivenessProbeRequirements, self).__init__(failure_threshold=failure_threshold, success_threshold=success_threshold, timeout_seconds=timeout_seconds, period_seconds=period_seconds, initial_delay_seconds=initial_delay_seconds, **kwargs)


class AksVariantResponse(ServiceResponseBase):
    """The response for an AKS variant.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AksServiceResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param description: The service description.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service property dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :ivar state: The current state of the service. Possible values include: "Transitioning",
     "Healthy", "Unhealthy", "Failed", "Unschedulable".
    :vartype state: str or ~azure_machine_learning_workspaces.models.WebServiceState
    :ivar error: The error details.
    :vartype error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param deployment_type: The deployment type for the service. Possible values include:
     "GRPCRealtimeEndpoint", "HttpRealtimeEndpoint", "Batch".
    :type deployment_type: str or ~azure_machine_learning_workspaces.models.DeploymentType
    :param is_default: Is this the default variant.
    :type is_default: bool
    :param traffic_percentile: The amount of traffic variant receives.
    :type traffic_percentile: float
    :param type: The type of the variant. Possible values include: "Control", "Treatment".
    :type type: str or ~azure_machine_learning_workspaces.models.VariantType
    """

    _validation = {
        'state': {'readonly': True},
        'error': {'readonly': True},
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'state': {'key': 'state', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'deployment_type': {'key': 'deploymentType', 'type': 'str'},
        'is_default': {'key': 'isDefault', 'type': 'bool'},
        'traffic_percentile': {'key': 'trafficPercentile', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'AKS': 'AksServiceResponse'}
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        deployment_type: Optional[Union[str, "DeploymentType"]] = None,
        is_default: Optional[bool] = None,
        traffic_percentile: Optional[float] = None,
        type: Optional[Union[str, "VariantType"]] = None,
        **kwargs
    ):
        super(AksVariantResponse, self).__init__(description=description, kv_tags=kv_tags, properties=properties, deployment_type=deployment_type, **kwargs)
        self.compute_type = 'Custom'  # type: str
        self.is_default = is_default
        self.traffic_percentile = traffic_percentile
        self.type = type


class AksServiceResponse(AksVariantResponse):
    """The response for an AKS service.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param description: The service description.
    :type description: str
    :param kv_tags: The service tag dictionary. Tags are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The service property dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :ivar state: The current state of the service. Possible values include: "Transitioning",
     "Healthy", "Unhealthy", "Failed", "Unschedulable".
    :vartype state: str or ~azure_machine_learning_workspaces.models.WebServiceState
    :ivar error: The error details.
    :vartype error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    :param compute_type: Required. The compute environment type for the service.Constant filled by
     server.  Possible values include: "ACI", "AKS".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeEnvironmentType
    :param deployment_type: The deployment type for the service. Possible values include:
     "GRPCRealtimeEndpoint", "HttpRealtimeEndpoint", "Batch".
    :type deployment_type: str or ~azure_machine_learning_workspaces.models.DeploymentType
    :param is_default: Is this the default variant.
    :type is_default: bool
    :param traffic_percentile: The amount of traffic variant receives.
    :type traffic_percentile: float
    :param type: The type of the variant. Possible values include: "Control", "Treatment".
    :type type: str or ~azure_machine_learning_workspaces.models.VariantType
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param container_resource_requirements: The container resource requirements.
    :type container_resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirements
    :param max_concurrent_requests_per_container: The maximum number of concurrent requests per
     container.
    :type max_concurrent_requests_per_container: int
    :param max_queue_wait_ms: Maximum time a request will wait in the queue (in milliseconds).
     After this time, the service will return 503 (Service Unavailable).
    :type max_queue_wait_ms: int
    :param compute_name: The name of the compute resource.
    :type compute_name: str
    :param namespace: The Kubernetes namespace of the deployment.
    :type namespace: str
    :param num_replicas: The number of replicas on the cluster.
    :type num_replicas: int
    :param data_collection: Details of the data collection options specified.
    :type data_collection: ~azure_machine_learning_workspaces.models.ModelDataCollection
    :param app_insights_enabled: Whether or not Application Insights is enabled.
    :type app_insights_enabled: bool
    :param auto_scaler: The auto scaler properties.
    :type auto_scaler: ~azure_machine_learning_workspaces.models.AutoScaler
    :ivar scoring_uri: The Uri for sending scoring requests.
    :vartype scoring_uri: str
    :ivar deployment_status: The deployment status.
    :vartype deployment_status: ~azure_machine_learning_workspaces.models.AksReplicaStatus
    :param scoring_timeout_ms: The scoring timeout in milliseconds.
    :type scoring_timeout_ms: int
    :param liveness_probe_requirements: The liveness probe requirements.
    :type liveness_probe_requirements:
     ~azure_machine_learning_workspaces.models.LivenessProbeRequirements
    :param auth_enabled: Whether or not authentication is enabled.
    :type auth_enabled: bool
    :param aad_auth_enabled: Whether or not AAD authentication is enabled.
    :type aad_auth_enabled: bool
    :ivar swagger_uri: The Uri for sending swagger requests.
    :vartype swagger_uri: str
    :ivar model_config_map: Details on the models and configurations.
    :vartype model_config_map: dict[str, object]
    :param environment_image_request: The Environment, models and assets used for inferencing.
    :type environment_image_request:
     ~azure_machine_learning_workspaces.models.EnvironmentImageResponse
    """

    _validation = {
        'state': {'readonly': True},
        'error': {'readonly': True},
        'compute_type': {'required': True},
        'scoring_uri': {'readonly': True},
        'deployment_status': {'readonly': True},
        'swagger_uri': {'readonly': True},
        'model_config_map': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'state': {'key': 'state', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'deployment_type': {'key': 'deploymentType', 'type': 'str'},
        'is_default': {'key': 'isDefault', 'type': 'bool'},
        'traffic_percentile': {'key': 'trafficPercentile', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
        'models': {'key': 'models', 'type': '[Model]'},
        'container_resource_requirements': {'key': 'containerResourceRequirements', 'type': 'ContainerResourceRequirements'},
        'max_concurrent_requests_per_container': {'key': 'maxConcurrentRequestsPerContainer', 'type': 'int'},
        'max_queue_wait_ms': {'key': 'maxQueueWaitMs', 'type': 'int'},
        'compute_name': {'key': 'computeName', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'num_replicas': {'key': 'numReplicas', 'type': 'int'},
        'data_collection': {'key': 'dataCollection', 'type': 'ModelDataCollection'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'auto_scaler': {'key': 'autoScaler', 'type': 'AutoScaler'},
        'scoring_uri': {'key': 'scoringUri', 'type': 'str'},
        'deployment_status': {'key': 'deploymentStatus', 'type': 'AksReplicaStatus'},
        'scoring_timeout_ms': {'key': 'scoringTimeoutMs', 'type': 'int'},
        'liveness_probe_requirements': {'key': 'livenessProbeRequirements', 'type': 'LivenessProbeRequirements'},
        'auth_enabled': {'key': 'authEnabled', 'type': 'bool'},
        'aad_auth_enabled': {'key': 'aadAuthEnabled', 'type': 'bool'},
        'swagger_uri': {'key': 'swaggerUri', 'type': 'str'},
        'model_config_map': {'key': 'modelConfigMap', 'type': '{object}'},
        'environment_image_request': {'key': 'environmentImageRequest', 'type': 'EnvironmentImageResponse'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        deployment_type: Optional[Union[str, "DeploymentType"]] = None,
        is_default: Optional[bool] = None,
        traffic_percentile: Optional[float] = None,
        type: Optional[Union[str, "VariantType"]] = None,
        models: Optional[List["Model"]] = None,
        container_resource_requirements: Optional["ContainerResourceRequirements"] = None,
        max_concurrent_requests_per_container: Optional[int] = None,
        max_queue_wait_ms: Optional[int] = None,
        compute_name: Optional[str] = None,
        namespace: Optional[str] = None,
        num_replicas: Optional[int] = None,
        data_collection: Optional["ModelDataCollection"] = None,
        app_insights_enabled: Optional[bool] = None,
        auto_scaler: Optional["AutoScaler"] = None,
        scoring_timeout_ms: Optional[int] = None,
        liveness_probe_requirements: Optional["LivenessProbeRequirements"] = None,
        auth_enabled: Optional[bool] = None,
        aad_auth_enabled: Optional[bool] = None,
        environment_image_request: Optional["EnvironmentImageResponse"] = None,
        **kwargs
    ):
        super(AksServiceResponse, self).__init__(description=description, kv_tags=kv_tags, properties=properties, deployment_type=deployment_type, is_default=is_default, traffic_percentile=traffic_percentile, type=type, **kwargs)
        self.compute_type = 'AKS'  # type: str
        self.models = models
        self.container_resource_requirements = container_resource_requirements
        self.max_concurrent_requests_per_container = max_concurrent_requests_per_container
        self.max_queue_wait_ms = max_queue_wait_ms
        self.compute_name = compute_name
        self.namespace = namespace
        self.num_replicas = num_replicas
        self.data_collection = data_collection
        self.app_insights_enabled = app_insights_enabled
        self.auto_scaler = auto_scaler
        self.scoring_uri = None
        self.deployment_status = None
        self.scoring_timeout_ms = scoring_timeout_ms
        self.liveness_probe_requirements = liveness_probe_requirements
        self.auth_enabled = auth_enabled
        self.aad_auth_enabled = aad_auth_enabled
        self.swagger_uri = None
        self.model_config_map = None
        self.environment_image_request = environment_image_request


class AksServiceResponseAutoScaler(AutoScaler):
    """The auto scaler properties.

    :param autoscale_enabled: Option to enable/disable auto scaling.
    :type autoscale_enabled: bool
    :param min_replicas: The minimum number of replicas to scale down to.
    :type min_replicas: int
    :param max_replicas: The maximum number of replicas in the cluster.
    :type max_replicas: int
    :param target_utilization: The target utilization percentage to use for determining whether to
     scale the cluster.
    :type target_utilization: int
    :param refresh_period_in_seconds: The amount of seconds to wait between auto scale updates.
    :type refresh_period_in_seconds: int
    """

    _attribute_map = {
        'autoscale_enabled': {'key': 'autoscaleEnabled', 'type': 'bool'},
        'min_replicas': {'key': 'minReplicas', 'type': 'int'},
        'max_replicas': {'key': 'maxReplicas', 'type': 'int'},
        'target_utilization': {'key': 'targetUtilization', 'type': 'int'},
        'refresh_period_in_seconds': {'key': 'refreshPeriodInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        autoscale_enabled: Optional[bool] = None,
        min_replicas: Optional[int] = None,
        max_replicas: Optional[int] = None,
        target_utilization: Optional[int] = None,
        refresh_period_in_seconds: Optional[int] = None,
        **kwargs
    ):
        super(AksServiceResponseAutoScaler, self).__init__(autoscale_enabled=autoscale_enabled, min_replicas=min_replicas, max_replicas=max_replicas, target_utilization=target_utilization, refresh_period_in_seconds=refresh_period_in_seconds, **kwargs)


class AksServiceResponseDataCollection(ModelDataCollection):
    """Details of the data collection options specified.

    :param event_hub_enabled: Option for enabling/disabling Event Hub.
    :type event_hub_enabled: bool
    :param storage_enabled: Option for enabling/disabling storage.
    :type storage_enabled: bool
    """

    _attribute_map = {
        'event_hub_enabled': {'key': 'eventHubEnabled', 'type': 'bool'},
        'storage_enabled': {'key': 'storageEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        event_hub_enabled: Optional[bool] = None,
        storage_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(AksServiceResponseDataCollection, self).__init__(event_hub_enabled=event_hub_enabled, storage_enabled=storage_enabled, **kwargs)


class AksServiceResponseDeploymentStatus(AksReplicaStatus):
    """The deployment status.

    :param desired_replicas: The desired number of replicas.
    :type desired_replicas: int
    :param updated_replicas: The number of updated replicas.
    :type updated_replicas: int
    :param available_replicas: The number of available replicas.
    :type available_replicas: int
    :param error: The error details.
    :type error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    """

    _attribute_map = {
        'desired_replicas': {'key': 'desiredReplicas', 'type': 'int'},
        'updated_replicas': {'key': 'updatedReplicas', 'type': 'int'},
        'available_replicas': {'key': 'availableReplicas', 'type': 'int'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
    }

    def __init__(
        self,
        *,
        desired_replicas: Optional[int] = None,
        updated_replicas: Optional[int] = None,
        available_replicas: Optional[int] = None,
        error: Optional["ErrorResponseautogenerated2"] = None,
        **kwargs
    ):
        super(AksServiceResponseDeploymentStatus, self).__init__(desired_replicas=desired_replicas, updated_replicas=updated_replicas, available_replicas=available_replicas, error=error, **kwargs)


class AksServiceResponseEnvironmentImageRequest(EnvironmentImageResponse):
    """The Environment, models and assets used for inferencing.

    :param driver_program: The name of the driver file.
    :type driver_program: str
    :param assets: The list of assets.
    :type assets: list[~azure_machine_learning_workspaces.models.ImageAsset]
    :param model_ids: The list of model Ids.
    :type model_ids: list[str]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment: The details of the AZURE ML environment.
    :type environment: ~azure_machine_learning_workspaces.models.ModelEnvironmentDefinitionResponse
    :param environment_reference: The unique identifying details of the AZURE ML environment.
    :type environment_reference: ~azure_machine_learning_workspaces.models.EnvironmentReference
    """

    _attribute_map = {
        'driver_program': {'key': 'driverProgram', 'type': 'str'},
        'assets': {'key': 'assets', 'type': '[ImageAsset]'},
        'model_ids': {'key': 'modelIds', 'type': '[str]'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment': {'key': 'environment', 'type': 'ModelEnvironmentDefinitionResponse'},
        'environment_reference': {'key': 'environmentReference', 'type': 'EnvironmentReference'},
    }

    def __init__(
        self,
        *,
        driver_program: Optional[str] = None,
        assets: Optional[List["ImageAsset"]] = None,
        model_ids: Optional[List[str]] = None,
        models: Optional[List["Model"]] = None,
        environment: Optional["ModelEnvironmentDefinitionResponse"] = None,
        environment_reference: Optional["EnvironmentReference"] = None,
        **kwargs
    ):
        super(AksServiceResponseEnvironmentImageRequest, self).__init__(driver_program=driver_program, assets=assets, model_ids=model_ids, models=models, environment=environment, environment_reference=environment_reference, **kwargs)


class AksServiceResponseLivenessProbeRequirements(LivenessProbeRequirements):
    """The liveness probe requirements.

    :param failure_threshold: The number of failures to allow before returning an unhealthy status.
    :type failure_threshold: int
    :param success_threshold: The number of successful probes before returning a healthy status.
    :type success_threshold: int
    :param timeout_seconds: The probe timeout in seconds.
    :type timeout_seconds: int
    :param period_seconds: The length of time between probes in seconds.
    :type period_seconds: int
    :param initial_delay_seconds: The delay before the first probe in seconds.
    :type initial_delay_seconds: int
    """

    _attribute_map = {
        'failure_threshold': {'key': 'failureThreshold', 'type': 'int'},
        'success_threshold': {'key': 'successThreshold', 'type': 'int'},
        'timeout_seconds': {'key': 'timeoutSeconds', 'type': 'int'},
        'period_seconds': {'key': 'periodSeconds', 'type': 'int'},
        'initial_delay_seconds': {'key': 'initialDelaySeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        success_threshold: Optional[int] = None,
        timeout_seconds: Optional[int] = None,
        period_seconds: Optional[int] = None,
        initial_delay_seconds: Optional[int] = None,
        **kwargs
    ):
        super(AksServiceResponseLivenessProbeRequirements, self).__init__(failure_threshold=failure_threshold, success_threshold=success_threshold, timeout_seconds=timeout_seconds, period_seconds=period_seconds, initial_delay_seconds=initial_delay_seconds, **kwargs)


class AmlCompute(Compute):
    """An Azure Machine Learning compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param properties: AML Compute properties.
    :type properties: ~azure_machine_learning_workspaces.models.AmlComputeProperties
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'properties': {'key': 'properties', 'type': 'AmlComputeProperties'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        properties: Optional["AmlComputeProperties"] = None,
        **kwargs
    ):
        super(AmlCompute, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'AmlCompute'  # type: str
        self.properties = properties


class AmlComputeDeploymentConfiguration(DeploymentConfigurationBase):
    """AmlComputeDeploymentConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param app_insights_enabled:
    :type app_insights_enabled: bool
    :param instance_type:
    :type instance_type: str
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
        'instance_type': {'key': 'instanceType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        app_insights_enabled: Optional[bool] = None,
        instance_type: Optional[str] = None,
        **kwargs
    ):
        super(AmlComputeDeploymentConfiguration, self).__init__(app_insights_enabled=app_insights_enabled, **kwargs)
        self.compute_type = 'AMLCompute'  # type: str
        self.instance_type = instance_type


class AmlComputeNodeInformation(msrest.serialization.Model):
    """Compute node information related to a AmlCompute.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar node_id: ID of the compute node.
    :vartype node_id: str
    :ivar private_ip_address: Private IP address of the compute node.
    :vartype private_ip_address: str
    :ivar public_ip_address: Public IP address of the compute node.
    :vartype public_ip_address: str
    :ivar port: SSH port number of the node.
    :vartype port: int
    :ivar node_state: State of the compute node. Values are idle, running, preparing, unusable,
     leaving and preempted. Possible values include: "idle", "running", "preparing", "unusable",
     "leaving", "preempted".
    :vartype node_state: str or ~azure_machine_learning_workspaces.models.NodeState
    :ivar run_id: ID of the Experiment running on the node, if any else null.
    :vartype run_id: str
    """

    _validation = {
        'node_id': {'readonly': True},
        'private_ip_address': {'readonly': True},
        'public_ip_address': {'readonly': True},
        'port': {'readonly': True},
        'node_state': {'readonly': True},
        'run_id': {'readonly': True},
    }

    _attribute_map = {
        'node_id': {'key': 'nodeId', 'type': 'str'},
        'private_ip_address': {'key': 'privateIpAddress', 'type': 'str'},
        'public_ip_address': {'key': 'publicIpAddress', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'node_state': {'key': 'nodeState', 'type': 'str'},
        'run_id': {'key': 'runId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AmlComputeNodeInformation, self).__init__(**kwargs)
        self.node_id = None
        self.private_ip_address = None
        self.public_ip_address = None
        self.port = None
        self.node_state = None
        self.run_id = None


class ComputeNodesInformation(msrest.serialization.Model):
    """Compute nodes information related to a Machine Learning compute. Might differ for every type of compute.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AmlComputeNodesInformation.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :ivar next_link: The continuation token.
    :vartype next_link: str
    """

    _validation = {
        'compute_type': {'required': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    _subtype_map = {
        'compute_type': {'AmlCompute': 'AmlComputeNodesInformation'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ComputeNodesInformation, self).__init__(**kwargs)
        self.compute_type = None  # type: Optional[str]
        self.next_link = None


class AmlComputeNodesInformation(ComputeNodesInformation):
    """Compute node information related to a AmlCompute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :ivar next_link: The continuation token.
    :vartype next_link: str
    :ivar nodes: The collection of returned AmlCompute nodes details.
    :vartype nodes: list[~azure_machine_learning_workspaces.models.AmlComputeNodeInformation]
    """

    _validation = {
        'compute_type': {'required': True},
        'next_link': {'readonly': True},
        'nodes': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
        'nodes': {'key': 'nodes', 'type': '[AmlComputeNodeInformation]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AmlComputeNodesInformation, self).__init__(**kwargs)
        self.compute_type = 'AmlCompute'  # type: str
        self.nodes = None


class AmlComputeProperties(msrest.serialization.Model):
    """AML Compute properties.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param os_type: Compute OS Type. Possible values include: "Linux", "Windows".
    :type os_type: str or ~azure_machine_learning_workspaces.models.OsType
    :param vm_size: Virtual Machine Size.
    :type vm_size: str
    :param vm_priority: Virtual Machine priority. Possible values include: "Dedicated",
     "LowPriority".
    :type vm_priority: str or ~azure_machine_learning_workspaces.models.VmPriority
    :param virtual_machine_image: Virtual Machine image for AML Compute - windows only.
    :type virtual_machine_image: ~azure_machine_learning_workspaces.models.VirtualMachineImage
    :param isolated_network: Network is isolated or not.
    :type isolated_network: bool
    :param scale_settings: Scale settings for AML Compute.
    :type scale_settings: ~azure_machine_learning_workspaces.models.ScaleSettingsautogenerated
    :param user_account_credentials: Credentials for an administrator user account that will be
     created on each compute node.
    :type user_account_credentials:
     ~azure_machine_learning_workspaces.models.UserAccountCredentials
    :param subnet: Virtual network subnet resource ID the compute nodes belong to.
    :type subnet: ~azure_machine_learning_workspaces.models.ResourceId
    :param remote_login_port_public_access: State of the public SSH port. Possible values are:
     Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled -
     Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified -
     Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
     else is open all public nodes. It can be default only during cluster creation time, after
     creation it will be either enabled or disabled. Possible values include: "Enabled", "Disabled",
     "NotSpecified". Default value: "NotSpecified".
    :type remote_login_port_public_access: str or
     ~azure_machine_learning_workspaces.models.RemoteLoginPortPublicAccess
    :ivar allocation_state: Allocation state of the compute. Possible values are: steady -
     Indicates that the compute is not resizing. There are no changes to the number of compute nodes
     in the compute in progress. A compute enters this state when it is created and when no
     operations are being performed on the compute to change the number of compute nodes. resizing -
     Indicates that the compute is resizing; that is, compute nodes are being added to or removed
     from the compute. Possible values include: "Steady", "Resizing".
    :vartype allocation_state: str or ~azure_machine_learning_workspaces.models.AllocationState
    :ivar allocation_state_transition_time: The time at which the compute entered its current
     allocation state.
    :vartype allocation_state_transition_time: ~datetime.datetime
    :ivar errors: Collection of errors encountered by various compute nodes during node setup.
    :vartype errors: list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar current_node_count: The number of compute nodes currently assigned to the compute.
    :vartype current_node_count: int
    :ivar target_node_count: The target number of compute nodes for the compute. If the
     allocationState is resizing, this property denotes the target node count for the ongoing resize
     operation. If the allocationState is steady, this property denotes the target node count for
     the previous resize operation.
    :vartype target_node_count: int
    :ivar node_state_counts: Counts of various node states on the compute.
    :vartype node_state_counts: ~azure_machine_learning_workspaces.models.NodeStateCounts
    :param enable_node_public_ip: Enable or disable node public IP address provisioning. Possible
     values are: Possible values are: true - Indicates that the compute nodes will have public IPs
     provisioned. false - Indicates that the compute nodes will have a private endpoint and no
     public IPs.
    :type enable_node_public_ip: bool
    """

    _validation = {
        'allocation_state': {'readonly': True},
        'allocation_state_transition_time': {'readonly': True},
        'errors': {'readonly': True},
        'current_node_count': {'readonly': True},
        'target_node_count': {'readonly': True},
        'node_state_counts': {'readonly': True},
    }

    _attribute_map = {
        'os_type': {'key': 'osType', 'type': 'str'},
        'vm_size': {'key': 'vmSize', 'type': 'str'},
        'vm_priority': {'key': 'vmPriority', 'type': 'str'},
        'virtual_machine_image': {'key': 'virtualMachineImage', 'type': 'VirtualMachineImage'},
        'isolated_network': {'key': 'isolatedNetwork', 'type': 'bool'},
        'scale_settings': {'key': 'scaleSettings', 'type': 'ScaleSettingsautogenerated'},
        'user_account_credentials': {'key': 'userAccountCredentials', 'type': 'UserAccountCredentials'},
        'subnet': {'key': 'subnet', 'type': 'ResourceId'},
        'remote_login_port_public_access': {'key': 'remoteLoginPortPublicAccess', 'type': 'str'},
        'allocation_state': {'key': 'allocationState', 'type': 'str'},
        'allocation_state_transition_time': {'key': 'allocationStateTransitionTime', 'type': 'iso-8601'},
        'errors': {'key': 'errors', 'type': '[MachineLearningServiceError]'},
        'current_node_count': {'key': 'currentNodeCount', 'type': 'int'},
        'target_node_count': {'key': 'targetNodeCount', 'type': 'int'},
        'node_state_counts': {'key': 'nodeStateCounts', 'type': 'NodeStateCounts'},
        'enable_node_public_ip': {'key': 'enableNodePublicIp', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        os_type: Optional[Union[str, "OsType"]] = None,
        vm_size: Optional[str] = None,
        vm_priority: Optional[Union[str, "VmPriority"]] = None,
        virtual_machine_image: Optional["VirtualMachineImage"] = None,
        isolated_network: Optional[bool] = None,
        scale_settings: Optional["ScaleSettingsautogenerated"] = None,
        user_account_credentials: Optional["UserAccountCredentials"] = None,
        subnet: Optional["ResourceId"] = None,
        remote_login_port_public_access: Optional[Union[str, "RemoteLoginPortPublicAccess"]] = "NotSpecified",
        enable_node_public_ip: Optional[bool] = True,
        **kwargs
    ):
        super(AmlComputeProperties, self).__init__(**kwargs)
        self.os_type = os_type
        self.vm_size = vm_size
        self.vm_priority = vm_priority
        self.virtual_machine_image = virtual_machine_image
        self.isolated_network = isolated_network
        self.scale_settings = scale_settings
        self.user_account_credentials = user_account_credentials
        self.subnet = subnet
        self.remote_login_port_public_access = remote_login_port_public_access
        self.allocation_state = None
        self.allocation_state_transition_time = None
        self.errors = None
        self.current_node_count = None
        self.target_node_count = None
        self.node_state_counts = None
        self.enable_node_public_ip = enable_node_public_ip


class AmlUserFeature(msrest.serialization.Model):
    """Features enabled for a workspace.

    :param id: Specifies the feature ID.
    :type id: str
    :param display_name: Specifies the feature name.
    :type display_name: str
    :param description: Describes the feature for user experience.
    :type description: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'display_name': {'key': 'displayName', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(AmlUserFeature, self).__init__(**kwargs)
        self.id = id
        self.display_name = display_name
        self.description = description


class ArtifactContentInformationDto(msrest.serialization.Model):
    """ArtifactContentInformationDto.

    :param content_uri:
    :type content_uri: str
    :param origin:
    :type origin: str
    :param container:
    :type container: str
    :param path:
    :type path: str
    """

    _attribute_map = {
        'content_uri': {'key': 'contentUri', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'container': {'key': 'container', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        content_uri: Optional[str] = None,
        origin: Optional[str] = None,
        container: Optional[str] = None,
        path: Optional[str] = None,
        **kwargs
    ):
        super(ArtifactContentInformationDto, self).__init__(**kwargs)
        self.content_uri = content_uri
        self.origin = origin
        self.container = container
        self.path = path


class ArtifactDto(msrest.serialization.Model):
    """ArtifactDto.

    :param artifact_id:
    :type artifact_id: str
    :param origin:
    :type origin: str
    :param container:
    :type container: str
    :param path:
    :type path: str
    :param etag:
    :type etag: str
    :param created_time:
    :type created_time: ~datetime.datetime
    """

    _attribute_map = {
        'artifact_id': {'key': 'artifactId', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'container': {'key': 'container', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
        'created_time': {'key': 'createdTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        artifact_id: Optional[str] = None,
        origin: Optional[str] = None,
        container: Optional[str] = None,
        path: Optional[str] = None,
        etag: Optional[str] = None,
        created_time: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(ArtifactDto, self).__init__(**kwargs)
        self.artifact_id = artifact_id
        self.origin = origin
        self.container = container
        self.path = path
        self.etag = etag
        self.created_time = created_time


class ArtifactPathDto(msrest.serialization.Model):
    """ArtifactPathDto.

    :param path:
    :type path: str
    """

    _attribute_map = {
        'path': {'key': 'path', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        path: Optional[str] = None,
        **kwargs
    ):
        super(ArtifactPathDto, self).__init__(**kwargs)
        self.path = path


class AssetContainer(msrest.serialization.Model):
    """AssetContainer.

    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param description:
    :type description: str
    """

    _attribute_map = {
        'properties': {'key': 'properties', 'type': '{str}'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(AssetContainer, self).__init__(**kwargs)
        self.properties = properties
        self.tags = tags
        self.description = description


class AssetContainerResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required.
    :type properties: ~azure_machine_learning_workspaces.models.AssetContainer
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'AssetContainer'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "AssetContainer",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(AssetContainerResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class AssetContainerResourceArmPaginatedResult(msrest.serialization.Model):
    """AssetContainerResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.AssetContainerResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AssetContainerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["AssetContainerResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(AssetContainerResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class AssetPath(msrest.serialization.Model):
    """Details of an AssetUri.

    All required parameters must be populated in order to send to Azure.

    :param path: Required. The path of file/directory.
    :type path: str
    :param is_directory: Whether the path defines a directory or a single file.
    :type is_directory: bool
    """

    _validation = {
        'path': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'path': {'key': 'path', 'type': 'str'},
        'is_directory': {'key': 'isDirectory', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        path: str,
        is_directory: Optional[bool] = None,
        **kwargs
    ):
        super(AssetPath, self).__init__(**kwargs)
        self.path = path
        self.is_directory = is_directory


class AssetReferenceBase(msrest.serialization.Model):
    """AssetReferenceBase.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BatchDeploymentModelReference, DataPathAssetReference, IdAssetReference, OnlineDeploymentPropertiesModelReference, OutputPathAssetReference.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
    }

    _subtype_map = {
        'reference_type': {'BatchDeployment-modelReference': 'BatchDeploymentModelReference', 'DataPath': 'DataPathAssetReference', 'Id': 'IdAssetReference', 'OnlineDeploymentProperties-modelReference': 'OnlineDeploymentPropertiesModelReference', 'OutputPath': 'OutputPathAssetReference'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AssetReferenceBase, self).__init__(**kwargs)
        self.reference_type = None  # type: Optional[str]


class AuthKeys(msrest.serialization.Model):
    """AuthKeys.

    :param primary_key: The primary key.
    :type primary_key: str
    :param secondary_key: The secondary key.
    :type secondary_key: str
    """

    _attribute_map = {
        'primary_key': {'key': 'primaryKey', 'type': 'str'},
        'secondary_key': {'key': 'secondaryKey', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        primary_key: Optional[str] = None,
        secondary_key: Optional[str] = None,
        **kwargs
    ):
        super(AuthKeys, self).__init__(**kwargs)
        self.primary_key = primary_key
        self.secondary_key = secondary_key


class AuthToken(msrest.serialization.Model):
    """Service Token.

    :param access_token: Access token.
    :type access_token: str
    :param token_type: Access token type.
    :type token_type: str
    :param expiry_time_utc: Access token expiry time (UTC).
    :type expiry_time_utc: long
    :param refresh_after_time_utc: Refresh access token after time (UTC).
    :type refresh_after_time_utc: long
    """

    _attribute_map = {
        'access_token': {'key': 'accessToken', 'type': 'str'},
        'token_type': {'key': 'tokenType', 'type': 'str'},
        'expiry_time_utc': {'key': 'expiryTimeUtc', 'type': 'long'},
        'refresh_after_time_utc': {'key': 'refreshAfterTimeUtc', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        access_token: Optional[str] = None,
        token_type: Optional[str] = None,
        expiry_time_utc: Optional[int] = None,
        refresh_after_time_utc: Optional[int] = None,
        **kwargs
    ):
        super(AuthToken, self).__init__(**kwargs)
        self.access_token = access_token
        self.token_type = token_type
        self.expiry_time_utc = expiry_time_utc
        self.refresh_after_time_utc = refresh_after_time_utc


class JobBase(msrest.serialization.Model):
    """Job base definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ComputeJobBase, JobBaseResourceProperties, LabelingJob, PipelineJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    _subtype_map = {
        'job_type': {'ComputeJobBase': 'ComputeJobBase', 'JobBaseResource-properties': 'JobBaseResourceProperties', 'Labeling': 'LabelingJob', 'Pipeline': 'PipelineJob'}
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(JobBase, self).__init__(**kwargs)
        self.job_type = None  # type: Optional[str]
        self.interaction_endpoints = None
        self.description = description
        self.tags = tags
        self.properties = properties


class ComputeJobBase(JobBase):
    """Compute job base definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CommandJob, DataJob, SweepJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
    }

    _subtype_map = {
        'job_type': {'Command': 'CommandJob', 'Data': 'DataJob', 'Sweep': 'SweepJob'}
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        **kwargs
    ):
        super(ComputeJobBase, self).__init__(description=description, tags=tags, properties=properties, **kwargs)
        self.job_type = 'ComputeJobBase'  # type: str
        self.experiment_name = experiment_name
        self.compute_binding = compute_binding
        self.output = output


class CommandJob(ComputeJobBase):
    """Code Job definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AutomlJob, CommandJobResourceProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required.
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: dict[str, ~azure_machine_learning_workspaces.models.DataBinding]
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration:
     ~azure_machine_learning_workspaces.models.DistributionConfiguration
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': '{DataBinding}'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'DistributionConfiguration'},
    }

    _subtype_map = {
        'job_type': {'AutoML': 'AutomlJob', 'Command': 'CommandJobResourceProperties'}
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        code_configuration: "CodeConfiguration",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        max_run_duration_seconds: Optional[int] = None,
        environment_id: Optional[str] = None,
        data_bindings: Optional[Dict[str, "DataBinding"]] = None,
        distribution_configuration: Optional["DistributionConfiguration"] = None,
        **kwargs
    ):
        super(CommandJob, self).__init__(description=description, tags=tags, properties=properties, experiment_name=experiment_name, compute_binding=compute_binding, output=output, **kwargs)
        self.job_type = 'Command'  # type: str
        self.status = status
        self.max_run_duration_seconds = max_run_duration_seconds
        self.code_configuration = code_configuration
        self.environment_id = environment_id
        self.data_bindings = data_bindings
        self.distribution_configuration = distribution_configuration


class AutomlJob(CommandJob):
    """Automl Job definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required.
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: dict[str, ~azure_machine_learning_workspaces.models.DataBinding]
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration:
     ~azure_machine_learning_workspaces.models.DistributionConfiguration
    :param run_type: Run type.
    :type run_type: str
    :param run_source: Run source would be used by services calling AutoML CreateParentRun,
     if none is provided it would default to "AutoML"
     This value would be used for RootAttribution.
    :type run_source: str
    :param num_iterations: Number of iterations.
    :type num_iterations: int
    :param training_type: Training type. Possible values include: "TrainFull", "TrainAndValidate",
     "CrossValidate", "MeanCrossValidate".
    :type training_type: str or ~azure_machine_learning_workspaces.models.TrainingType
    :param acquisition_function: Aquisition function. Possible values include: "EI", "PI", "UCB".
    :type acquisition_function: str or
     ~azure_machine_learning_workspaces.models.AcquisitionFunction
    :param metrics: Optimization metrics.
    :type metrics: list[str or ~azure_machine_learning_workspaces.models.OptimizationMetric]
    :param primary_metric: Primary optimization metric. Possible values include: "AUC_weighted",
     "Accuracy", "Norm_macro_recall", "Average_precision_score_weighted",
     "Precision_score_weighted", "Spearman_correlation", "Normalized_root_mean_squared_error",
     "R2_score", "Normalized_mean_absolute_error", "Normalized_root_mean_squared_log_error",
     "Mean_average_precision", "Iou".
    :type primary_metric: str or ~azure_machine_learning_workspaces.models.OptimizationMetric
    :param train_split: Train split percentage.
    :type train_split: float
    :param acquisition_parameter: Aquisition parameter.
    :type acquisition_parameter: float
    :param num_cross_validation: Num cross validation.
    :type num_cross_validation: int
    :param target: Target.
    :type target: str
    :param aml_settings_json_string: AMLSettings Json string.
    :type aml_settings_json_string: str
    :param data_prep_json_string: Serialized DataPrep dataflow object.
    :type data_prep_json_string: str
    :param enable_subsampling: Enable subsampling.
    :type enable_subsampling: bool
    :param scenario: Which scenario is being used to mapping to a curated environment.
    :type scenario: str
    :param parent_run_id: The parent run id for the current parent run dto.
    :type parent_run_id: str
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': '{DataBinding}'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'DistributionConfiguration'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'run_source': {'key': 'runSource', 'type': 'str'},
        'num_iterations': {'key': 'numIterations', 'type': 'int'},
        'training_type': {'key': 'trainingType', 'type': 'str'},
        'acquisition_function': {'key': 'acquisitionFunction', 'type': 'str'},
        'metrics': {'key': 'metrics', 'type': '[str]'},
        'primary_metric': {'key': 'primaryMetric', 'type': 'str'},
        'train_split': {'key': 'trainSplit', 'type': 'float'},
        'acquisition_parameter': {'key': 'acquisitionParameter', 'type': 'float'},
        'num_cross_validation': {'key': 'numCrossValidation', 'type': 'int'},
        'target': {'key': 'target', 'type': 'str'},
        'aml_settings_json_string': {'key': 'amlSettingsJsonString', 'type': 'str'},
        'data_prep_json_string': {'key': 'dataPrepJsonString', 'type': 'str'},
        'enable_subsampling': {'key': 'enableSubsampling', 'type': 'bool'},
        'scenario': {'key': 'scenario', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        code_configuration: "CodeConfiguration",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        max_run_duration_seconds: Optional[int] = None,
        environment_id: Optional[str] = None,
        data_bindings: Optional[Dict[str, "DataBinding"]] = None,
        distribution_configuration: Optional["DistributionConfiguration"] = None,
        run_type: Optional[str] = None,
        run_source: Optional[str] = None,
        num_iterations: Optional[int] = None,
        training_type: Optional[Union[str, "TrainingType"]] = None,
        acquisition_function: Optional[Union[str, "AcquisitionFunction"]] = None,
        metrics: Optional[List[Union[str, "OptimizationMetric"]]] = None,
        primary_metric: Optional[Union[str, "OptimizationMetric"]] = None,
        train_split: Optional[float] = None,
        acquisition_parameter: Optional[float] = None,
        num_cross_validation: Optional[int] = None,
        target: Optional[str] = None,
        aml_settings_json_string: Optional[str] = None,
        data_prep_json_string: Optional[str] = None,
        enable_subsampling: Optional[bool] = None,
        scenario: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        **kwargs
    ):
        super(AutomlJob, self).__init__(description=description, tags=tags, properties=properties, experiment_name=experiment_name, compute_binding=compute_binding, output=output, status=status, max_run_duration_seconds=max_run_duration_seconds, code_configuration=code_configuration, environment_id=environment_id, data_bindings=data_bindings, distribution_configuration=distribution_configuration, **kwargs)
        self.job_type = 'AutoML'  # type: str
        self.run_type = run_type
        self.run_source = run_source
        self.num_iterations = num_iterations
        self.training_type = training_type
        self.acquisition_function = acquisition_function
        self.metrics = metrics
        self.primary_metric = primary_metric
        self.train_split = train_split
        self.acquisition_parameter = acquisition_parameter
        self.num_cross_validation = num_cross_validation
        self.target = target
        self.aml_settings_json_string = aml_settings_json_string
        self.data_prep_json_string = data_prep_json_string
        self.enable_subsampling = enable_subsampling
        self.scenario = scenario
        self.parent_run_id = parent_run_id


class AzureDataLakeSection(msrest.serialization.Model):
    """AzureDataLakeSection.

    All required parameters must be populated in order to send to Azure.

    :param credentials: Required.
    :type credentials: ~azure_machine_learning_workspaces.models.DatastoreCredentials
    :param store_name: Required. Azure Data Lake store name.
    :type store_name: str
    """

    _validation = {
        'credentials': {'required': True},
        'store_name': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'credentials': {'key': 'credentials', 'type': 'DatastoreCredentials'},
        'store_name': {'key': 'storeName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        credentials: "DatastoreCredentials",
        store_name: str,
        **kwargs
    ):
        super(AzureDataLakeSection, self).__init__(**kwargs)
        self.credentials = credentials
        self.store_name = store_name


class AzureMySQLSection(msrest.serialization.Model):
    """AzureMySQLSection.

    All required parameters must be populated in order to send to Azure.

    :param credentials: Required.
    :type credentials: ~azure_machine_learning_workspaces.models.DatastoreCredentials
    :param database_name: Required. Azure SQL database name.
    :type database_name: str
    :param endpoint: Required. Azure cloud endpoint for the database.
    :type endpoint: str
    :param port_number: Required. Azure SQL server port.
    :type port_number: int
    :param server_name: Required. Azure SQL server name.
    :type server_name: str
    """

    _validation = {
        'credentials': {'required': True},
        'database_name': {'required': True, 'pattern': r'\w'},
        'endpoint': {'required': True, 'pattern': r'\w'},
        'port_number': {'required': True},
        'server_name': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'credentials': {'key': 'credentials', 'type': 'DatastoreCredentials'},
        'database_name': {'key': 'databaseName', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'port_number': {'key': 'portNumber', 'type': 'int'},
        'server_name': {'key': 'serverName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        credentials: "DatastoreCredentials",
        database_name: str,
        endpoint: str,
        port_number: int,
        server_name: str,
        **kwargs
    ):
        super(AzureMySQLSection, self).__init__(**kwargs)
        self.credentials = credentials
        self.database_name = database_name
        self.endpoint = endpoint
        self.port_number = port_number
        self.server_name = server_name


class AzurePostgreSQLSection(msrest.serialization.Model):
    """AzurePostgreSQLSection.

    All required parameters must be populated in order to send to Azure.

    :param enable_ssl: Whether the Azure PostgreSQL server requires SSL.
    :type enable_ssl: bool
    :param credentials: Required.
    :type credentials: ~azure_machine_learning_workspaces.models.DatastoreCredentials
    :param database_name: Required. Azure SQL database name.
    :type database_name: str
    :param endpoint: Required. Azure cloud endpoint for the database.
    :type endpoint: str
    :param port_number: Required. Azure SQL server port.
    :type port_number: int
    :param server_name: Required. Azure SQL server name.
    :type server_name: str
    """

    _validation = {
        'credentials': {'required': True},
        'database_name': {'required': True, 'pattern': r'\w'},
        'endpoint': {'required': True, 'pattern': r'\w'},
        'port_number': {'required': True},
        'server_name': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'enable_ssl': {'key': 'enableSSL', 'type': 'bool'},
        'credentials': {'key': 'credentials', 'type': 'DatastoreCredentials'},
        'database_name': {'key': 'databaseName', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'port_number': {'key': 'portNumber', 'type': 'int'},
        'server_name': {'key': 'serverName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        credentials: "DatastoreCredentials",
        database_name: str,
        endpoint: str,
        port_number: int,
        server_name: str,
        enable_ssl: Optional[bool] = None,
        **kwargs
    ):
        super(AzurePostgreSQLSection, self).__init__(**kwargs)
        self.enable_ssl = enable_ssl
        self.credentials = credentials
        self.database_name = database_name
        self.endpoint = endpoint
        self.port_number = port_number
        self.server_name = server_name


class AzureSQLDatabaseSection(msrest.serialization.Model):
    """AzureSQLDatabaseSection.

    All required parameters must be populated in order to send to Azure.

    :param credentials: Required.
    :type credentials: ~azure_machine_learning_workspaces.models.DatastoreCredentials
    :param database_name: Required. Azure SQL database name.
    :type database_name: str
    :param endpoint: Required. Azure cloud endpoint for the database.
    :type endpoint: str
    :param port_number: Required. Azure SQL server port.
    :type port_number: int
    :param server_name: Required. Azure SQL server name.
    :type server_name: str
    """

    _validation = {
        'credentials': {'required': True},
        'database_name': {'required': True, 'pattern': r'\w'},
        'endpoint': {'required': True, 'pattern': r'\w'},
        'port_number': {'required': True},
        'server_name': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'credentials': {'key': 'credentials', 'type': 'DatastoreCredentials'},
        'database_name': {'key': 'databaseName', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'port_number': {'key': 'portNumber', 'type': 'int'},
        'server_name': {'key': 'serverName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        credentials: "DatastoreCredentials",
        database_name: str,
        endpoint: str,
        port_number: int,
        server_name: str,
        **kwargs
    ):
        super(AzureSQLDatabaseSection, self).__init__(**kwargs)
        self.credentials = credentials
        self.database_name = database_name
        self.endpoint = endpoint
        self.port_number = port_number
        self.server_name = server_name


class AzureStorageSection(msrest.serialization.Model):
    """AzureStorageSection.

    All required parameters must be populated in order to send to Azure.

    :param account_name: Required. Storage account name.
    :type account_name: str
    :param blob_cache_timeout: Blob storage cache timeout.
    :type blob_cache_timeout: int
    :param container_name: Required. Storage account container name.
    :type container_name: str
    :param credentials: Required.
    :type credentials: ~azure_machine_learning_workspaces.models.DatastoreCredentials
    :param endpoint: Required. Azure cloud endpoint for the storage account.
    :type endpoint: str
    :param protocol: Required. Protocol used to communicate with the storage account.
    :type protocol: str
    """

    _validation = {
        'account_name': {'required': True, 'pattern': r'\w'},
        'container_name': {'required': True, 'pattern': r'\w'},
        'credentials': {'required': True},
        'endpoint': {'required': True, 'pattern': r'\w'},
        'protocol': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'account_name': {'key': 'accountName', 'type': 'str'},
        'blob_cache_timeout': {'key': 'blobCacheTimeout', 'type': 'int'},
        'container_name': {'key': 'containerName', 'type': 'str'},
        'credentials': {'key': 'credentials', 'type': 'DatastoreCredentials'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'protocol': {'key': 'protocol', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        account_name: str,
        container_name: str,
        credentials: "DatastoreCredentials",
        endpoint: str,
        protocol: str,
        blob_cache_timeout: Optional[int] = None,
        **kwargs
    ):
        super(AzureStorageSection, self).__init__(**kwargs)
        self.account_name = account_name
        self.blob_cache_timeout = blob_cache_timeout
        self.container_name = container_name
        self.credentials = credentials
        self.endpoint = endpoint
        self.protocol = protocol


class EarlyTerminationPolicyConfiguration(msrest.serialization.Model):
    """Early termination policies enable canceling poor-performing runs before they complete.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BanditPolicyConfiguration, MedianStoppingPolicyConfiguration, TerminationConfigurationEarlyTerminationPolicyConfiguration, TruncationSelectionPolicyConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param policy_type: Required. Name of policy configuration.Constant filled by server.  Possible
     values include: "Bandit", "MedianStopping", "TruncationSelection".
    :type policy_type: str or ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyType
    :param evaluation_interval:
    :type evaluation_interval: int
    :param delay_evaluation:
    :type delay_evaluation: int
    """

    _validation = {
        'policy_type': {'required': True},
    }

    _attribute_map = {
        'policy_type': {'key': 'policyType', 'type': 'str'},
        'evaluation_interval': {'key': 'evaluationInterval', 'type': 'int'},
        'delay_evaluation': {'key': 'delayEvaluation', 'type': 'int'},
    }

    _subtype_map = {
        'policy_type': {'Bandit': 'BanditPolicyConfiguration', 'MedianStopping': 'MedianStoppingPolicyConfiguration', 'TerminationConfiguration-earlyTerminationPolicyConfiguration': 'TerminationConfigurationEarlyTerminationPolicyConfiguration', 'TruncationSelection': 'TruncationSelectionPolicyConfiguration'}
    }

    def __init__(
        self,
        *,
        evaluation_interval: Optional[int] = None,
        delay_evaluation: Optional[int] = None,
        **kwargs
    ):
        super(EarlyTerminationPolicyConfiguration, self).__init__(**kwargs)
        self.policy_type = None  # type: Optional[str]
        self.evaluation_interval = evaluation_interval
        self.delay_evaluation = delay_evaluation


class BanditPolicyConfiguration(EarlyTerminationPolicyConfiguration):
    """Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation.

    All required parameters must be populated in order to send to Azure.

    :param policy_type: Required. Name of policy configuration.Constant filled by server.  Possible
     values include: "Bandit", "MedianStopping", "TruncationSelection".
    :type policy_type: str or ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyType
    :param evaluation_interval:
    :type evaluation_interval: int
    :param delay_evaluation:
    :type delay_evaluation: int
    :param slack_factor:
    :type slack_factor: float
    :param slack_amount:
    :type slack_amount: float
    """

    _validation = {
        'policy_type': {'required': True},
    }

    _attribute_map = {
        'policy_type': {'key': 'policyType', 'type': 'str'},
        'evaluation_interval': {'key': 'evaluationInterval', 'type': 'int'},
        'delay_evaluation': {'key': 'delayEvaluation', 'type': 'int'},
        'slack_factor': {'key': 'slackFactor', 'type': 'float'},
        'slack_amount': {'key': 'slackAmount', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        evaluation_interval: Optional[int] = None,
        delay_evaluation: Optional[int] = None,
        slack_factor: Optional[float] = None,
        slack_amount: Optional[float] = None,
        **kwargs
    ):
        super(BanditPolicyConfiguration, self).__init__(evaluation_interval=evaluation_interval, delay_evaluation=delay_evaluation, **kwargs)
        self.policy_type = 'Bandit'  # type: str
        self.slack_factor = slack_factor
        self.slack_amount = slack_amount


class BaseEvent(msrest.serialization.Model):
    """BaseEvent.

    :param timestamp:
    :type timestamp: ~datetime.datetime
    :param name:
    :type name: str
    :param project_id:
    :type project_id: str
    :param experiment_id:
    :type experiment_id: str
    :param container_name:
    :type container_name: str
    :param data: Any object.
    :type data: object
    """

    _attribute_map = {
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'project_id': {'key': 'projectId', 'type': 'str'},
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'container_name': {'key': 'containerName', 'type': 'str'},
        'data': {'key': 'data', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        timestamp: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        project_id: Optional[str] = None,
        experiment_id: Optional[str] = None,
        container_name: Optional[str] = None,
        data: Optional[object] = None,
        **kwargs
    ):
        super(BaseEvent, self).__init__(**kwargs)
        self.timestamp = timestamp
        self.name = name
        self.project_id = project_id
        self.experiment_id = experiment_id
        self.container_name = container_name
        self.data = data


class BaseEventDto(msrest.serialization.Model):
    """BaseEventDto.

    :param timestamp:
    :type timestamp: ~datetime.datetime
    :param name:
    :type name: str
    :param data: Any object.
    :type data: object
    """

    _attribute_map = {
        'timestamp': {'key': 'timestamp', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        timestamp: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        data: Optional[object] = None,
        **kwargs
    ):
        super(BaseEventDto, self).__init__(**kwargs)
        self.timestamp = timestamp
        self.name = name
        self.data = data


class BatchAddOrModifyRunRequestDto(msrest.serialization.Model):
    """BatchAddOrModifyRunRequestDto.

    :param runs:
    :type runs: list[~azure_machine_learning_workspaces.models.CreateRunDto]
    """

    _attribute_map = {
        'runs': {'key': 'runs', 'type': '[CreateRunDto]'},
    }

    def __init__(
        self,
        *,
        runs: Optional[List["CreateRunDto"]] = None,
        **kwargs
    ):
        super(BatchAddOrModifyRunRequestDto, self).__init__(**kwargs)
        self.runs = runs


class BatchAddOrModifyRunResultDto(msrest.serialization.Model):
    """BatchAddOrModifyRunResultDto.

    :param runs: Dictionary of :code:`<RunDto>`.
    :type runs: dict[str, ~azure_machine_learning_workspaces.models.RunDto]
    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated]
    """

    _attribute_map = {
        'runs': {'key': 'runs', 'type': '{RunDto}'},
        'errors': {'key': 'errors', 'type': '{ErrorResponseautogenerated}'},
    }

    def __init__(
        self,
        *,
        runs: Optional[Dict[str, "RunDto"]] = None,
        errors: Optional[Dict[str, "ErrorResponseautogenerated"]] = None,
        **kwargs
    ):
        super(BatchAddOrModifyRunResultDto, self).__init__(**kwargs)
        self.runs = runs
        self.errors = errors


class BatchArtifactContentInformationDto(msrest.serialization.Model):
    """BatchArtifactContentInformationDto.

    :param artifacts: Dictionary of :code:`<ArtifactDto>`.
    :type artifacts: dict[str, ~azure_machine_learning_workspaces.models.ArtifactDto]
    :param artifact_content_information: Dictionary of :code:`<ArtifactContentInformationDto>`.
    :type artifact_content_information: dict[str,
     ~azure_machine_learning_workspaces.models.ArtifactContentInformationDto]
    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated]
    """

    _attribute_map = {
        'artifacts': {'key': 'artifacts', 'type': '{ArtifactDto}'},
        'artifact_content_information': {'key': 'artifactContentInformation', 'type': '{ArtifactContentInformationDto}'},
        'errors': {'key': 'errors', 'type': '{ErrorResponseautogenerated}'},
    }

    def __init__(
        self,
        *,
        artifacts: Optional[Dict[str, "ArtifactDto"]] = None,
        artifact_content_information: Optional[Dict[str, "ArtifactContentInformationDto"]] = None,
        errors: Optional[Dict[str, "ErrorResponseautogenerated"]] = None,
        **kwargs
    ):
        super(BatchArtifactContentInformationDto, self).__init__(**kwargs)
        self.artifacts = artifacts
        self.artifact_content_information = artifact_content_information
        self.errors = errors


class BatchArtifactCreateCommand(msrest.serialization.Model):
    """BatchArtifactCreateCommand.

    :param paths:
    :type paths: list[~azure_machine_learning_workspaces.models.ArtifactPathDto]
    """

    _attribute_map = {
        'paths': {'key': 'paths', 'type': '[ArtifactPathDto]'},
    }

    def __init__(
        self,
        *,
        paths: Optional[List["ArtifactPathDto"]] = None,
        **kwargs
    ):
        super(BatchArtifactCreateCommand, self).__init__(**kwargs)
        self.paths = paths


class BatchDeployment(msrest.serialization.Model):
    """Batch inference settings per deployment.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param scale_settings:
    :type scale_settings: ~azure_machine_learning_workspaces.models.DeploymentScaleSettings
    :param batch_settings: Batch inference specific settings per deployment.
    :type batch_settings: ~azure_machine_learning_workspaces.models.BatchDeploymentSettings
    :param description: Description of the endpoint deployment.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param model_reference: Model Configuration.
    :type model_reference: ~azure_machine_learning_workspaces.models.AssetReferenceBase
    :param code_configuration:
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification for the endpoint deployment.
    :type environment_id: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Possible values
     include: "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.DeploymentProvisioningState
    """

    _validation = {
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'scale_settings': {'key': 'scaleSettings', 'type': 'DeploymentScaleSettings'},
        'batch_settings': {'key': 'batchSettings', 'type': 'BatchDeploymentSettings'},
        'description': {'key': 'description', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'model_reference': {'key': 'modelReference', 'type': 'AssetReferenceBase'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        scale_settings: Optional["DeploymentScaleSettings"] = None,
        batch_settings: Optional["BatchDeploymentSettings"] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        model_reference: Optional["AssetReferenceBase"] = None,
        code_configuration: Optional["CodeConfiguration"] = None,
        environment_id: Optional[str] = None,
        **kwargs
    ):
        super(BatchDeployment, self).__init__(**kwargs)
        self.scale_settings = scale_settings
        self.batch_settings = batch_settings
        self.description = description
        self.properties = properties
        self.model_reference = model_reference
        self.code_configuration = code_configuration
        self.environment_id = environment_id
        self.provisioning_state = None


class BatchDeploymentModelReference(AssetReferenceBase):
    """Model Configuration.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BatchDeploymentModelReference, self).__init__(**kwargs)
        self.reference_type = 'BatchDeployment-modelReference'  # type: str


class BatchDeploymentResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param scale_settings:
    :type scale_settings: ~azure_machine_learning_workspaces.models.DeploymentScaleSettings
    :param batch_settings: Batch inference specific settings per deployment.
    :type batch_settings: ~azure_machine_learning_workspaces.models.BatchDeploymentSettings
    :param description: Description of the endpoint deployment.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param model_reference: Model Configuration.
    :type model_reference: ~azure_machine_learning_workspaces.models.AssetReferenceBase
    :param code_configuration:
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification for the endpoint deployment.
    :type environment_id: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Possible values
     include: "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.DeploymentProvisioningState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'scale_settings': {'key': 'properties.scaleSettings', 'type': 'DeploymentScaleSettings'},
        'batch_settings': {'key': 'properties.batchSettings', 'type': 'BatchDeploymentSettings'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'model_reference': {'key': 'properties.modelReference', 'type': 'AssetReferenceBase'},
        'code_configuration': {'key': 'properties.codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'properties.environmentId', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        scale_settings: Optional["DeploymentScaleSettings"] = None,
        batch_settings: Optional["BatchDeploymentSettings"] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        model_reference: Optional["AssetReferenceBase"] = None,
        code_configuration: Optional["CodeConfiguration"] = None,
        environment_id: Optional[str] = None,
        **kwargs
    ):
        super(BatchDeploymentResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.scale_settings = scale_settings
        self.batch_settings = batch_settings
        self.description = description
        self.properties = properties
        self.model_reference = model_reference
        self.code_configuration = code_configuration
        self.environment_id = environment_id
        self.provisioning_state = None


class BatchDeploymentSettings(msrest.serialization.Model):
    """Batch inference specific settings per deployment.

    :param compute_id: Compute artifact Identifier.
    :type compute_id: str
    :param error_threshold: Error threshold, if the error count for the entire input goes above
     this value,
     the batch inference will be aborted. Range is [-1, int.MaxValue]
     -1 value indicates, ignore all failures during batch inference
     For FileDataset count of file failures
     For TabularDataset, this is the count of record failures.
    :type error_threshold: int
    :param retry_settings: Retry settings for a batch inference operation.
    :type retry_settings: ~azure_machine_learning_workspaces.models.BatchRetrySettings
    :param partitioning_scheme: Partitioning scheme for batch inference operation.
    :type partitioning_scheme: ~azure_machine_learning_workspaces.models.BatchPartitioningScheme
    :param logging_level: Logging level for batch inference operation. Possible values include:
     "Info", "Warning", "Debug".
    :type logging_level: str or ~azure_machine_learning_workspaces.models.BatchLoggingLevel
    :param output_configuration: Batch inference output configuration.
    :type output_configuration: ~azure_machine_learning_workspaces.models.BatchOutputConfiguration
    """

    _attribute_map = {
        'compute_id': {'key': 'computeId', 'type': 'str'},
        'error_threshold': {'key': 'errorThreshold', 'type': 'int'},
        'retry_settings': {'key': 'retrySettings', 'type': 'BatchRetrySettings'},
        'partitioning_scheme': {'key': 'partitioningScheme', 'type': 'BatchPartitioningScheme'},
        'logging_level': {'key': 'loggingLevel', 'type': 'str'},
        'output_configuration': {'key': 'outputConfiguration', 'type': 'BatchOutputConfiguration'},
    }

    def __init__(
        self,
        *,
        compute_id: Optional[str] = None,
        error_threshold: Optional[int] = None,
        retry_settings: Optional["BatchRetrySettings"] = None,
        partitioning_scheme: Optional["BatchPartitioningScheme"] = None,
        logging_level: Optional[Union[str, "BatchLoggingLevel"]] = None,
        output_configuration: Optional["BatchOutputConfiguration"] = None,
        **kwargs
    ):
        super(BatchDeploymentSettings, self).__init__(**kwargs)
        self.compute_id = compute_id
        self.error_threshold = error_threshold
        self.retry_settings = retry_settings
        self.partitioning_scheme = partitioning_scheme
        self.logging_level = logging_level
        self.output_configuration = output_configuration


class BatchDeploymentTrackedResource(msrest.serialization.Model):
    """BatchDeploymentTrackedResource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param location:
    :type location: str
    :param kind:
    :type kind: str
    :param identity:
    :type identity: ~azure_machine_learning_workspaces.models.ResourceIdentityInArm
    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Batch inference settings per deployment.
    :type properties: ~azure_machine_learning_workspaces.models.BatchDeployment
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentityInArm'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'BatchDeployment'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "BatchDeployment",
        tags: Optional[Dict[str, str]] = None,
        location: Optional[str] = None,
        kind: Optional[str] = None,
        identity: Optional["ResourceIdentityInArm"] = None,
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(BatchDeploymentTrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location
        self.kind = kind
        self.identity = identity
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class BatchDeploymentTrackedResourceArmPaginatedResult(msrest.serialization.Model):
    """BatchDeploymentTrackedResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.BatchDeploymentTrackedResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[BatchDeploymentTrackedResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["BatchDeploymentTrackedResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(BatchDeploymentTrackedResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class BatchEndpoint(msrest.serialization.Model):
    """Batch endpoint configuration.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param description: Description of the inference endpoint.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param traffic_rules: Traffic rules on how the traffic will be routed across deployments.
    :type traffic_rules: dict[str, int]
    :param compute_configuration: Reference to compute configuration.
    :type compute_configuration: ~azure_machine_learning_workspaces.models.ComputeConfiguration
    :ivar provisioning_state: State of provisioning. Possible values include: "Creating",
     "Deleting", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.EndpointProvisioningState
    :ivar endpoint: Endpoint URI.
    :vartype endpoint: str
    :ivar swagger_endpoint: Endpoint Swagger URI.
    :vartype swagger_endpoint: str
    :param auth_mode: Inference endpoint authentication mode type. Possible values include:
     "AMLToken", "Key".
    :type auth_mode: str or ~azure_machine_learning_workspaces.models.EndpointAuthModeType
    :param keys:
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    """

    _validation = {
        'provisioning_state': {'readonly': True},
        'endpoint': {'readonly': True},
        'swagger_endpoint': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'traffic_rules': {'key': 'trafficRules', 'type': '{int}'},
        'compute_configuration': {'key': 'computeConfiguration', 'type': 'ComputeConfiguration'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'swagger_endpoint': {'key': 'swaggerEndpoint', 'type': 'str'},
        'auth_mode': {'key': 'authMode', 'type': 'str'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        traffic_rules: Optional[Dict[str, int]] = None,
        compute_configuration: Optional["ComputeConfiguration"] = None,
        auth_mode: Optional[Union[str, "EndpointAuthModeType"]] = None,
        keys: Optional["AuthKeys"] = None,
        **kwargs
    ):
        super(BatchEndpoint, self).__init__(**kwargs)
        self.description = description
        self.properties = properties
        self.traffic_rules = traffic_rules
        self.compute_configuration = compute_configuration
        self.provisioning_state = None
        self.endpoint = None
        self.swagger_endpoint = None
        self.auth_mode = auth_mode
        self.keys = keys


class BatchEndpointComputeConfiguration(ComputeConfiguration):
    """Reference to compute configuration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BatchEndpointComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = 'BatchEndpoint-computeConfiguration'  # type: str


class BatchEndpointResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param description: Description of the inference endpoint.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param traffic_rules: Traffic rules on how the traffic will be routed across deployments.
    :type traffic_rules: dict[str, int]
    :param compute_configuration: Reference to compute configuration.
    :type compute_configuration: ~azure_machine_learning_workspaces.models.ComputeConfiguration
    :ivar provisioning_state: State of provisioning. Possible values include: "Creating",
     "Deleting", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.EndpointProvisioningState
    :ivar endpoint: Endpoint URI.
    :vartype endpoint: str
    :ivar swagger_endpoint: Endpoint Swagger URI.
    :vartype swagger_endpoint: str
    :param auth_mode: Inference endpoint authentication mode type. Possible values include:
     "AMLToken", "Key".
    :type auth_mode: str or ~azure_machine_learning_workspaces.models.EndpointAuthModeType
    :param keys:
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'endpoint': {'readonly': True},
        'swagger_endpoint': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'traffic_rules': {'key': 'properties.trafficRules', 'type': '{int}'},
        'compute_configuration': {'key': 'properties.computeConfiguration', 'type': 'ComputeConfiguration'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'endpoint': {'key': 'properties.endpoint', 'type': 'str'},
        'swagger_endpoint': {'key': 'properties.swaggerEndpoint', 'type': 'str'},
        'auth_mode': {'key': 'properties.authMode', 'type': 'str'},
        'keys': {'key': 'properties.keys', 'type': 'AuthKeys'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        traffic_rules: Optional[Dict[str, int]] = None,
        compute_configuration: Optional["ComputeConfiguration"] = None,
        auth_mode: Optional[Union[str, "EndpointAuthModeType"]] = None,
        keys: Optional["AuthKeys"] = None,
        **kwargs
    ):
        super(BatchEndpointResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.description = description
        self.properties = properties
        self.traffic_rules = traffic_rules
        self.compute_configuration = compute_configuration
        self.provisioning_state = None
        self.endpoint = None
        self.swagger_endpoint = None
        self.auth_mode = auth_mode
        self.keys = keys


class BatchEndpointTrackedResource(msrest.serialization.Model):
    """BatchEndpointTrackedResource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param location:
    :type location: str
    :param kind:
    :type kind: str
    :param identity:
    :type identity: ~azure_machine_learning_workspaces.models.ResourceIdentityInArm
    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Batch endpoint configuration.
    :type properties: ~azure_machine_learning_workspaces.models.BatchEndpoint
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentityInArm'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'BatchEndpoint'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "BatchEndpoint",
        tags: Optional[Dict[str, str]] = None,
        location: Optional[str] = None,
        kind: Optional[str] = None,
        identity: Optional["ResourceIdentityInArm"] = None,
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(BatchEndpointTrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location
        self.kind = kind
        self.identity = identity
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class BatchEndpointTrackedResourceArmPaginatedResult(msrest.serialization.Model):
    """BatchEndpointTrackedResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.BatchEndpointTrackedResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[BatchEndpointTrackedResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["BatchEndpointTrackedResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(BatchEndpointTrackedResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class BatchEventCommandDto(msrest.serialization.Model):
    """BatchEventCommandDto.

    :param events:
    :type events: list[~azure_machine_learning_workspaces.models.BaseEventDto]
    """

    _attribute_map = {
        'events': {'key': 'events', 'type': '[BaseEventDto]'},
    }

    def __init__(
        self,
        *,
        events: Optional[List["BaseEventDto"]] = None,
        **kwargs
    ):
        super(BatchEventCommandDto, self).__init__(**kwargs)
        self.events = events


class BatchEventCommandResultDto(msrest.serialization.Model):
    """BatchEventCommandResultDto.

    :param errors:
    :type errors: list[~azure_machine_learning_workspaces.models.BatchEventCommandResultKvp]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '[BatchEventCommandResultKvp]'},
    }

    def __init__(
        self,
        *,
        errors: Optional[List["BatchEventCommandResultKvp"]] = None,
        **kwargs
    ):
        super(BatchEventCommandResultDto, self).__init__(**kwargs)
        self.errors = errors


class BatchEventCommandResultKvp(msrest.serialization.Model):
    """BatchEventCommandResultKvp.

    :param key:
    :type key: ~azure_machine_learning_workspaces.models.BaseEventDto
    :param value: The error response.
    :type value: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'BaseEventDto'},
        'value': {'key': 'value', 'type': 'ErrorResponseautogenerated'},
    }

    def __init__(
        self,
        *,
        key: Optional["BaseEventDto"] = None,
        value: Optional["ErrorResponseautogenerated"] = None,
        **kwargs
    ):
        super(BatchEventCommandResultKvp, self).__init__(**kwargs)
        self.key = key
        self.value = value


class BatchMetricDto(msrest.serialization.Model):
    """BatchMetricDto.

    :param values:
    :type values: list[~azure_machine_learning_workspaces.models.MetricDto]
    """

    _attribute_map = {
        'values': {'key': 'values', 'type': '[MetricDto]'},
    }

    def __init__(
        self,
        *,
        values: Optional[List["MetricDto"]] = None,
        **kwargs
    ):
        super(BatchMetricDto, self).__init__(**kwargs)
        self.values = values


class BatchOutputConfiguration(msrest.serialization.Model):
    """Batch inference output configuration.

    :param output_action: Indicates how the output will be organized. Possible values include:
     "SummaryOnly", "AppendRow".
    :type output_action: str or ~azure_machine_learning_workspaces.models.BatchOutputAction
    :param append_row_file_name: Customized output file name for append_row output action.
    :type append_row_file_name: str
    """

    _attribute_map = {
        'output_action': {'key': 'outputAction', 'type': 'str'},
        'append_row_file_name': {'key': 'appendRowFileName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        output_action: Optional[Union[str, "BatchOutputAction"]] = None,
        append_row_file_name: Optional[str] = None,
        **kwargs
    ):
        super(BatchOutputConfiguration, self).__init__(**kwargs)
        self.output_action = output_action
        self.append_row_file_name = append_row_file_name


class BatchPartitioningScheme(msrest.serialization.Model):
    """Partitioning scheme for batch inference operation.

    :param partitioning_keys: Partition keys list used for Named partitioning.
    :type partitioning_keys: list[str]
    :param mini_batch_size: Size of the mini-batch passed to each batch invocation.
     For FileDataset, this is the number of files per mini-batch.
     For TabularDataset, this is the size of the records in bytes, per mini-batch.
    :type mini_batch_size: long
    """

    _attribute_map = {
        'partitioning_keys': {'key': 'partitioningKeys', 'type': '[str]'},
        'mini_batch_size': {'key': 'miniBatchSize', 'type': 'long'},
    }

    def __init__(
        self,
        *,
        partitioning_keys: Optional[List[str]] = None,
        mini_batch_size: Optional[int] = None,
        **kwargs
    ):
        super(BatchPartitioningScheme, self).__init__(**kwargs)
        self.partitioning_keys = partitioning_keys
        self.mini_batch_size = mini_batch_size


class BatchRetrySettings(msrest.serialization.Model):
    """Retry settings for a batch inference operation.

    :param maximum_retries: Maximum retry count for a mini-batch.
    :type maximum_retries: int
    :param timeout_in_seconds: Invocation timeout for a mini-batch, in seconds.
    :type timeout_in_seconds: int
    """

    _attribute_map = {
        'maximum_retries': {'key': 'maximumRetries', 'type': 'int'},
        'timeout_in_seconds': {'key': 'timeoutInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        maximum_retries: Optional[int] = None,
        timeout_in_seconds: Optional[int] = None,
        **kwargs
    ):
        super(BatchRetrySettings, self).__init__(**kwargs)
        self.maximum_retries = maximum_retries
        self.timeout_in_seconds = timeout_in_seconds


class CertificateSection(msrest.serialization.Model):
    """CertificateSection.

    All required parameters must be populated in order to send to Azure.

    :param authority_url: Authority URL used for authentication.
    :type authority_url: str
    :param resource_uri: Resource the service principal has access to.
    :type resource_uri: str
    :param tenant_id: Required. ID of the tenant to which the service principal belongs.
    :type tenant_id: str
    :param client_id: Required. Service principal client ID.
    :type client_id: str
    :param certificate: Service principal certificate.
    :type certificate: str
    :param thumbprint: Required. Thumbprint of the certificate used for authentication.
    :type thumbprint: str
    """

    _validation = {
        'tenant_id': {'required': True},
        'client_id': {'required': True},
        'thumbprint': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'authority_url': {'key': 'authorityUrl', 'type': 'str'},
        'resource_uri': {'key': 'resourceUri', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'certificate': {'key': 'certificate', 'type': 'str'},
        'thumbprint': {'key': 'thumbprint', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tenant_id: str,
        client_id: str,
        thumbprint: str,
        authority_url: Optional[str] = None,
        resource_uri: Optional[str] = None,
        certificate: Optional[str] = None,
        **kwargs
    ):
        super(CertificateSection, self).__init__(**kwargs)
        self.authority_url = authority_url
        self.resource_uri = resource_uri
        self.tenant_id = tenant_id
        self.client_id = client_id
        self.certificate = certificate
        self.thumbprint = thumbprint


class ClusterUpdateParameters(msrest.serialization.Model):
    """AmlCompute update parameters.

    :param scale_settings: Desired scale settings for the amlCompute.
    :type scale_settings: ~azure_machine_learning_workspaces.models.ScaleSettingsautogenerated
    """

    _attribute_map = {
        'scale_settings': {'key': 'properties.scaleSettings', 'type': 'ScaleSettingsautogenerated'},
    }

    def __init__(
        self,
        *,
        scale_settings: Optional["ScaleSettingsautogenerated"] = None,
        **kwargs
    ):
        super(ClusterUpdateParameters, self).__init__(**kwargs)
        self.scale_settings = scale_settings


class ExportSummary(msrest.serialization.Model):
    """ExportSummary.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CsvExportSummary, CocoExportSummary, DatasetExportSummary, ExportSummaryResourceProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: Required. The format of exported labels, also as the discriminator.Constant
     filled by server.  Possible values include: "Dataset", "Coco", "CSV".
    :type format: str or ~azure_machine_learning_workspaces.models.ExportFormatType
    :ivar export_id: The unique identifier of completed Export Labels operation.
    :vartype export_id: str
    :ivar labeling_job_id: Name and identifier of the job containing exported labels.
    :vartype labeling_job_id: str
    :ivar exported_row_count: The total number of labeled datapoints exported.
    :vartype exported_row_count: long
    :ivar start_time_utc: The time when the export was requested.
    :vartype start_time_utc: ~datetime.datetime
    :ivar end_time_utc: The time when the export was completed.
    :vartype end_time_utc: ~datetime.datetime
    :ivar state: The state of the Export Labels operation. Possible values include: "Requested",
     "Running", "Failed", "Completed".
    :vartype state: str or ~azure_machine_learning_workspaces.models.LabelExportState
    """

    _validation = {
        'format': {'required': True},
        'export_id': {'readonly': True},
        'labeling_job_id': {'readonly': True},
        'exported_row_count': {'readonly': True},
        'start_time_utc': {'readonly': True},
        'end_time_utc': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'export_id': {'key': 'exportId', 'type': 'str'},
        'labeling_job_id': {'key': 'labelingJobId', 'type': 'str'},
        'exported_row_count': {'key': 'exportedRowCount', 'type': 'long'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'state': {'key': 'state', 'type': 'str'},
    }

    _subtype_map = {
        'format': {'CSV': 'CsvExportSummary', 'Coco': 'CocoExportSummary', 'Dataset': 'DatasetExportSummary', 'ExportSummaryResource-properties': 'ExportSummaryResourceProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ExportSummary, self).__init__(**kwargs)
        self.format = None  # type: Optional[str]
        self.export_id = None
        self.labeling_job_id = None
        self.exported_row_count = None
        self.start_time_utc = None
        self.end_time_utc = None
        self.state = None


class CocoExportSummary(ExportSummary):
    """CocoExportSummary.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: Required. The format of exported labels, also as the discriminator.Constant
     filled by server.  Possible values include: "Dataset", "Coco", "CSV".
    :type format: str or ~azure_machine_learning_workspaces.models.ExportFormatType
    :ivar export_id: The unique identifier of completed Export Labels operation.
    :vartype export_id: str
    :ivar labeling_job_id: Name and identifier of the job containing exported labels.
    :vartype labeling_job_id: str
    :ivar exported_row_count: The total number of labeled datapoints exported.
    :vartype exported_row_count: long
    :ivar start_time_utc: The time when the export was requested.
    :vartype start_time_utc: ~datetime.datetime
    :ivar end_time_utc: The time when the export was completed.
    :vartype end_time_utc: ~datetime.datetime
    :ivar state: The state of the Export Labels operation. Possible values include: "Requested",
     "Running", "Failed", "Completed".
    :vartype state: str or ~azure_machine_learning_workspaces.models.LabelExportState
    :param snapshot_path: The output path where the labels will be exported.
    :type snapshot_path: str
    :param container_name: The container name to which the labels will be exported.
    :type container_name: str
    """

    _validation = {
        'format': {'required': True},
        'export_id': {'readonly': True},
        'labeling_job_id': {'readonly': True},
        'exported_row_count': {'readonly': True},
        'start_time_utc': {'readonly': True},
        'end_time_utc': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'export_id': {'key': 'exportId', 'type': 'str'},
        'labeling_job_id': {'key': 'labelingJobId', 'type': 'str'},
        'exported_row_count': {'key': 'exportedRowCount', 'type': 'long'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'state': {'key': 'state', 'type': 'str'},
        'snapshot_path': {'key': 'snapshotPath', 'type': 'str'},
        'container_name': {'key': 'containerName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        snapshot_path: Optional[str] = None,
        container_name: Optional[str] = None,
        **kwargs
    ):
        super(CocoExportSummary, self).__init__(**kwargs)
        self.format = 'Coco'  # type: str
        self.snapshot_path = snapshot_path
        self.container_name = container_name


class CodeConfiguration(msrest.serialization.Model):
    """CodeConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param code_artifact_id: The ID of the code asset.
    :type code_artifact_id: str
    :param command: Required. The command to execute on startup of the job. eg. ["python",
     "train.py"].
    :type command: list[str]
    """

    _validation = {
        'command': {'required': True},
    }

    _attribute_map = {
        'code_artifact_id': {'key': 'codeArtifactId', 'type': 'str'},
        'command': {'key': 'command', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        command: List[str],
        code_artifact_id: Optional[str] = None,
        **kwargs
    ):
        super(CodeConfiguration, self).__init__(**kwargs)
        self.code_artifact_id = code_artifact_id
        self.command = command


class CodeContainerResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param description:
    :type description: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(CodeContainerResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.properties = properties
        self.tags = tags
        self.description = description


class CodeContainerResourceArmPaginatedResult(msrest.serialization.Model):
    """CodeContainerResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.CodeContainerResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[CodeContainerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["CodeContainerResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(CodeContainerResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class CodeVersionResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param datastore_id: The asset datastoreId.
    :type datastore_id: str
    :param asset_path: Details of an AssetUri.
    :type asset_path: ~azure_machine_learning_workspaces.models.AssetPath
    :param linked_resource_ids: Associated ARM resources. Key is the link type, value is a list of
     ARM IDs.
    :type linked_resource_ids: dict[str, list[str]]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'datastore_id': {'key': 'properties.datastoreId', 'type': 'str'},
        'asset_path': {'key': 'properties.assetPath', 'type': 'AssetPath'},
        'linked_resource_ids': {'key': 'properties.linkedResourceIds', 'type': '{[str]}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        datastore_id: Optional[str] = None,
        asset_path: Optional["AssetPath"] = None,
        linked_resource_ids: Optional[Dict[str, List[str]]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(CodeVersionResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.datastore_id = datastore_id
        self.asset_path = asset_path
        self.linked_resource_ids = linked_resource_ids
        self.description = description
        self.tags = tags
        self.properties = properties


class CodeVersionResourceArmPaginatedResult(msrest.serialization.Model):
    """CodeVersionResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.CodeVersionResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[CodeVersionResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["CodeVersionResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(CodeVersionResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class DistributionConfiguration(msrest.serialization.Model):
    """DistributionConfiguration.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CommandJobDistributionConfiguration, Mpi, PyTorch, Tensorflow.

    All required parameters must be populated in order to send to Azure.

    :param distribution_type: Required. Specifies the type of distibution framework.Constant filled
     by server.  Possible values include: "PyTorch", "Tensorflow", "Mpi".
    :type distribution_type: str or ~azure_machine_learning_workspaces.models.DistributionType
    """

    _validation = {
        'distribution_type': {'required': True},
    }

    _attribute_map = {
        'distribution_type': {'key': 'distributionType', 'type': 'str'},
    }

    _subtype_map = {
        'distribution_type': {'CommandJob-distributionConfiguration': 'CommandJobDistributionConfiguration', 'Mpi': 'Mpi', 'PyTorch': 'PyTorch', 'Tensorflow': 'Tensorflow'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DistributionConfiguration, self).__init__(**kwargs)
        self.distribution_type = None  # type: Optional[str]


class CommandJobDistributionConfiguration(DistributionConfiguration):
    """Distributon configuration of the job. This should be one of MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param distribution_type: Required. Specifies the type of distibution framework.Constant filled
     by server.  Possible values include: "PyTorch", "Tensorflow", "Mpi".
    :type distribution_type: str or ~azure_machine_learning_workspaces.models.DistributionType
    """

    _validation = {
        'distribution_type': {'required': True},
    }

    _attribute_map = {
        'distribution_type': {'key': 'distributionType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CommandJobDistributionConfiguration, self).__init__(**kwargs)
        self.distribution_type = 'CommandJob-distributionConfiguration'  # type: str


class CommandJobResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Additional attributes of the entity.
    :type properties: ~azure_machine_learning_workspaces.models.CommandJob
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'CommandJob'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "CommandJob",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(CommandJobResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class CommandJobResourceArmPaginatedResult(msrest.serialization.Model):
    """CommandJobResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.CommandJobResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[CommandJobResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["CommandJobResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(CommandJobResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class CommandJobResourceProperties(CommandJob):
    """Additional attributes of the entity.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required.
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: dict[str, ~azure_machine_learning_workspaces.models.DataBinding]
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration:
     ~azure_machine_learning_workspaces.models.DistributionConfiguration
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': '{DataBinding}'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'DistributionConfiguration'},
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        code_configuration: "CodeConfiguration",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        max_run_duration_seconds: Optional[int] = None,
        environment_id: Optional[str] = None,
        data_bindings: Optional[Dict[str, "DataBinding"]] = None,
        distribution_configuration: Optional["DistributionConfiguration"] = None,
        **kwargs
    ):
        super(CommandJobResourceProperties, self).__init__(description=description, tags=tags, properties=properties, experiment_name=experiment_name, compute_binding=compute_binding, output=output, status=status, max_run_duration_seconds=max_run_duration_seconds, code_configuration=code_configuration, environment_id=environment_id, data_bindings=data_bindings, distribution_configuration=distribution_configuration, **kwargs)
        self.job_type = 'Command'  # type: str


class ComputeBinding(msrest.serialization.Model):
    """Compute binding definition.

    All required parameters must be populated in order to send to Azure.

    :param compute_id: Required. ID of the compute resource.
    :type compute_id: str
    :param node_count: Number of nodes.
    :type node_count: int
    """

    _validation = {
        'compute_id': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'compute_id': {'key': 'computeId', 'type': 'str'},
        'node_count': {'key': 'nodeCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        compute_id: str,
        node_count: Optional[int] = None,
        **kwargs
    ):
        super(ComputeBinding, self).__init__(**kwargs)
        self.compute_id = compute_id
        self.node_count = node_count


class MachineLearningResource(msrest.serialization.Model):
    """Azure Resource Manager resource envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        **kwargs
    ):
        super(MachineLearningResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.location = location
        self.type = None
        self.tags = tags
        self.sku = sku
        self.principal_id = None
        self.tenant_id = None
        self.type_identity_type = type_identity_type
        self.user_assigned_identities = user_assigned_identities


class ComputeResource(MachineLearningResource):
    """Machine Learning compute object wrapped into ARM resource envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    :param properties: Compute properties.
    :type properties: ~azure_machine_learning_workspaces.models.Compute
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
        'properties': {'key': 'properties', 'type': 'Compute'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        properties: Optional["Compute"] = None,
        **kwargs
    ):
        super(ComputeResource, self).__init__(location=location, tags=tags, sku=sku, type_identity_type=type_identity_type, user_assigned_identities=user_assigned_identities, **kwargs)
        self.properties = properties


class ContainerRegistry(msrest.serialization.Model):
    """ContainerRegistry.

    :param address:
    :type address: str
    :param username:
    :type username: str
    :param password:
    :type password: str
    """

    _attribute_map = {
        'address': {'key': 'address', 'type': 'str'},
        'username': {'key': 'username', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional[str] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs
    ):
        super(ContainerRegistry, self).__init__(**kwargs)
        self.address = address
        self.username = username
        self.password = password


class ContainerRegistryResponse(msrest.serialization.Model):
    """ContainerRegistryResponse.

    :param address:
    :type address: str
    """

    _attribute_map = {
        'address': {'key': 'address', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional[str] = None,
        **kwargs
    ):
        super(ContainerRegistryResponse, self).__init__(**kwargs)
        self.address = address


class ContainerResourceRequirements(msrest.serialization.Model):
    """The resource requirements for the container (cpu and memory).

    :param cpu: The number of CPU cores on the container.
    :type cpu: float
    :param memory_in_gb: The amount of memory on the container in GB.
    :type memory_in_gb: float
    :param gpu: The number of GPU cores in the container.
    :type gpu: int
    :param fpga: The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
    :type fpga: int
    """

    _attribute_map = {
        'cpu': {'key': 'cpu', 'type': 'float'},
        'memory_in_gb': {'key': 'memoryInGB', 'type': 'float'},
        'gpu': {'key': 'gpu', 'type': 'int'},
        'fpga': {'key': 'fpga', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        cpu: Optional[float] = None,
        memory_in_gb: Optional[float] = None,
        gpu: Optional[int] = None,
        fpga: Optional[int] = None,
        **kwargs
    ):
        super(ContainerResourceRequirements, self).__init__(**kwargs)
        self.cpu = cpu
        self.memory_in_gb = memory_in_gb
        self.gpu = gpu
        self.fpga = fpga


class ContainerResourceRequirementsautogenerated(msrest.serialization.Model):
    """ContainerResourceRequirementsautogenerated.

    :param cpu: The minimum amount of CPU cores to be used by the container. More info:
     https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/.
    :type cpu: float
    :param cpu_limit: The maximum amount of CPU cores allowed to be used by the container. More
     info:
     https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/.
    :type cpu_limit: float
    :param memory_in_gb: The minimum amount of memory (in GB) to be used by the container. More
     info:
     https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/.
    :type memory_in_gb: float
    :param memory_in_gb_limit: The maximum amount of memory (in GB) allowed to be used by the
     container. More info:
     https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/.
    :type memory_in_gb_limit: float
    :param gpu_enabled: If gpu should be enabled.
    :type gpu_enabled: bool
    :param gpu: The number of GPU cores in the container.
    :type gpu: int
    :param fpga: The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
    :type fpga: int
    """

    _attribute_map = {
        'cpu': {'key': 'cpu', 'type': 'float'},
        'cpu_limit': {'key': 'cpuLimit', 'type': 'float'},
        'memory_in_gb': {'key': 'memoryInGB', 'type': 'float'},
        'memory_in_gb_limit': {'key': 'memoryInGBLimit', 'type': 'float'},
        'gpu_enabled': {'key': 'gpuEnabled', 'type': 'bool'},
        'gpu': {'key': 'gpu', 'type': 'int'},
        'fpga': {'key': 'fpga', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        cpu: Optional[float] = None,
        cpu_limit: Optional[float] = None,
        memory_in_gb: Optional[float] = None,
        memory_in_gb_limit: Optional[float] = None,
        gpu_enabled: Optional[bool] = None,
        gpu: Optional[int] = None,
        fpga: Optional[int] = None,
        **kwargs
    ):
        super(ContainerResourceRequirementsautogenerated, self).__init__(**kwargs)
        self.cpu = cpu
        self.cpu_limit = cpu_limit
        self.memory_in_gb = memory_in_gb
        self.memory_in_gb_limit = memory_in_gb_limit
        self.gpu_enabled = gpu_enabled
        self.gpu = gpu
        self.fpga = fpga


class CreatedByDto(msrest.serialization.Model):
    """CreatedByDto.

    :param user_object_id:
    :type user_object_id: str
    :param user_tenant_id:
    :type user_tenant_id: str
    :param user_name:
    :type user_name: str
    """

    _attribute_map = {
        'user_object_id': {'key': 'userObjectId', 'type': 'str'},
        'user_tenant_id': {'key': 'userTenantId', 'type': 'str'},
        'user_name': {'key': 'userName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        user_object_id: Optional[str] = None,
        user_tenant_id: Optional[str] = None,
        user_name: Optional[str] = None,
        **kwargs
    ):
        super(CreatedByDto, self).__init__(**kwargs)
        self.user_object_id = user_object_id
        self.user_tenant_id = user_tenant_id
        self.user_name = user_name


class CreatedFromDto(msrest.serialization.Model):
    """CreatedFromDto.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type:  Default value: "Notebook".
    :vartype type: str
    :ivar location_type:  Default value: "ArtifactId".
    :vartype location_type: str
    :param location:
    :type location: str
    """

    _validation = {
        'type': {'constant': True},
        'location_type': {'constant': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'location_type': {'key': 'locationType', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
    }

    type = "Notebook"
    location_type = "ArtifactId"

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        **kwargs
    ):
        super(CreatedFromDto, self).__init__(**kwargs)
        self.location = location


class CreateRunDto(msrest.serialization.Model):
    """CreateRunDto.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param run_id:
    :type run_id: str
    :param parent_run_id:
    :type parent_run_id: str
    :param status:
    :type status: str
    :param start_time_utc:
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc:
    :type end_time_utc: ~datetime.datetime
    :param heartbeat_enabled:
    :type heartbeat_enabled: bool
    :param name:
    :type name: str
    :param data_container_id:
    :type data_container_id: str
    :param description:
    :type description: str
    :param hidden:
    :type hidden: bool
    :param run_type:
    :type run_type: str
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param script_name:
    :type script_name: str
    :param target:
    :type target: str
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param input_datasets:
    :type input_datasets: list[~azure_machine_learning_workspaces.models.Dataset]
    :param output_datasets:
    :type output_datasets: list[~azure_machine_learning_workspaces.models.OutputDatasetLineage]
    :param run_definition: Any object.
    :type run_definition: object
    :param cancel_uri:
    :type cancel_uri: str
    :param diagnostics_uri:
    :type diagnostics_uri: str
    :param queueing_info:
    :type queueing_info: ~azure_machine_learning_workspaces.models.QueueingInfoDto
    :ivar type:  Default value: "Notebook".
    :vartype type: str
    :ivar location_type:  Default value: "ArtifactId".
    :vartype location_type: str
    :param location:
    :type location: str
    :param generate_data_container_id_if_not_specified:
    :type generate_data_container_id_if_not_specified: bool
    """

    _validation = {
        'type': {'constant': True},
        'location_type': {'constant': True},
    }

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'heartbeat_enabled': {'key': 'heartbeatEnabled', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'hidden': {'key': 'hidden', 'type': 'bool'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'script_name': {'key': 'scriptName', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[Dataset]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'cancel_uri': {'key': 'cancelUri', 'type': 'str'},
        'diagnostics_uri': {'key': 'diagnosticsUri', 'type': 'str'},
        'queueing_info': {'key': 'queueingInfo', 'type': 'QueueingInfoDto'},
        'type': {'key': 'createdFrom.type', 'type': 'str'},
        'location_type': {'key': 'createdFrom.locationType', 'type': 'str'},
        'location': {'key': 'createdFrom.location', 'type': 'str'},
        'generate_data_container_id_if_not_specified': {'key': 'options.generateDataContainerIdIfNotSpecified', 'type': 'bool'},
    }

    type = "Notebook"
    location_type = "ArtifactId"

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        status: Optional[str] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        heartbeat_enabled: Optional[bool] = None,
        name: Optional[str] = None,
        data_container_id: Optional[str] = None,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        run_type: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        script_name: Optional[str] = None,
        target: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        input_datasets: Optional[List["Dataset"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        cancel_uri: Optional[str] = None,
        diagnostics_uri: Optional[str] = None,
        queueing_info: Optional["QueueingInfoDto"] = None,
        location: Optional[str] = None,
        generate_data_container_id_if_not_specified: Optional[bool] = None,
        **kwargs
    ):
        super(CreateRunDto, self).__init__(**kwargs)
        self.run_id = run_id
        self.parent_run_id = parent_run_id
        self.status = status
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.heartbeat_enabled = heartbeat_enabled
        self.name = name
        self.data_container_id = data_container_id
        self.description = description
        self.hidden = hidden
        self.run_type = run_type
        self.properties = properties
        self.script_name = script_name
        self.target = target
        self.tags = tags
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.cancel_uri = cancel_uri
        self.diagnostics_uri = diagnostics_uri
        self.queueing_info = queueing_info
        self.location = location
        self.generate_data_container_id_if_not_specified = generate_data_container_id_if_not_specified


class EnvironmentImageRequest(msrest.serialization.Model):
    """Request to create a Docker image based on Environment.

    :param driver_program: The name of the driver file.
    :type driver_program: str
    :param assets: The list of assets.
    :type assets: list[~azure_machine_learning_workspaces.models.ImageAsset]
    :param model_ids: The list of model Ids.
    :type model_ids: list[str]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment: The details of the AZURE ML environment.
    :type environment: ~azure_machine_learning_workspaces.models.ModelEnvironmentDefinition
    :param environment_reference: The unique identifying details of the AZURE ML environment.
    :type environment_reference: ~azure_machine_learning_workspaces.models.EnvironmentReference
    """

    _attribute_map = {
        'driver_program': {'key': 'driverProgram', 'type': 'str'},
        'assets': {'key': 'assets', 'type': '[ImageAsset]'},
        'model_ids': {'key': 'modelIds', 'type': '[str]'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment': {'key': 'environment', 'type': 'ModelEnvironmentDefinition'},
        'environment_reference': {'key': 'environmentReference', 'type': 'EnvironmentReference'},
    }

    def __init__(
        self,
        *,
        driver_program: Optional[str] = None,
        assets: Optional[List["ImageAsset"]] = None,
        model_ids: Optional[List[str]] = None,
        models: Optional[List["Model"]] = None,
        environment: Optional["ModelEnvironmentDefinition"] = None,
        environment_reference: Optional["EnvironmentReference"] = None,
        **kwargs
    ):
        super(EnvironmentImageRequest, self).__init__(**kwargs)
        self.driver_program = driver_program
        self.assets = assets
        self.model_ids = model_ids
        self.models = models
        self.environment = environment
        self.environment_reference = environment_reference


class CreateServiceRequestEnvironmentImageRequest(EnvironmentImageRequest):
    """The Environment, models and assets needed for inferencing.

    :param driver_program: The name of the driver file.
    :type driver_program: str
    :param assets: The list of assets.
    :type assets: list[~azure_machine_learning_workspaces.models.ImageAsset]
    :param model_ids: The list of model Ids.
    :type model_ids: list[str]
    :param models: The list of models.
    :type models: list[~azure_machine_learning_workspaces.models.Model]
    :param environment: The details of the AZURE ML environment.
    :type environment: ~azure_machine_learning_workspaces.models.ModelEnvironmentDefinition
    :param environment_reference: The unique identifying details of the AZURE ML environment.
    :type environment_reference: ~azure_machine_learning_workspaces.models.EnvironmentReference
    """

    _attribute_map = {
        'driver_program': {'key': 'driverProgram', 'type': 'str'},
        'assets': {'key': 'assets', 'type': '[ImageAsset]'},
        'model_ids': {'key': 'modelIds', 'type': '[str]'},
        'models': {'key': 'models', 'type': '[Model]'},
        'environment': {'key': 'environment', 'type': 'ModelEnvironmentDefinition'},
        'environment_reference': {'key': 'environmentReference', 'type': 'EnvironmentReference'},
    }

    def __init__(
        self,
        *,
        driver_program: Optional[str] = None,
        assets: Optional[List["ImageAsset"]] = None,
        model_ids: Optional[List[str]] = None,
        models: Optional[List["Model"]] = None,
        environment: Optional["ModelEnvironmentDefinition"] = None,
        environment_reference: Optional["EnvironmentReference"] = None,
        **kwargs
    ):
        super(CreateServiceRequestEnvironmentImageRequest, self).__init__(driver_program=driver_program, assets=assets, model_ids=model_ids, models=models, environment=environment, environment_reference=environment_reference, **kwargs)


class CreateServiceRequestKeys(AuthKeys):
    """The authentication keys.

    :param primary_key: The primary key.
    :type primary_key: str
    :param secondary_key: The secondary key.
    :type secondary_key: str
    """

    _attribute_map = {
        'primary_key': {'key': 'primaryKey', 'type': 'str'},
        'secondary_key': {'key': 'secondaryKey', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        primary_key: Optional[str] = None,
        secondary_key: Optional[str] = None,
        **kwargs
    ):
        super(CreateServiceRequestKeys, self).__init__(primary_key=primary_key, secondary_key=secondary_key, **kwargs)


class CsvExportSummary(ExportSummary):
    """CsvExportSummary.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: Required. The format of exported labels, also as the discriminator.Constant
     filled by server.  Possible values include: "Dataset", "Coco", "CSV".
    :type format: str or ~azure_machine_learning_workspaces.models.ExportFormatType
    :ivar export_id: The unique identifier of completed Export Labels operation.
    :vartype export_id: str
    :ivar labeling_job_id: Name and identifier of the job containing exported labels.
    :vartype labeling_job_id: str
    :ivar exported_row_count: The total number of labeled datapoints exported.
    :vartype exported_row_count: long
    :ivar start_time_utc: The time when the export was requested.
    :vartype start_time_utc: ~datetime.datetime
    :ivar end_time_utc: The time when the export was completed.
    :vartype end_time_utc: ~datetime.datetime
    :ivar state: The state of the Export Labels operation. Possible values include: "Requested",
     "Running", "Failed", "Completed".
    :vartype state: str or ~azure_machine_learning_workspaces.models.LabelExportState
    :param snapshot_path: The output path where the labels will be exported.
    :type snapshot_path: str
    :param container_name: The container name to which the labels will be exported.
    :type container_name: str
    """

    _validation = {
        'format': {'required': True},
        'export_id': {'readonly': True},
        'labeling_job_id': {'readonly': True},
        'exported_row_count': {'readonly': True},
        'start_time_utc': {'readonly': True},
        'end_time_utc': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'export_id': {'key': 'exportId', 'type': 'str'},
        'labeling_job_id': {'key': 'labelingJobId', 'type': 'str'},
        'exported_row_count': {'key': 'exportedRowCount', 'type': 'long'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'state': {'key': 'state', 'type': 'str'},
        'snapshot_path': {'key': 'snapshotPath', 'type': 'str'},
        'container_name': {'key': 'containerName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        snapshot_path: Optional[str] = None,
        container_name: Optional[str] = None,
        **kwargs
    ):
        super(CsvExportSummary, self).__init__(**kwargs)
        self.format = 'CSV'  # type: str
        self.snapshot_path = snapshot_path
        self.container_name = container_name


class CustomAssetVersionContainerResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param latest_versions: Latest Versions for all assets.
    :type latest_versions:
     list[~azure_machine_learning_workspaces.models.CustomAssetVersionResource]
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param description:
    :type description: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'latest_versions': {'key': 'properties.latestVersions', 'type': '[CustomAssetVersionResource]'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        latest_versions: Optional[List["CustomAssetVersionResource"]] = None,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(CustomAssetVersionContainerResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.latest_versions = latest_versions
        self.properties = properties
        self.tags = tags
        self.description = description


class CustomAssetVersionContainerResourceArmPaginatedResult(msrest.serialization.Model):
    """CustomAssetVersionContainerResourceArmPaginatedResult.

    :param value:
    :type value:
     list[~azure_machine_learning_workspaces.models.CustomAssetVersionContainerResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[CustomAssetVersionContainerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["CustomAssetVersionContainerResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(CustomAssetVersionContainerResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class CustomAssetVersionResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param custom_asset_type: Custom asset type
     RL currently use this type to store explanations and faireness data. Possible values include:
     "AzuremlExplanation", "AzuremlFairness", "AzuremlModel".
    :type custom_asset_type: str or ~azure_machine_learning_workspaces.models.CustomAssetType
    :param datastore_id: The asset datastoreId.
    :type datastore_id: str
    :param asset_path: Details of an AssetUri.
    :type asset_path: ~azure_machine_learning_workspaces.models.AssetPath
    :param linked_resource_ids: Associated ARM resources. Key is the link type, value is a list of
     ARM IDs.
    :type linked_resource_ids: dict[str, list[str]]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'custom_asset_type': {'key': 'properties.customAssetType', 'type': 'str'},
        'datastore_id': {'key': 'properties.datastoreId', 'type': 'str'},
        'asset_path': {'key': 'properties.assetPath', 'type': 'AssetPath'},
        'linked_resource_ids': {'key': 'properties.linkedResourceIds', 'type': '{[str]}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        custom_asset_type: Optional[Union[str, "CustomAssetType"]] = None,
        datastore_id: Optional[str] = None,
        asset_path: Optional["AssetPath"] = None,
        linked_resource_ids: Optional[Dict[str, List[str]]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(CustomAssetVersionResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.custom_asset_type = custom_asset_type
        self.datastore_id = datastore_id
        self.asset_path = asset_path
        self.linked_resource_ids = linked_resource_ids
        self.description = description
        self.tags = tags
        self.properties = properties


class CustomAssetVersionResourceArmPaginatedResult(msrest.serialization.Model):
    """CustomAssetVersionResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.CustomAssetVersionResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[CustomAssetVersionResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["CustomAssetVersionResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(CustomAssetVersionResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class DataBinding(msrest.serialization.Model):
    """Data binding definition.

    :param source_data_reference: Reference to source data artifact.
    :type source_data_reference: str
    :param local_reference: Location of data inside the container process.
    :type local_reference: str
    :param mode: Mechanism for accessing the data artifact. Possible values include: "Mount",
     "Download", "Upload".
    :type mode: str or ~azure_machine_learning_workspaces.models.DataBindingMode
    """

    _attribute_map = {
        'source_data_reference': {'key': 'sourceDataReference', 'type': 'str'},
        'local_reference': {'key': 'localReference', 'type': 'str'},
        'mode': {'key': 'mode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_data_reference: Optional[str] = None,
        local_reference: Optional[str] = None,
        mode: Optional[Union[str, "DataBindingMode"]] = None,
        **kwargs
    ):
        super(DataBinding, self).__init__(**kwargs)
        self.source_data_reference = source_data_reference
        self.local_reference = local_reference
        self.mode = mode


class Databricks(Compute):
    """A DataFactory compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param databricks_access_token: Databricks access token.
    :type databricks_access_token: str
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'databricks_access_token': {'key': 'properties.databricksAccessToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        databricks_access_token: Optional[str] = None,
        **kwargs
    ):
        super(Databricks, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'Databricks'  # type: str
        self.databricks_access_token = databricks_access_token


class DatabricksComputeSecrets(ComputeSecrets):
    """Secrets related to a Machine Learning compute based on Databricks.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param databricks_access_token: access token for databricks account.
    :type databricks_access_token: str
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'databricks_access_token': {'key': 'databricksAccessToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        databricks_access_token: Optional[str] = None,
        **kwargs
    ):
        super(DatabricksComputeSecrets, self).__init__(**kwargs)
        self.compute_type = 'Databricks'  # type: str
        self.databricks_access_token = databricks_access_token


class DataFactory(Compute):
    """A DataFactory compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ):
        super(DataFactory, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'DataFactory'  # type: str


class DataJob(ComputeJobBase):
    """Data Job definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    :param source: Source datasetId.
    :type source: str
    :param destination: Destination datastoreId.
    :type destination: str
    :param name: Destination dataset name.
    :type name: str
    :param path:
    :type path: str
    :param flow_type:  Possible values include: "Movement", "Materialize", "Transformation".
    :type flow_type: str or ~azure_machine_learning_workspaces.models.FlowType
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
        'source': {'key': 'source', 'type': 'str'},
        'destination': {'key': 'destination', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'flow_type': {'key': 'flowType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        source: Optional[str] = None,
        destination: Optional[str] = None,
        name: Optional[str] = None,
        path: Optional[str] = None,
        flow_type: Optional[Union[str, "FlowType"]] = None,
        **kwargs
    ):
        super(DataJob, self).__init__(description=description, tags=tags, properties=properties, experiment_name=experiment_name, compute_binding=compute_binding, output=output, **kwargs)
        self.job_type = 'Data'  # type: str
        self.source = source
        self.destination = destination
        self.name = name
        self.path = path
        self.flow_type = flow_type


class DataLakeAnalytics(Compute):
    """A DataLakeAnalytics compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param data_lake_store_account_name: DataLake Store Account Name.
    :type data_lake_store_account_name: str
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'data_lake_store_account_name': {'key': 'properties.dataLakeStoreAccountName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        data_lake_store_account_name: Optional[str] = None,
        **kwargs
    ):
        super(DataLakeAnalytics, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'DataLakeAnalytics'  # type: str
        self.data_lake_store_account_name = data_lake_store_account_name


class DataPathAssetReference(AssetReferenceBase):
    """DataPathAssetReference.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    :param path:
    :type path: str
    :param datastore_id:
    :type datastore_id: str
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'datastore_id': {'key': 'datastoreId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        path: Optional[str] = None,
        datastore_id: Optional[str] = None,
        **kwargs
    ):
        super(DataPathAssetReference, self).__init__(**kwargs)
        self.reference_type = 'DataPath'  # type: str
        self.path = path
        self.datastore_id = datastore_id


class Dataset(msrest.serialization.Model):
    """Dataset.

    :param consumption_type:  Possible values include: "RunInput", "Reference".
    :type consumption_type: str or ~azure_machine_learning_workspaces.models.DatasetConsumptionType
    :param input_name:
    :type input_name: str
    :param mechanism:  Possible values include: "Direct", "Mount", "Download".
    :type mechanism: str or ~azure_machine_learning_workspaces.models.DatasetDeliveryMechanism
    :param path_on_compute:
    :type path_on_compute: str
    :param saved_id:
    :type saved_id: str
    :param registered_id:
    :type registered_id: str
    :param registered_version:
    :type registered_version: str
    """

    _attribute_map = {
        'consumption_type': {'key': 'consumptionType', 'type': 'str'},
        'input_name': {'key': 'inputDetails.inputName', 'type': 'str'},
        'mechanism': {'key': 'inputDetails.mechanism', 'type': 'str'},
        'path_on_compute': {'key': 'inputDetails.pathOnCompute', 'type': 'str'},
        'saved_id': {'key': 'identifier.savedId', 'type': 'str'},
        'registered_id': {'key': 'identifier.registeredId', 'type': 'str'},
        'registered_version': {'key': 'identifier.registeredVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        consumption_type: Optional[Union[str, "DatasetConsumptionType"]] = None,
        input_name: Optional[str] = None,
        mechanism: Optional[Union[str, "DatasetDeliveryMechanism"]] = None,
        path_on_compute: Optional[str] = None,
        saved_id: Optional[str] = None,
        registered_id: Optional[str] = None,
        registered_version: Optional[str] = None,
        **kwargs
    ):
        super(Dataset, self).__init__(**kwargs)
        self.consumption_type = consumption_type
        self.input_name = input_name
        self.mechanism = mechanism
        self.path_on_compute = path_on_compute
        self.saved_id = saved_id
        self.registered_id = registered_id
        self.registered_version = registered_version


class DatasetExportSummary(ExportSummary):
    """DatasetExportSummary.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: Required. The format of exported labels, also as the discriminator.Constant
     filled by server.  Possible values include: "Dataset", "Coco", "CSV".
    :type format: str or ~azure_machine_learning_workspaces.models.ExportFormatType
    :ivar export_id: The unique identifier of completed Export Labels operation.
    :vartype export_id: str
    :ivar labeling_job_id: Name and identifier of the job containing exported labels.
    :vartype labeling_job_id: str
    :ivar exported_row_count: The total number of labeled datapoints exported.
    :vartype exported_row_count: long
    :ivar start_time_utc: The time when the export was requested.
    :vartype start_time_utc: ~datetime.datetime
    :ivar end_time_utc: The time when the export was completed.
    :vartype end_time_utc: ~datetime.datetime
    :ivar state: The state of the Export Labels operation. Possible values include: "Requested",
     "Running", "Failed", "Completed".
    :vartype state: str or ~azure_machine_learning_workspaces.models.LabelExportState
    :param labeled_asset_name: The unique name of the labeled data assset.
    :type labeled_asset_name: str
    """

    _validation = {
        'format': {'required': True},
        'export_id': {'readonly': True},
        'labeling_job_id': {'readonly': True},
        'exported_row_count': {'readonly': True},
        'start_time_utc': {'readonly': True},
        'end_time_utc': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'export_id': {'key': 'exportId', 'type': 'str'},
        'labeling_job_id': {'key': 'labelingJobId', 'type': 'str'},
        'exported_row_count': {'key': 'exportedRowCount', 'type': 'long'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'state': {'key': 'state', 'type': 'str'},
        'labeled_asset_name': {'key': 'labeledAssetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        labeled_asset_name: Optional[str] = None,
        **kwargs
    ):
        super(DatasetExportSummary, self).__init__(**kwargs)
        self.format = 'Dataset'  # type: str
        self.labeled_asset_name = labeled_asset_name


class DatasetReference(msrest.serialization.Model):
    """The dataset reference object.

    :param name: The name of the dataset reference.
    :type name: str
    :param id: The id of the dataset reference.
    :type id: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,
        **kwargs
    ):
        super(DatasetReference, self).__init__(**kwargs)
        self.name = name
        self.id = id


class DatastoreContents(msrest.serialization.Model):
    """DatastoreContents.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Storage type backing the datastore. Possible values include:
     "AzureBlob", "AzureDataLake", "AzureDataLakeGen2", "AzureFile", "AzureMySql",
     "AzurePostgreSql", "AzureSqlDatabase", "GlusterFs".
    :type type: str or ~azure_machine_learning_workspaces.models.ContentsType
    :param azure_data_lake:
    :type azure_data_lake: ~azure_machine_learning_workspaces.models.AzureDataLakeSection
    :param azure_my_sql:
    :type azure_my_sql: ~azure_machine_learning_workspaces.models.AzureMySQLSection
    :param azure_postgre_sql:
    :type azure_postgre_sql: ~azure_machine_learning_workspaces.models.AzurePostgreSQLSection
    :param azure_sql_database:
    :type azure_sql_database: ~azure_machine_learning_workspaces.models.AzureSQLDatabaseSection
    :param azure_storage:
    :type azure_storage: ~azure_machine_learning_workspaces.models.AzureStorageSection
    :param gluster_fs:
    :type gluster_fs: ~azure_machine_learning_workspaces.models.GlusterFsSection
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'azure_data_lake': {'key': 'azureDataLake', 'type': 'AzureDataLakeSection'},
        'azure_my_sql': {'key': 'azureMySql', 'type': 'AzureMySQLSection'},
        'azure_postgre_sql': {'key': 'azurePostgreSql', 'type': 'AzurePostgreSQLSection'},
        'azure_sql_database': {'key': 'azureSqlDatabase', 'type': 'AzureSQLDatabaseSection'},
        'azure_storage': {'key': 'azureStorage', 'type': 'AzureStorageSection'},
        'gluster_fs': {'key': 'glusterFs', 'type': 'GlusterFsSection'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "ContentsType"],
        azure_data_lake: Optional["AzureDataLakeSection"] = None,
        azure_my_sql: Optional["AzureMySQLSection"] = None,
        azure_postgre_sql: Optional["AzurePostgreSQLSection"] = None,
        azure_sql_database: Optional["AzureSQLDatabaseSection"] = None,
        azure_storage: Optional["AzureStorageSection"] = None,
        gluster_fs: Optional["GlusterFsSection"] = None,
        **kwargs
    ):
        super(DatastoreContents, self).__init__(**kwargs)
        self.type = type
        self.azure_data_lake = azure_data_lake
        self.azure_my_sql = azure_my_sql
        self.azure_postgre_sql = azure_postgre_sql
        self.azure_sql_database = azure_sql_database
        self.azure_storage = azure_storage
        self.gluster_fs = gluster_fs


class DatastoreCredentials(msrest.serialization.Model):
    """DatastoreCredentials.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Credential type used to authentication with storage. Possible values
     include: "AccountKey", "Certificate", "Sas", "ServicePrincipal", "SqlAdmin".
    :type type: str or ~azure_machine_learning_workspaces.models.CredentialsType
    :param account_key:
    :type account_key: ~azure_machine_learning_workspaces.models.AccountKeySection
    :param certificate:
    :type certificate: ~azure_machine_learning_workspaces.models.CertificateSection
    :param sas:
    :type sas: ~azure_machine_learning_workspaces.models.SasSection
    :param service_principal:
    :type service_principal: ~azure_machine_learning_workspaces.models.ServicePrincipalSection
    :param sql_admin:
    :type sql_admin: ~azure_machine_learning_workspaces.models.SQLAdminSection
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'account_key': {'key': 'accountKey', 'type': 'AccountKeySection'},
        'certificate': {'key': 'certificate', 'type': 'CertificateSection'},
        'sas': {'key': 'sas', 'type': 'SasSection'},
        'service_principal': {'key': 'servicePrincipal', 'type': 'ServicePrincipalSection'},
        'sql_admin': {'key': 'sqlAdmin', 'type': 'SQLAdminSection'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "CredentialsType"],
        account_key: Optional["AccountKeySection"] = None,
        certificate: Optional["CertificateSection"] = None,
        sas: Optional["SasSection"] = None,
        service_principal: Optional["ServicePrincipalSection"] = None,
        sql_admin: Optional["SQLAdminSection"] = None,
        **kwargs
    ):
        super(DatastoreCredentials, self).__init__(**kwargs)
        self.type = type
        self.account_key = account_key
        self.certificate = certificate
        self.sas = sas
        self.service_principal = service_principal
        self.sql_admin = sql_admin


class DatastorePropertiesResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param contents: Required.
    :type contents: ~azure_machine_learning_workspaces.models.DatastoreContents
    :ivar has_been_validated: Whether the service has validated access to the datastore with the
     provided credentials.
    :vartype has_been_validated: bool
    :param is_default: Whether this datastore is the default for the workspace.
    :type is_default: bool
    :param linked_info:
    :type linked_info: ~azure_machine_learning_workspaces.models.LinkedInfo
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'contents': {'required': True},
        'has_been_validated': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'contents': {'key': 'properties.contents', 'type': 'DatastoreContents'},
        'has_been_validated': {'key': 'properties.hasBeenValidated', 'type': 'bool'},
        'is_default': {'key': 'properties.isDefault', 'type': 'bool'},
        'linked_info': {'key': 'properties.linkedInfo', 'type': 'LinkedInfo'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        contents: "DatastoreContents",
        system_data: Optional["SystemData"] = None,
        is_default: Optional[bool] = None,
        linked_info: Optional["LinkedInfo"] = None,
        properties: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(DatastorePropertiesResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.contents = contents
        self.has_been_validated = None
        self.is_default = is_default
        self.linked_info = linked_info
        self.properties = properties
        self.description = description
        self.tags = tags


class DatastorePropertiesResourceArmPaginatedResult(msrest.serialization.Model):
    """DatastorePropertiesResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.DatastorePropertiesResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[DatastorePropertiesResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["DatastorePropertiesResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(DatastorePropertiesResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class DataVersionResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param dataset_type: The Format of dataset. Possible values include: "Simple", "Dataflow".
    :type dataset_type: str or ~azure_machine_learning_workspaces.models.DatasetType
    :param datastore_id: The asset datastoreId.
    :type datastore_id: str
    :param asset_path: Details of an AssetUri.
    :type asset_path: ~azure_machine_learning_workspaces.models.AssetPath
    :param linked_resource_ids: Associated ARM resources. Key is the link type, value is a list of
     ARM IDs.
    :type linked_resource_ids: dict[str, list[str]]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'dataset_type': {'key': 'properties.datasetType', 'type': 'str'},
        'datastore_id': {'key': 'properties.datastoreId', 'type': 'str'},
        'asset_path': {'key': 'properties.assetPath', 'type': 'AssetPath'},
        'linked_resource_ids': {'key': 'properties.linkedResourceIds', 'type': '{[str]}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        dataset_type: Optional[Union[str, "DatasetType"]] = None,
        datastore_id: Optional[str] = None,
        asset_path: Optional["AssetPath"] = None,
        linked_resource_ids: Optional[Dict[str, List[str]]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(DataVersionResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.dataset_type = dataset_type
        self.datastore_id = datastore_id
        self.asset_path = asset_path
        self.linked_resource_ids = linked_resource_ids
        self.description = description
        self.tags = tags
        self.properties = properties


class DataVersionResourceArmPaginatedResult(msrest.serialization.Model):
    """DataVersionResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.DataVersionResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[DataVersionResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["DataVersionResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(DataVersionResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class DebugInfoResponse(msrest.serialization.Model):
    """Internal debugging information not intended for external clients.

    :param type: The type.
    :type type: str
    :param message: The message.
    :type message: str
    :param stack_trace: The stack trace.
    :type stack_trace: str
    :param inner_exception: The inner exception.
    :type inner_exception: ~azure_machine_learning_workspaces.models.DebugInfoResponse
    :param data: The data associated with the error.
    :type data: dict[str, object]
    :param error_response: The error response.
    :type error_response: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'stack_trace': {'key': 'stackTrace', 'type': 'str'},
        'inner_exception': {'key': 'innerException', 'type': 'DebugInfoResponse'},
        'data': {'key': 'data', 'type': '{object}'},
        'error_response': {'key': 'errorResponse', 'type': 'ErrorResponseautogenerated'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        message: Optional[str] = None,
        stack_trace: Optional[str] = None,
        inner_exception: Optional["DebugInfoResponse"] = None,
        data: Optional[Dict[str, object]] = None,
        error_response: Optional["ErrorResponseautogenerated"] = None,
        **kwargs
    ):
        super(DebugInfoResponse, self).__init__(**kwargs)
        self.type = type
        self.message = message
        self.stack_trace = stack_trace
        self.inner_exception = inner_exception
        self.data = data
        self.error_response = error_response


class DebugInfoResponseautogenerated(msrest.serialization.Model):
    """DebugInfoResponseautogenerated.

    :param type:
    :type type: str
    :param message:
    :type message: str
    :param stack_trace:
    :type stack_trace: str
    :param inner_exception:
    :type inner_exception: ~azure_machine_learning_workspaces.models.DebugInfoResponseautogenerated
    :param data: Dictionary of :code:`<any>`.
    :type data: dict[str, object]
    :param error_response:
    :type error_response: ~azure_machine_learning_workspaces.models.ErrorResponse
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'stack_trace': {'key': 'stackTrace', 'type': 'str'},
        'inner_exception': {'key': 'innerException', 'type': 'DebugInfoResponseautogenerated'},
        'data': {'key': 'data', 'type': '{object}'},
        'error_response': {'key': 'errorResponse', 'type': 'ErrorResponse'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        message: Optional[str] = None,
        stack_trace: Optional[str] = None,
        inner_exception: Optional["DebugInfoResponseautogenerated"] = None,
        data: Optional[Dict[str, object]] = None,
        error_response: Optional["ErrorResponse"] = None,
        **kwargs
    ):
        super(DebugInfoResponseautogenerated, self).__init__(**kwargs)
        self.type = type
        self.message = message
        self.stack_trace = stack_trace
        self.inner_exception = inner_exception
        self.data = data
        self.error_response = error_response


class DeleteExperimentTagsResultDto(msrest.serialization.Model):
    """DeleteExperimentTagsResultDto.

    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '{ErrorResponseautogenerated}'},
    }

    def __init__(
        self,
        *,
        errors: Optional[Dict[str, "ErrorResponseautogenerated"]] = None,
        **kwargs
    ):
        super(DeleteExperimentTagsResultDto, self).__init__(**kwargs)
        self.errors = errors


class DeleteRunTagsResultDto(msrest.serialization.Model):
    """DeleteRunTagsResultDto.

    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '{ErrorResponseautogenerated}'},
    }

    def __init__(
        self,
        *,
        errors: Optional[Dict[str, "ErrorResponseautogenerated"]] = None,
        **kwargs
    ):
        super(DeleteRunTagsResultDto, self).__init__(**kwargs)
        self.errors = errors


class DeleteTagsCommandDto(msrest.serialization.Model):
    """DeleteTagsCommandDto.

    :param tags: A set of tags.
    :type tags: list[str]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        super(DeleteTagsCommandDto, self).__init__(**kwargs)
        self.tags = tags


class DeleteTagsResultDto(msrest.serialization.Model):
    """DeleteTagsResultDto.

    :param errors: Dictionary of :code:`<ErrorResponse>`.
    :type errors: dict[str, ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated]
    """

    _attribute_map = {
        'errors': {'key': 'errors', 'type': '{ErrorResponseautogenerated}'},
    }

    def __init__(
        self,
        *,
        errors: Optional[Dict[str, "ErrorResponseautogenerated"]] = None,
        **kwargs
    ):
        super(DeleteTagsResultDto, self).__init__(**kwargs)
        self.errors = errors


class DeploymentScaleSettings(msrest.serialization.Model):
    """DeploymentScaleSettings.

    :param node_count: Number of Compute nodes to be used for running the deployment.
    :type node_count: int
    """

    _attribute_map = {
        'node_count': {'key': 'nodeCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        node_count: Optional[int] = None,
        **kwargs
    ):
        super(DeploymentScaleSettings, self).__init__(**kwargs)
        self.node_count = node_count


class DockerProperties(msrest.serialization.Model):
    """Class to represent configuration settings for Docker.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Type of Docker Properties specified. Possible values include: "Dockerfile",
     "DockerImage".
    :vartype type: str or ~azure_machine_learning_workspaces.models.DockerSpecificationType
    :param docker_image_uri: Image name of a custom base image. This property will not be used if
     Dockerfile is supplied
     and Type is DockerSpecificationType.Dockerfile.
    Microsoft.MachineLearning.ManagementFrontEnd.Contracts.Assets.EnvironmentSpecificationVersion.DockerProperties.Type:code:`<seealso
     href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-
     image#use-a-custom-base-image" />`.
    :type docker_image_uri: str
    :param dockerfile: Docker command line instructions to assemble an image.
    
    
     .. raw:: html
    
        <seealso href="https://repo2docker.readthedocs.io/en/latest/config_files.html#dockerfile-
     advanced-environments" />.
    :type dockerfile: str
    :param context: Path to a snapshot of the Docker Context. This property is only valid if
     Dockerfile is specified.
     The path is relative to AssetPaths which must contain a single Blob URI value.
     Microsoft.MachineLearning.ManagementFrontEnd.Contracts.Assets.Asset.AssetPath:code:`<seealso
     href="https://docs.docker.com/engine/context/working-with-contexts/" />`.
    :type context: str
    """

    _validation = {
        'type': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'docker_image_uri': {'key': 'dockerImageUri', 'type': 'str'},
        'dockerfile': {'key': 'dockerfile', 'type': 'str'},
        'context': {'key': 'context', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        docker_image_uri: Optional[str] = None,
        dockerfile: Optional[str] = None,
        context: Optional[str] = None,
        **kwargs
    ):
        super(DockerProperties, self).__init__(**kwargs)
        self.type = None
        self.docker_image_uri = docker_image_uri
        self.dockerfile = dockerfile
        self.context = context


class EncryptionProperties(msrest.serialization.Model):
    """EncryptionProperties.

    :param vault_base_url: vault base Url.
    :type vault_base_url: str
    :param key_name: Encryption Key name.
    :type key_name: str
    :param key_version: Encryption Key Version.
    :type key_version: str
    """

    _attribute_map = {
        'vault_base_url': {'key': 'vaultBaseUrl', 'type': 'str'},
        'key_name': {'key': 'keyName', 'type': 'str'},
        'key_version': {'key': 'keyVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vault_base_url: Optional[str] = None,
        key_name: Optional[str] = None,
        key_version: Optional[str] = None,
        **kwargs
    ):
        super(EncryptionProperties, self).__init__(**kwargs)
        self.vault_base_url = vault_base_url
        self.key_name = key_name
        self.key_version = key_version


class EnvironmentContainer(msrest.serialization.Model):
    """EnvironmentContainer.

    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param description:
    :type description: str
    """

    _attribute_map = {
        'properties': {'key': 'properties', 'type': '{str}'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        properties: Optional[Dict[str, str]] = None,
        tags: Optional[Dict[str, str]] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentContainer, self).__init__(**kwargs)
        self.properties = properties
        self.tags = tags
        self.description = description


class EnvironmentContainerResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required.
    :type properties: ~azure_machine_learning_workspaces.models.EnvironmentContainer
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'EnvironmentContainer'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "EnvironmentContainer",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(EnvironmentContainerResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class EnvironmentContainerResourceArmPaginatedResult(msrest.serialization.Model):
    """EnvironmentContainerResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.EnvironmentContainerResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[EnvironmentContainerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["EnvironmentContainerResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentContainerResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ModelEnvironmentDefinition(msrest.serialization.Model):
    """ModelEnvironmentDefinition.

    :param name: The name of the environment.
    :type name: str
    :param version: The environment version.
    :type version: str
    :param python: Settings for a Python environment.
    :type python: ~azure_machine_learning_workspaces.models.ModelPythonSection
    :param environment_variables: Definition of environment variables to be defined in the
     environment.
    :type environment_variables: dict[str, str]
    :param docker: The definition of a Docker container.
    :type docker: ~azure_machine_learning_workspaces.models.ModelDockerSection
    :param spark: The configuration for a Spark environment.
    :type spark: ~azure_machine_learning_workspaces.models.ModelSparkSection
    :param r: Settings for a R environment.
    :type r: ~azure_machine_learning_workspaces.models.RSection
    :param inferencing_stack_version: The inferencing stack version added to the image. To avoid
     adding an inferencing stack, do not set this value. Valid values: "latest".
    :type inferencing_stack_version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'python': {'key': 'python', 'type': 'ModelPythonSection'},
        'environment_variables': {'key': 'environmentVariables', 'type': '{str}'},
        'docker': {'key': 'docker', 'type': 'ModelDockerSection'},
        'spark': {'key': 'spark', 'type': 'ModelSparkSection'},
        'r': {'key': 'r', 'type': 'RSection'},
        'inferencing_stack_version': {'key': 'inferencingStackVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        python: Optional["ModelPythonSection"] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        docker: Optional["ModelDockerSection"] = None,
        spark: Optional["ModelSparkSection"] = None,
        r: Optional["RSection"] = None,
        inferencing_stack_version: Optional[str] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinition, self).__init__(**kwargs)
        self.name = name
        self.version = version
        self.python = python
        self.environment_variables = environment_variables
        self.docker = docker
        self.spark = spark
        self.r = r
        self.inferencing_stack_version = inferencing_stack_version


class EnvironmentImageRequestEnvironment(ModelEnvironmentDefinition):
    """The details of the AZURE ML environment.

    :param name: The name of the environment.
    :type name: str
    :param version: The environment version.
    :type version: str
    :param python: Settings for a Python environment.
    :type python: ~azure_machine_learning_workspaces.models.ModelPythonSection
    :param environment_variables: Definition of environment variables to be defined in the
     environment.
    :type environment_variables: dict[str, str]
    :param docker: The definition of a Docker container.
    :type docker: ~azure_machine_learning_workspaces.models.ModelDockerSection
    :param spark: The configuration for a Spark environment.
    :type spark: ~azure_machine_learning_workspaces.models.ModelSparkSection
    :param r: Settings for a R environment.
    :type r: ~azure_machine_learning_workspaces.models.RSection
    :param inferencing_stack_version: The inferencing stack version added to the image. To avoid
     adding an inferencing stack, do not set this value. Valid values: "latest".
    :type inferencing_stack_version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'python': {'key': 'python', 'type': 'ModelPythonSection'},
        'environment_variables': {'key': 'environmentVariables', 'type': '{str}'},
        'docker': {'key': 'docker', 'type': 'ModelDockerSection'},
        'spark': {'key': 'spark', 'type': 'ModelSparkSection'},
        'r': {'key': 'r', 'type': 'RSection'},
        'inferencing_stack_version': {'key': 'inferencingStackVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        python: Optional["ModelPythonSection"] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        docker: Optional["ModelDockerSection"] = None,
        spark: Optional["ModelSparkSection"] = None,
        r: Optional["RSection"] = None,
        inferencing_stack_version: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentImageRequestEnvironment, self).__init__(name=name, version=version, python=python, environment_variables=environment_variables, docker=docker, spark=spark, r=r, inferencing_stack_version=inferencing_stack_version, **kwargs)


class EnvironmentReference(msrest.serialization.Model):
    """EnvironmentReference.

    :param name: Name of the environment.
    :type name: str
    :param version: Version of the environment.
    :type version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentReference, self).__init__(**kwargs)
        self.name = name
        self.version = version


class EnvironmentImageRequestEnvironmentReference(EnvironmentReference):
    """The unique identifying details of the AZURE ML environment.

    :param name: Name of the environment.
    :type name: str
    :param version: Version of the environment.
    :type version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentImageRequestEnvironmentReference, self).__init__(name=name, version=version, **kwargs)


class ModelEnvironmentDefinitionResponse(msrest.serialization.Model):
    """ModelEnvironmentDefinitionResponse.

    :param name: The name of the environment.
    :type name: str
    :param version: The environment version.
    :type version: str
    :param python: Settings for a Python environment.
    :type python: ~azure_machine_learning_workspaces.models.ModelPythonSection
    :param environment_variables: Definition of environment variables to be defined in the
     environment.
    :type environment_variables: dict[str, str]
    :param docker: The definition of a Docker container.
    :type docker: ~azure_machine_learning_workspaces.models.ModelDockerSectionResponse
    :param spark: The configuration for a Spark environment.
    :type spark: ~azure_machine_learning_workspaces.models.ModelSparkSection
    :param r: Settings for a R environment.
    :type r: ~azure_machine_learning_workspaces.models.RSectionResponse
    :param inferencing_stack_version: The inferencing stack version added to the image. To avoid
     adding an inferencing stack, do not set this value. Valid values: "latest".
    :type inferencing_stack_version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'python': {'key': 'python', 'type': 'ModelPythonSection'},
        'environment_variables': {'key': 'environmentVariables', 'type': '{str}'},
        'docker': {'key': 'docker', 'type': 'ModelDockerSectionResponse'},
        'spark': {'key': 'spark', 'type': 'ModelSparkSection'},
        'r': {'key': 'r', 'type': 'RSectionResponse'},
        'inferencing_stack_version': {'key': 'inferencingStackVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        python: Optional["ModelPythonSection"] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        docker: Optional["ModelDockerSectionResponse"] = None,
        spark: Optional["ModelSparkSection"] = None,
        r: Optional["RSectionResponse"] = None,
        inferencing_stack_version: Optional[str] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionResponse, self).__init__(**kwargs)
        self.name = name
        self.version = version
        self.python = python
        self.environment_variables = environment_variables
        self.docker = docker
        self.spark = spark
        self.r = r
        self.inferencing_stack_version = inferencing_stack_version


class EnvironmentImageResponseEnvironment(ModelEnvironmentDefinitionResponse):
    """The details of the AZURE ML environment.

    :param name: The name of the environment.
    :type name: str
    :param version: The environment version.
    :type version: str
    :param python: Settings for a Python environment.
    :type python: ~azure_machine_learning_workspaces.models.ModelPythonSection
    :param environment_variables: Definition of environment variables to be defined in the
     environment.
    :type environment_variables: dict[str, str]
    :param docker: The definition of a Docker container.
    :type docker: ~azure_machine_learning_workspaces.models.ModelDockerSectionResponse
    :param spark: The configuration for a Spark environment.
    :type spark: ~azure_machine_learning_workspaces.models.ModelSparkSection
    :param r: Settings for a R environment.
    :type r: ~azure_machine_learning_workspaces.models.RSectionResponse
    :param inferencing_stack_version: The inferencing stack version added to the image. To avoid
     adding an inferencing stack, do not set this value. Valid values: "latest".
    :type inferencing_stack_version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'python': {'key': 'python', 'type': 'ModelPythonSection'},
        'environment_variables': {'key': 'environmentVariables', 'type': '{str}'},
        'docker': {'key': 'docker', 'type': 'ModelDockerSectionResponse'},
        'spark': {'key': 'spark', 'type': 'ModelSparkSection'},
        'r': {'key': 'r', 'type': 'RSectionResponse'},
        'inferencing_stack_version': {'key': 'inferencingStackVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        python: Optional["ModelPythonSection"] = None,
        environment_variables: Optional[Dict[str, str]] = None,
        docker: Optional["ModelDockerSectionResponse"] = None,
        spark: Optional["ModelSparkSection"] = None,
        r: Optional["RSectionResponse"] = None,
        inferencing_stack_version: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentImageResponseEnvironment, self).__init__(name=name, version=version, python=python, environment_variables=environment_variables, docker=docker, spark=spark, r=r, inferencing_stack_version=inferencing_stack_version, **kwargs)


class EnvironmentImageResponseEnvironmentReference(EnvironmentReference):
    """The unique identifying details of the AZURE ML environment.

    :param name: Name of the environment.
    :type name: str
    :param version: Version of the environment.
    :type version: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentImageResponseEnvironmentReference, self).__init__(name=name, version=version, **kwargs)


class EnvironmentOverrides(msrest.serialization.Model):
    """EnvironmentOverrides.

    :param environment_variables: Dictionary of :code:`<string>`.
    :type environment_variables: dict[str, str]
    """

    _attribute_map = {
        'environment_variables': {'key': 'environmentVariables', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        environment_variables: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(EnvironmentOverrides, self).__init__(**kwargs)
        self.environment_variables = environment_variables


class EnvironmentSpecificationVersion(msrest.serialization.Model):
    """Data Transfer Object (DTO) for an Execution Environment Specification. Name and
version should default to the AzureML-Minimal environment version tested with the
current SDK client version as this is a main use-case.


.. raw:: html

   <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />.

    :param type: Environment specification is either user managed or curated by the Azure ML
     service
    
    
     .. raw:: html
    
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-
     environments" />. Possible values include: "Curated", "UserCreated".
    :type type: str or ~azure_machine_learning_workspaces.models.EnvironmentSpecificationType
    :param docker: Class to represent configuration settings for Docker.
    :type docker: ~azure_machine_learning_workspaces.models.DockerProperties
    :param python: Class to represent configuration settings for Python and Conda.
    :type python: ~azure_machine_learning_workspaces.models.PythonProperties
    :param runtime: Specifies the version of the runtime (e.g the version of Python or R snapshot)
    
    
     .. raw:: html
    
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#runtime-txt-
     specifying-runtimes" />.
    :type runtime: str
    :param r_install: Used to install R libraries pinned to a specific snapshot on MRAN
    
     :code:`<see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#install-r-
     install-an-r-rstudio-environment" />`:code:`<seealso
     href="https://mran.microsoft.com/documents/rro/reproducibility" />`.
    :type r_install: str
    :param spark_maven_pom: Spark Maven project object model file used to specify dependencies
    
    
     .. raw:: html
    
        <see href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html" />.
    :type spark_maven_pom: str
    :param datastore_id: The asset datastoreId.
    :type datastore_id: str
    :param asset_path: Details of an AssetUri.
    :type asset_path: ~azure_machine_learning_workspaces.models.AssetPath
    :param linked_resource_ids: Associated ARM resources. Key is the link type, value is a list of
     ARM IDs.
    :type linked_resource_ids: dict[str, list[str]]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'docker': {'key': 'docker', 'type': 'DockerProperties'},
        'python': {'key': 'python', 'type': 'PythonProperties'},
        'runtime': {'key': 'runtime', 'type': 'str'},
        'r_install': {'key': 'rInstall', 'type': 'str'},
        'spark_maven_pom': {'key': 'sparkMavenPom', 'type': 'str'},
        'datastore_id': {'key': 'datastoreId', 'type': 'str'},
        'asset_path': {'key': 'assetPath', 'type': 'AssetPath'},
        'linked_resource_ids': {'key': 'linkedResourceIds', 'type': '{[str]}'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "EnvironmentSpecificationType"]] = None,
        docker: Optional["DockerProperties"] = None,
        python: Optional["PythonProperties"] = None,
        runtime: Optional[str] = None,
        r_install: Optional[str] = None,
        spark_maven_pom: Optional[str] = None,
        datastore_id: Optional[str] = None,
        asset_path: Optional["AssetPath"] = None,
        linked_resource_ids: Optional[Dict[str, List[str]]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(EnvironmentSpecificationVersion, self).__init__(**kwargs)
        self.type = type
        self.docker = docker
        self.python = python
        self.runtime = runtime
        self.r_install = r_install
        self.spark_maven_pom = spark_maven_pom
        self.datastore_id = datastore_id
        self.asset_path = asset_path
        self.linked_resource_ids = linked_resource_ids
        self.description = description
        self.tags = tags
        self.properties = properties


class EnvironmentSpecificationVersionResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Data Transfer Object (DTO) for an Execution Environment
     Specification. Name and
     version should default to the AzureML-Minimal environment version tested with the
     current SDK client version as this is a main use-case.
    
    
     .. raw:: html
    
        <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />.
    :type properties: ~azure_machine_learning_workspaces.models.EnvironmentSpecificationVersion
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'EnvironmentSpecificationVersion'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "EnvironmentSpecificationVersion",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(EnvironmentSpecificationVersionResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class EnvironmentSpecificationVersionResourceArmPaginatedResult(msrest.serialization.Model):
    """EnvironmentSpecificationVersionResourceArmPaginatedResult.

    :param value:
    :type value:
     list[~azure_machine_learning_workspaces.models.EnvironmentSpecificationVersionResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[EnvironmentSpecificationVersionResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["EnvironmentSpecificationVersionResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(EnvironmentSpecificationVersionResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ErrorDetail(msrest.serialization.Model):
    """Error detail information.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. Error code.
    :type code: str
    :param message: Required. Error message.
    :type message: str
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        **kwargs
    ):
        super(ErrorDetail, self).__init__(**kwargs)
        self.code = code
        self.message = message


class ErrorDetails(msrest.serialization.Model):
    """The error details.

    :param code: The error code.
    :type code: str
    :param message: The error message.
    :type message: str
    :param target: The target of the error (e.g., the name of the property in error).
    :type target: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        target: Optional[str] = None,
        **kwargs
    ):
        super(ErrorDetails, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target


class ErrorResponse(msrest.serialization.Model):
    """ErrorResponse.

    :param error:
    :type error: ~azure_machine_learning_workspaces.models.RootError
    :param correlation: Dictionary of :code:`<string>`.
    :type correlation: dict[str, str]
    :param environment:
    :type environment: str
    :param location:
    :type location: str
    :param time:
    :type time: ~datetime.datetime
    :param component_name:
    :type component_name: str
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'RootError'},
        'correlation': {'key': 'correlation', 'type': '{str}'},
        'environment': {'key': 'environment', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'time': {'key': 'time', 'type': 'iso-8601'},
        'component_name': {'key': 'componentName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        error: Optional["RootError"] = None,
        correlation: Optional[Dict[str, str]] = None,
        environment: Optional[str] = None,
        location: Optional[str] = None,
        time: Optional[datetime.datetime] = None,
        component_name: Optional[str] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error
        self.correlation = correlation
        self.environment = environment
        self.location = location
        self.time = time
        self.component_name = component_name


class ErrorResponseautogenerated(msrest.serialization.Model):
    """The error response.

    :param error: The top level error that occurred.
    :type error: ~azure_machine_learning_workspaces.models.RootErrorautogenerated
    :param correlation: Dictionary containing correlation details for the error.
    :type correlation: dict[str, str]
    :param environment: The hosting environment.
    :type environment: str
    :param location: The Azure region.
    :type location: str
    :param time: The time in UTC.
    :type time: ~datetime.datetime
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'RootErrorautogenerated'},
        'correlation': {'key': 'correlation', 'type': '{str}'},
        'environment': {'key': 'environment', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'time': {'key': 'time', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        error: Optional["RootErrorautogenerated"] = None,
        correlation: Optional[Dict[str, str]] = None,
        environment: Optional[str] = None,
        location: Optional[str] = None,
        time: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(ErrorResponseautogenerated, self).__init__(**kwargs)
        self.error = error
        self.correlation = correlation
        self.environment = environment
        self.location = location
        self.time = time


class EstimatedVmPrice(msrest.serialization.Model):
    """The estimated price info for using a VM of a particular OS type, tier, etc.

    All required parameters must be populated in order to send to Azure.

    :param retail_price: Required. The price charged for using the VM.
    :type retail_price: float
    :param os_type: Required. Operating system type used by the VM. Possible values include:
     "Linux", "Windows".
    :type os_type: str or ~azure_machine_learning_workspaces.models.VmPriceOsType
    :param vm_tier: Required. The type of the VM. Possible values include: "Standard",
     "LowPriority", "Spot".
    :type vm_tier: str or ~azure_machine_learning_workspaces.models.VmTier
    """

    _validation = {
        'retail_price': {'required': True},
        'os_type': {'required': True},
        'vm_tier': {'required': True},
    }

    _attribute_map = {
        'retail_price': {'key': 'retailPrice', 'type': 'float'},
        'os_type': {'key': 'osType', 'type': 'str'},
        'vm_tier': {'key': 'vmTier', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        retail_price: float,
        os_type: Union[str, "VmPriceOsType"],
        vm_tier: Union[str, "VmTier"],
        **kwargs
    ):
        super(EstimatedVmPrice, self).__init__(**kwargs)
        self.retail_price = retail_price
        self.os_type = os_type
        self.vm_tier = vm_tier


class EstimatedVmPrices(msrest.serialization.Model):
    """The estimated price info for using a VM.

    All required parameters must be populated in order to send to Azure.

    :param billing_currency: Required. Three lettered code specifying the currency of the VM price.
     Example: USD. Possible values include: "USD".
    :type billing_currency: str or ~azure_machine_learning_workspaces.models.BillingCurrency
    :param unit_of_measure: Required. The unit of time measurement for the specified VM price.
     Example: OneHour. Possible values include: "OneHour".
    :type unit_of_measure: str or ~azure_machine_learning_workspaces.models.UnitOfMeasure
    :param values: Required. The list of estimated prices for using a VM of a particular OS type,
     tier, etc.
    :type values: list[~azure_machine_learning_workspaces.models.EstimatedVmPrice]
    """

    _validation = {
        'billing_currency': {'required': True},
        'unit_of_measure': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'billing_currency': {'key': 'billingCurrency', 'type': 'str'},
        'unit_of_measure': {'key': 'unitOfMeasure', 'type': 'str'},
        'values': {'key': 'values', 'type': '[EstimatedVmPrice]'},
    }

    def __init__(
        self,
        *,
        billing_currency: Union[str, "BillingCurrency"],
        unit_of_measure: Union[str, "UnitOfMeasure"],
        values: List["EstimatedVmPrice"],
        **kwargs
    ):
        super(EstimatedVmPrices, self).__init__(**kwargs)
        self.billing_currency = billing_currency
        self.unit_of_measure = unit_of_measure
        self.values = values


class EvaluationConfiguration(msrest.serialization.Model):
    """EvaluationConfiguration.

    :param primary_metric_name:
    :type primary_metric_name: str
    :param primary_metric_goal: Defines supported metric goals for hyperparameter tuning. Possible
     values include: "Minimize", "Maximize".
    :type primary_metric_goal: str or ~azure_machine_learning_workspaces.models.PrimaryMetricGoal
    """

    _attribute_map = {
        'primary_metric_name': {'key': 'primaryMetricName', 'type': 'str'},
        'primary_metric_goal': {'key': 'primaryMetricGoal', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        primary_metric_name: Optional[str] = None,
        primary_metric_goal: Optional[Union[str, "PrimaryMetricGoal"]] = None,
        **kwargs
    ):
        super(EvaluationConfiguration, self).__init__(**kwargs)
        self.primary_metric_name = primary_metric_name
        self.primary_metric_goal = primary_metric_goal


class ExperimentDto(msrest.serialization.Model):
    """ExperimentDto.

    :param experiment_id:
    :type experiment_id: str
    :param name:
    :type name: str
    :param description:
    :type description: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param archived_time:
    :type archived_time: ~datetime.datetime
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'archived_time': {'key': 'archivedTime', 'type': 'iso-8601'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        experiment_id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        archived_time: Optional[datetime.datetime] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ExperimentDto, self).__init__(**kwargs)
        self.experiment_id = experiment_id
        self.name = name
        self.description = description
        self.created_utc = created_utc
        self.archived_time = archived_time
        self.tags = tags


class ExperimentQueryParamsDto(msrest.serialization.Model):
    """ExperimentQueryParamsDto.

    :param filter:
    :type filter: str
    :param continuation_token:
    :type continuation_token: str
    :param orderby:
    :type orderby: str
    :param top:
    :type top: int
    :param view_type:  Possible values include: "Default", "All", "ActiveOnly", "ArchivedOnly".
    :type view_type: str or
     ~azure_machine_learning_workspaces.models.ExperimentQueryParamsDtoViewType
    """

    _attribute_map = {
        'filter': {'key': 'filter', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'orderby': {'key': 'orderby', 'type': 'str'},
        'top': {'key': 'top', 'type': 'int'},
        'view_type': {'key': 'viewType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        filter: Optional[str] = None,
        continuation_token: Optional[str] = None,
        orderby: Optional[str] = None,
        top: Optional[int] = None,
        view_type: Optional[Union[str, "ExperimentQueryParamsDtoViewType"]] = None,
        **kwargs
    ):
        super(ExperimentQueryParamsDto, self).__init__(**kwargs)
        self.filter = filter
        self.continuation_token = continuation_token
        self.orderby = orderby
        self.top = top
        self.view_type = view_type


class ExportSummaryResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Additional attributes of the entity.
    :type properties: ~azure_machine_learning_workspaces.models.ExportSummary
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'ExportSummary'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "ExportSummary",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(ExportSummaryResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class ExportSummaryResourceProperties(ExportSummary):
    """Additional attributes of the entity.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: Required. The format of exported labels, also as the discriminator.Constant
     filled by server.  Possible values include: "Dataset", "Coco", "CSV".
    :type format: str or ~azure_machine_learning_workspaces.models.ExportFormatType
    :ivar export_id: The unique identifier of completed Export Labels operation.
    :vartype export_id: str
    :ivar labeling_job_id: Name and identifier of the job containing exported labels.
    :vartype labeling_job_id: str
    :ivar exported_row_count: The total number of labeled datapoints exported.
    :vartype exported_row_count: long
    :ivar start_time_utc: The time when the export was requested.
    :vartype start_time_utc: ~datetime.datetime
    :ivar end_time_utc: The time when the export was completed.
    :vartype end_time_utc: ~datetime.datetime
    :ivar state: The state of the Export Labels operation. Possible values include: "Requested",
     "Running", "Failed", "Completed".
    :vartype state: str or ~azure_machine_learning_workspaces.models.LabelExportState
    """

    _validation = {
        'format': {'required': True},
        'export_id': {'readonly': True},
        'labeling_job_id': {'readonly': True},
        'exported_row_count': {'readonly': True},
        'start_time_utc': {'readonly': True},
        'end_time_utc': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'export_id': {'key': 'exportId', 'type': 'str'},
        'labeling_job_id': {'key': 'labelingJobId', 'type': 'str'},
        'exported_row_count': {'key': 'exportedRowCount', 'type': 'long'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'state': {'key': 'state', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ExportSummaryResourceProperties, self).__init__(**kwargs)
        self.format = 'ExportSummaryResource-properties'  # type: str


class GlusterFsSection(msrest.serialization.Model):
    """GlusterFsSection.

    All required parameters must be populated in order to send to Azure.

    :param server_address: Required. GlusterFS server address (can be the IP address or server
     name).
    :type server_address: str
    :param volume_name: Required. GlusterFS volume name.
    :type volume_name: str
    """

    _validation = {
        'server_address': {'required': True, 'pattern': r'\w'},
        'volume_name': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'server_address': {'key': 'serverAddress', 'type': 'str'},
        'volume_name': {'key': 'volumeName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        server_address: str,
        volume_name: str,
        **kwargs
    ):
        super(GlusterFsSection, self).__init__(**kwargs)
        self.server_address = server_address
        self.volume_name = volume_name


class HdInsight(Compute):
    """A HDInsight compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param ssh_port: Port open for ssh connections on the master node of the cluster.
    :type ssh_port: int
    :param address: Public IP address of the master node of the cluster.
    :type address: str
    :param administrator_account: Admin credentials for master node of the cluster.
    :type administrator_account:
     ~azure_machine_learning_workspaces.models.VirtualMachineSshCredentials
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'ssh_port': {'key': 'properties.sshPort', 'type': 'int'},
        'address': {'key': 'properties.address', 'type': 'str'},
        'administrator_account': {'key': 'properties.administratorAccount', 'type': 'VirtualMachineSshCredentials'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        ssh_port: Optional[int] = None,
        address: Optional[str] = None,
        administrator_account: Optional["VirtualMachineSshCredentials"] = None,
        **kwargs
    ):
        super(HdInsight, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'HDInsight'  # type: str
        self.ssh_port = ssh_port
        self.address = address
        self.administrator_account = administrator_account


class IdAssetReference(AssetReferenceBase):
    """IdAssetReference.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    :param id:
    :type id: str
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        **kwargs
    ):
        super(IdAssetReference, self).__init__(**kwargs)
        self.reference_type = 'Id'  # type: str
        self.id = id


class ImageAsset(msrest.serialization.Model):
    """An Image asset.

    :param id: The Asset Id.
    :type id: str
    :param mime_type: The mime type.
    :type mime_type: str
    :param url: The Url of the Asset.
    :type url: str
    :param unpack: Whether the Asset is unpacked.
    :type unpack: bool
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'mime_type': {'key': 'mimeType', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
        'unpack': {'key': 'unpack', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        mime_type: Optional[str] = None,
        url: Optional[str] = None,
        unpack: Optional[bool] = None,
        **kwargs
    ):
        super(ImageAsset, self).__init__(**kwargs)
        self.id = id
        self.mime_type = mime_type
        self.url = url
        self.unpack = unpack


class InferenceEndpointKeys(msrest.serialization.Model):
    """InferenceEndpointKeys.

    :param endpoint_key: Endpoint keys.
    :type endpoint_key: str
    """

    _attribute_map = {
        'endpoint_key': {'key': 'endpointKey', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        endpoint_key: Optional[str] = None,
        **kwargs
    ):
        super(InferenceEndpointKeys, self).__init__(**kwargs)
        self.endpoint_key = endpoint_key


class InferenceEndpointKeysTrackedResource(msrest.serialization.Model):
    """InferenceEndpointKeysTrackedResource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param location:
    :type location: str
    :param kind:
    :type kind: str
    :param identity:
    :type identity: ~azure_machine_learning_workspaces.models.ResourceIdentityInArm
    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required.
    :type properties: ~azure_machine_learning_workspaces.models.InferenceEndpointKeys
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentityInArm'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'InferenceEndpointKeys'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "InferenceEndpointKeys",
        tags: Optional[Dict[str, str]] = None,
        location: Optional[str] = None,
        kind: Optional[str] = None,
        identity: Optional["ResourceIdentityInArm"] = None,
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(InferenceEndpointKeysTrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location
        self.kind = kind
        self.identity = identity
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class InnerErrorResponse(msrest.serialization.Model):
    """InnerErrorResponse.

    :param code:
    :type code: str
    :param inner_error:
    :type inner_error: ~azure_machine_learning_workspaces.models.InnerErrorResponse
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponse'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        inner_error: Optional["InnerErrorResponse"] = None,
        **kwargs
    ):
        super(InnerErrorResponse, self).__init__(**kwargs)
        self.code = code
        self.inner_error = inner_error


class InnerErrorResponseautogenerated(msrest.serialization.Model):
    """A nested structure of errors.

    :param code: The error code.
    :type code: str
    :param inner_error: A nested list of inner errors. When evaluating errors, clients MUST
     traverse through all of the nested "innerErrors" and choose the deepest one that they
     understand.
    :type inner_error: ~azure_machine_learning_workspaces.models.InnerErrorResponseautogenerated
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponseautogenerated'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        inner_error: Optional["InnerErrorResponseautogenerated"] = None,
        **kwargs
    ):
        super(InnerErrorResponseautogenerated, self).__init__(**kwargs)
        self.code = code
        self.inner_error = inner_error


class JobBaseInteractionEndpoints(msrest.serialization.Model):
    """Dictonary of endpoint URIs, keyed by enumerated job endpoints.

    :param tracking:
    :type tracking: str
    :param studio:
    :type studio: str
    :param grafana:
    :type grafana: str
    :param tensorboard:
    :type tensorboard: str
    """

    _attribute_map = {
        'tracking': {'key': 'Tracking', 'type': 'str'},
        'studio': {'key': 'Studio', 'type': 'str'},
        'grafana': {'key': 'Grafana', 'type': 'str'},
        'tensorboard': {'key': 'Tensorboard', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tracking: Optional[str] = None,
        studio: Optional[str] = None,
        grafana: Optional[str] = None,
        tensorboard: Optional[str] = None,
        **kwargs
    ):
        super(JobBaseInteractionEndpoints, self).__init__(**kwargs)
        self.tracking = tracking
        self.studio = studio
        self.grafana = grafana
        self.tensorboard = tensorboard


class JobBaseResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Additional attributes of the entity.
    :type properties: ~azure_machine_learning_workspaces.models.JobBase
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'JobBase'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "JobBase",
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(JobBaseResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class JobBaseResourceArmPaginatedResult(msrest.serialization.Model):
    """JobBaseResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.JobBaseResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[JobBaseResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["JobBaseResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(JobBaseResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class JobBaseResourceProperties(JobBase):
    """Additional attributes of the entity.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(JobBaseResourceProperties, self).__init__(description=description, tags=tags, properties=properties, **kwargs)
        self.job_type = 'JobBaseResource-properties'  # type: str


class JobOutput(msrest.serialization.Model):
    """JobOutput.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar datastore_id: ARM ID of the datastore where the job logs and artifacts are stored, or
     null for the default container ("azureml") in the workspace's storage account.
    :vartype datastore_id: str
    :ivar path: Path within the datastore to the job logs and artifacts.
    :vartype path: str
    """

    _validation = {
        'datastore_id': {'readonly': True},
        'path': {'readonly': True},
    }

    _attribute_map = {
        'datastore_id': {'key': 'datastoreId', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(JobOutput, self).__init__(**kwargs)
        self.datastore_id = None
        self.path = None


class KeyVaultProperties(msrest.serialization.Model):
    """KeyVaultProperties.

    All required parameters must be populated in order to send to Azure.

    :param key_vault_arm_id: Required. The ArmId of the keyVault where the customer owned
     encryption key is present.
    :type key_vault_arm_id: str
    :param key_identifier: Required. Key vault uri to access the encryption key.
    :type key_identifier: str
    :param identity_client_id: For future use - The client id of the identity which will be used to
     access key vault.
    :type identity_client_id: str
    """

    _validation = {
        'key_vault_arm_id': {'required': True},
        'key_identifier': {'required': True},
    }

    _attribute_map = {
        'key_vault_arm_id': {'key': 'keyVaultArmId', 'type': 'str'},
        'key_identifier': {'key': 'keyIdentifier', 'type': 'str'},
        'identity_client_id': {'key': 'identityClientId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_vault_arm_id: str,
        key_identifier: str,
        identity_client_id: Optional[str] = None,
        **kwargs
    ):
        super(KeyVaultProperties, self).__init__(**kwargs)
        self.key_vault_arm_id = key_vault_arm_id
        self.key_identifier = key_identifier
        self.identity_client_id = identity_client_id


class LabelCategory(msrest.serialization.Model):
    """Label category definition.

    :param display_name: Display name of the label category.
    :type display_name: str
    :param allow_multi_select: Indicates whether it is allowed to select multiple classes in this
     category.
    :type allow_multi_select: bool
    :param classes: Dictionary of label classes in this category.
    :type classes: dict[str, ~azure_machine_learning_workspaces.models.LabelClass]
    """

    _attribute_map = {
        'display_name': {'key': 'displayName', 'type': 'str'},
        'allow_multi_select': {'key': 'allowMultiSelect', 'type': 'bool'},
        'classes': {'key': 'classes', 'type': '{LabelClass}'},
    }

    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        allow_multi_select: Optional[bool] = None,
        classes: Optional[Dict[str, "LabelClass"]] = None,
        **kwargs
    ):
        super(LabelCategory, self).__init__(**kwargs)
        self.display_name = display_name
        self.allow_multi_select = allow_multi_select
        self.classes = classes


class LabelClass(msrest.serialization.Model):
    """Label class definition.

    :param display_name: Display name of the label class.
    :type display_name: str
    :param subclasses: Dictionary of subclasses of the label class.
    :type subclasses: dict[str, ~azure_machine_learning_workspaces.models.LabelClass]
    """

    _attribute_map = {
        'display_name': {'key': 'displayName', 'type': 'str'},
        'subclasses': {'key': 'subclasses', 'type': '{LabelClass}'},
    }

    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        subclasses: Optional[Dict[str, "LabelClass"]] = None,
        **kwargs
    ):
        super(LabelClass, self).__init__(**kwargs)
        self.display_name = display_name
        self.subclasses = subclasses


class LabelingDatasetConfiguration(msrest.serialization.Model):
    """Labeling dataset configuration definition.

    :param asset_name: Name of the data asset to perform labeling.
    :type asset_name: str
    :param incremental_dataset_refresh_enabled: Indicates whether to enable incremental dataset
     refresh.
    :type incremental_dataset_refresh_enabled: bool
    :param dataset_version: AML dataset version.
    :type dataset_version: str
    """

    _attribute_map = {
        'asset_name': {'key': 'assetName', 'type': 'str'},
        'incremental_dataset_refresh_enabled': {'key': 'incrementalDatasetRefreshEnabled', 'type': 'bool'},
        'dataset_version': {'key': 'datasetVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        asset_name: Optional[str] = None,
        incremental_dataset_refresh_enabled: Optional[bool] = None,
        dataset_version: Optional[str] = None,
        **kwargs
    ):
        super(LabelingDatasetConfiguration, self).__init__(**kwargs)
        self.asset_name = asset_name
        self.incremental_dataset_refresh_enabled = incremental_dataset_refresh_enabled
        self.dataset_version = dataset_version


class LabelingJob(JobBase):
    """Labeling job definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param label_categories: Label categories of the job.
    :type label_categories: dict[str, ~azure_machine_learning_workspaces.models.LabelCategory]
    :param job_instructions: Instructions for labeling job.
    :type job_instructions: ~azure_machine_learning_workspaces.models.LabelingJobInstructions
    :param dataset_configuration: Labeling dataset configuration definition.
    :type dataset_configuration:
     ~azure_machine_learning_workspaces.models.LabelingDatasetConfiguration
    :param ml_assist_configuration: Labeling MLAssist configuration definition.
    :type ml_assist_configuration: ~azure_machine_learning_workspaces.models.MlAssistConfiguration
    :param labeling_job_media_properties: Media type specific properties in the job.
    :type labeling_job_media_properties:
     ~azure_machine_learning_workspaces.models.LabelingJobMediaProperties
    :param project_id: Internal id of the job(Previously called project).
    :type project_id: str
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param progress_metrics: Progress metrics definition.
    :type progress_metrics: ~azure_machine_learning_workspaces.models.ProgressMetrics
    :param status_messages: Status messages of the job.
    :type status_messages: list[~azure_machine_learning_workspaces.models.StatusMessage]
    :param created_time_utc: Created time of the job in UTC timezone.
    :type created_time_utc: ~datetime.datetime
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'label_categories': {'key': 'labelCategories', 'type': '{LabelCategory}'},
        'job_instructions': {'key': 'jobInstructions', 'type': 'LabelingJobInstructions'},
        'dataset_configuration': {'key': 'datasetConfiguration', 'type': 'LabelingDatasetConfiguration'},
        'ml_assist_configuration': {'key': 'mlAssistConfiguration', 'type': 'MlAssistConfiguration'},
        'labeling_job_media_properties': {'key': 'labelingJobMediaProperties', 'type': 'LabelingJobMediaProperties'},
        'project_id': {'key': 'projectId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'progress_metrics': {'key': 'progressMetrics', 'type': 'ProgressMetrics'},
        'status_messages': {'key': 'statusMessages', 'type': '[StatusMessage]'},
        'created_time_utc': {'key': 'createdTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        label_categories: Optional[Dict[str, "LabelCategory"]] = None,
        job_instructions: Optional["LabelingJobInstructions"] = None,
        dataset_configuration: Optional["LabelingDatasetConfiguration"] = None,
        ml_assist_configuration: Optional["MlAssistConfiguration"] = None,
        labeling_job_media_properties: Optional["LabelingJobMediaProperties"] = None,
        project_id: Optional[str] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        progress_metrics: Optional["ProgressMetrics"] = None,
        status_messages: Optional[List["StatusMessage"]] = None,
        created_time_utc: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(LabelingJob, self).__init__(description=description, tags=tags, properties=properties, **kwargs)
        self.job_type = 'Labeling'  # type: str
        self.label_categories = label_categories
        self.job_instructions = job_instructions
        self.dataset_configuration = dataset_configuration
        self.ml_assist_configuration = ml_assist_configuration
        self.labeling_job_media_properties = labeling_job_media_properties
        self.project_id = project_id
        self.status = status
        self.progress_metrics = progress_metrics
        self.status_messages = status_messages
        self.created_time_utc = created_time_utc


class LabelingJobMediaProperties(msrest.serialization.Model):
    """Properties of a labeling job.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: LabelingJobImageProperties, LabelingJobMediaPropertiesautogenerated, LabelingJobTextProperties.

    All required parameters must be populated in order to send to Azure.

    :param media_type: Required. Media type of the job.Constant filled by server.  Possible values
     include: "Image", "Text".
    :type media_type: str or ~azure_machine_learning_workspaces.models.MediaType
    """

    _validation = {
        'media_type': {'required': True},
    }

    _attribute_map = {
        'media_type': {'key': 'mediaType', 'type': 'str'},
    }

    _subtype_map = {
        'media_type': {'Image': 'LabelingJobImageProperties', 'LabelingJob-labelingJobMediaProperties': 'LabelingJobMediaPropertiesautogenerated', 'Text': 'LabelingJobTextProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LabelingJobMediaProperties, self).__init__(**kwargs)
        self.media_type = None  # type: Optional[str]


class LabelingJobImageProperties(LabelingJobMediaProperties):
    """Properties of a labeling job for image data.

    All required parameters must be populated in order to send to Azure.

    :param media_type: Required. Media type of the job.Constant filled by server.  Possible values
     include: "Image", "Text".
    :type media_type: str or ~azure_machine_learning_workspaces.models.MediaType
    :param annotation_type: Annotation type of image labeling job. Possible values include:
     "Classification", "BoundingBox", "InstanceSegmentation".
    :type annotation_type: str or ~azure_machine_learning_workspaces.models.ImageAnnotationType
    """

    _validation = {
        'media_type': {'required': True},
    }

    _attribute_map = {
        'media_type': {'key': 'mediaType', 'type': 'str'},
        'annotation_type': {'key': 'annotationType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        annotation_type: Optional[Union[str, "ImageAnnotationType"]] = None,
        **kwargs
    ):
        super(LabelingJobImageProperties, self).__init__(**kwargs)
        self.media_type = 'Image'  # type: str
        self.annotation_type = annotation_type


class LabelingJobInstructions(msrest.serialization.Model):
    """Instructions for labeling job.

    :param uri: The link to a page with detailed labeling instructions for labelers.
    :type uri: str
    """

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        uri: Optional[str] = None,
        **kwargs
    ):
        super(LabelingJobInstructions, self).__init__(**kwargs)
        self.uri = uri


class LabelingJobMediaPropertiesautogenerated(LabelingJobMediaProperties):
    """Media type specific properties in the job.

    All required parameters must be populated in order to send to Azure.

    :param media_type: Required. Media type of the job.Constant filled by server.  Possible values
     include: "Image", "Text".
    :type media_type: str or ~azure_machine_learning_workspaces.models.MediaType
    """

    _validation = {
        'media_type': {'required': True},
    }

    _attribute_map = {
        'media_type': {'key': 'mediaType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LabelingJobMediaPropertiesautogenerated, self).__init__(**kwargs)
        self.media_type = 'LabelingJob-labelingJobMediaProperties'  # type: str


class LabelingJobResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param label_categories: Label categories of the job.
    :type label_categories: dict[str, ~azure_machine_learning_workspaces.models.LabelCategory]
    :param job_instructions: Instructions for labeling job.
    :type job_instructions: ~azure_machine_learning_workspaces.models.LabelingJobInstructions
    :param dataset_configuration: Labeling dataset configuration definition.
    :type dataset_configuration:
     ~azure_machine_learning_workspaces.models.LabelingDatasetConfiguration
    :param ml_assist_configuration: Labeling MLAssist configuration definition.
    :type ml_assist_configuration: ~azure_machine_learning_workspaces.models.MlAssistConfiguration
    :param labeling_job_media_properties: Media type specific properties in the job.
    :type labeling_job_media_properties:
     ~azure_machine_learning_workspaces.models.LabelingJobMediaProperties
    :param project_id: Internal id of the job(Previously called project).
    :type project_id: str
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param progress_metrics: Progress metrics definition.
    :type progress_metrics: ~azure_machine_learning_workspaces.models.ProgressMetrics
    :param status_messages: Status messages of the job.
    :type status_messages: list[~azure_machine_learning_workspaces.models.StatusMessage]
    :param created_time_utc: Created time of the job in UTC timezone.
    :type created_time_utc: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'job_type': {'key': 'properties.jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'properties.interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
        'label_categories': {'key': 'properties.labelCategories', 'type': '{LabelCategory}'},
        'job_instructions': {'key': 'properties.jobInstructions', 'type': 'LabelingJobInstructions'},
        'dataset_configuration': {'key': 'properties.datasetConfiguration', 'type': 'LabelingDatasetConfiguration'},
        'ml_assist_configuration': {'key': 'properties.mlAssistConfiguration', 'type': 'MlAssistConfiguration'},
        'labeling_job_media_properties': {'key': 'properties.labelingJobMediaProperties', 'type': 'LabelingJobMediaProperties'},
        'project_id': {'key': 'properties.projectId', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'progress_metrics': {'key': 'properties.progressMetrics', 'type': 'ProgressMetrics'},
        'status_messages': {'key': 'properties.statusMessages', 'type': '[StatusMessage]'},
        'created_time_utc': {'key': 'properties.createdTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        label_categories: Optional[Dict[str, "LabelCategory"]] = None,
        job_instructions: Optional["LabelingJobInstructions"] = None,
        dataset_configuration: Optional["LabelingDatasetConfiguration"] = None,
        ml_assist_configuration: Optional["MlAssistConfiguration"] = None,
        labeling_job_media_properties: Optional["LabelingJobMediaProperties"] = None,
        project_id: Optional[str] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        progress_metrics: Optional["ProgressMetrics"] = None,
        status_messages: Optional[List["StatusMessage"]] = None,
        created_time_utc: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(LabelingJobResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.job_type = None  # type: Optional[str]
        self.interaction_endpoints = None
        self.description = description
        self.tags = tags
        self.properties = properties
        self.label_categories = label_categories
        self.job_instructions = job_instructions
        self.dataset_configuration = dataset_configuration
        self.ml_assist_configuration = ml_assist_configuration
        self.labeling_job_media_properties = labeling_job_media_properties
        self.project_id = project_id
        self.status = status
        self.progress_metrics = progress_metrics
        self.status_messages = status_messages
        self.created_time_utc = created_time_utc


class LabelingJobResourceArmPaginatedResult(msrest.serialization.Model):
    """LabelingJobResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.LabelingJobResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LabelingJobResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["LabelingJobResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(LabelingJobResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class LabelingJobTextProperties(LabelingJobMediaProperties):
    """Properties of a labeling job for text data.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param media_type: Required. Media type of the job.Constant filled by server.  Possible values
     include: "Image", "Text".
    :type media_type: str or ~azure_machine_learning_workspaces.models.MediaType
    :ivar annotation_type: Annotation type of text labeling job. Default value: "Classification".
    :vartype annotation_type: str
    """

    _validation = {
        'media_type': {'required': True},
        'annotation_type': {'constant': True},
    }

    _attribute_map = {
        'media_type': {'key': 'mediaType', 'type': 'str'},
        'annotation_type': {'key': 'annotationType', 'type': 'str'},
    }

    annotation_type = "Classification"

    def __init__(
        self,
        **kwargs
    ):
        super(LabelingJobTextProperties, self).__init__(**kwargs)
        self.media_type = 'Text'  # type: str


class LinkedInfo(msrest.serialization.Model):
    """LinkedInfo.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param linked_id: Linked service ID.
    :type linked_id: str
    :param linked_resource_name: Linked service resource name.
    :type linked_resource_name: str
    :ivar origin: Type of the linked service. Default value: "Synapse".
    :vartype origin: str
    """

    _validation = {
        'origin': {'constant': True},
    }

    _attribute_map = {
        'linked_id': {'key': 'linkedId', 'type': 'str'},
        'linked_resource_name': {'key': 'linkedResourceName', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
    }

    origin = "Synapse"

    def __init__(
        self,
        *,
        linked_id: Optional[str] = None,
        linked_resource_name: Optional[str] = None,
        **kwargs
    ):
        super(LinkedInfo, self).__init__(**kwargs)
        self.linked_id = linked_id
        self.linked_resource_name = linked_resource_name


class LinkedWorkspace(msrest.serialization.Model):
    """Linked workspace.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: ResourceId of the link of the linked workspace.
    :vartype id: str
    :ivar name: Friendly name of the linked workspace.
    :vartype name: str
    :ivar type: Resource type of linked workspace.
    :vartype type: str
    :param properties: LinkedWorkspace specific properties.
    :type properties: ~azure_machine_learning_workspaces.models.LinkedWorkspaceProps
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'LinkedWorkspaceProps'},
    }

    def __init__(
        self,
        *,
        properties: Optional["LinkedWorkspaceProps"] = None,
        **kwargs
    ):
        super(LinkedWorkspace, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties


class LinkedWorkspaceDto(msrest.serialization.Model):
    """object used for creating linked workspace.

    :param name: Friendly name of the linked workspace.
    :type name: str
    :param properties: LinkedWorkspace specific properties.
    :type properties: ~azure_machine_learning_workspaces.models.LinkedWorkspaceProps
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'LinkedWorkspaceProps'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        properties: Optional["LinkedWorkspaceProps"] = None,
        **kwargs
    ):
        super(LinkedWorkspaceDto, self).__init__(**kwargs)
        self.name = name
        self.properties = properties


class LinkedWorkspaceProps(msrest.serialization.Model):
    """LinkedWorkspace specific properties.

    :param linked_workspace_resource_id: ResourceId of the link target of the linked workspace.
    :type linked_workspace_resource_id: str
    :param user_assigned_identity_resource_id: ResourceId of the user assigned identity for the
     linked workspace.
    :type user_assigned_identity_resource_id: str
    """

    _attribute_map = {
        'linked_workspace_resource_id': {'key': 'linkedWorkspaceResourceId', 'type': 'str'},
        'user_assigned_identity_resource_id': {'key': 'userAssignedIdentityResourceId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        linked_workspace_resource_id: Optional[str] = None,
        user_assigned_identity_resource_id: Optional[str] = None,
        **kwargs
    ):
        super(LinkedWorkspaceProps, self).__init__(**kwargs)
        self.linked_workspace_resource_id = linked_workspace_resource_id
        self.user_assigned_identity_resource_id = user_assigned_identity_resource_id


class ListAmlUserFeatureResult(msrest.serialization.Model):
    """The List Aml user feature operation response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The list of AML user facing features.
    :vartype value: list[~azure_machine_learning_workspaces.models.AmlUserFeature]
    :ivar next_link: The URI to fetch the next page of AML user features information. Call
     ListNext() with this to fetch the next page of AML user features information.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[AmlUserFeature]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListAmlUserFeatureResult, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class ListUsagesResult(msrest.serialization.Model):
    """The List Usages operation response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The list of AML resource usages.
    :vartype value: list[~azure_machine_learning_workspaces.models.Usage]
    :ivar next_link: The URI to fetch the next page of AML resource usage information. Call
     ListNext() with this to fetch the next page of AML resource usage information.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Usage]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListUsagesResult, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class ListWorkspaceKeysResult(msrest.serialization.Model):
    """ListWorkspaceKeysResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar user_storage_key:
    :vartype user_storage_key: str
    :ivar user_storage_resource_id:
    :vartype user_storage_resource_id: str
    :ivar app_insights_instrumentation_key:
    :vartype app_insights_instrumentation_key: str
    :ivar container_registry_credentials:
    :vartype container_registry_credentials:
     ~azure_machine_learning_workspaces.models.RegistryListCredentialsResult
    """

    _validation = {
        'user_storage_key': {'readonly': True},
        'user_storage_resource_id': {'readonly': True},
        'app_insights_instrumentation_key': {'readonly': True},
        'container_registry_credentials': {'readonly': True},
    }

    _attribute_map = {
        'user_storage_key': {'key': 'userStorageKey', 'type': 'str'},
        'user_storage_resource_id': {'key': 'userStorageResourceId', 'type': 'str'},
        'app_insights_instrumentation_key': {'key': 'appInsightsInstrumentationKey', 'type': 'str'},
        'container_registry_credentials': {'key': 'containerRegistryCredentials', 'type': 'RegistryListCredentialsResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListWorkspaceKeysResult, self).__init__(**kwargs)
        self.user_storage_key = None
        self.user_storage_resource_id = None
        self.app_insights_instrumentation_key = None
        self.container_registry_credentials = None


class ListWorkspaceQuotas(msrest.serialization.Model):
    """The List WorkspaceQuotasByVMFamily operation response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The list of Workspace Quotas by VM Family.
    :vartype value: list[~azure_machine_learning_workspaces.models.ResourceQuota]
    :ivar next_link: The URI to fetch the next page of workspace quota information by VM Family.
     Call ListNext() with this to fetch the next page of Workspace Quota information.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ResourceQuota]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListWorkspaceQuotas, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class MachineLearningServiceError(msrest.serialization.Model):
    """Wrapper for error response to follow ARM guidelines.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar error: The error response.
    :vartype error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated2
    """

    _validation = {
        'error': {'readonly': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated2'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MachineLearningServiceError, self).__init__(**kwargs)
        self.error = None


class MedianStoppingPolicyConfiguration(EarlyTerminationPolicyConfiguration):
    """Defines an early termination policy based on running averages of the primary metric of all runs.

    All required parameters must be populated in order to send to Azure.

    :param policy_type: Required. Name of policy configuration.Constant filled by server.  Possible
     values include: "Bandit", "MedianStopping", "TruncationSelection".
    :type policy_type: str or ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyType
    :param evaluation_interval:
    :type evaluation_interval: int
    :param delay_evaluation:
    :type delay_evaluation: int
    """

    _validation = {
        'policy_type': {'required': True},
    }

    _attribute_map = {
        'policy_type': {'key': 'policyType', 'type': 'str'},
        'evaluation_interval': {'key': 'evaluationInterval', 'type': 'int'},
        'delay_evaluation': {'key': 'delayEvaluation', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        evaluation_interval: Optional[int] = None,
        delay_evaluation: Optional[int] = None,
        **kwargs
    ):
        super(MedianStoppingPolicyConfiguration, self).__init__(evaluation_interval=evaluation_interval, delay_evaluation=delay_evaluation, **kwargs)
        self.policy_type = 'MedianStopping'  # type: str


class MetaApiVersionResponse(msrest.serialization.Model):
    """MetaApiVersionResponse.

    :param name:
    :type name: str
    :param version:
    :type version: str
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        version: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(MetaApiVersionResponse, self).__init__(**kwargs)
        self.name = name
        self.version = version
        self.properties = properties


class MetricDto(msrest.serialization.Model):
    """MetricDto.

    :param metric_id:
    :type metric_id: str
    :param metric_type:
    :type metric_type: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param name:
    :type name: str
    :param description:
    :type description: str
    :param label:
    :type label: str
    :param num_cells:
    :type num_cells: int
    :param data_location:
    :type data_location: str
    :param cells:
    :type cells: list[dict[str, object]]
    :param num_properties:
    :type num_properties: int
    :param properties:
    :type properties: list[~azure_machine_learning_workspaces.models.MetricSchemaPropertyDto]
    """

    _attribute_map = {
        'metric_id': {'key': 'metricId', 'type': 'str'},
        'metric_type': {'key': 'metricType', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
        'num_cells': {'key': 'numCells', 'type': 'int'},
        'data_location': {'key': 'dataLocation', 'type': 'str'},
        'cells': {'key': 'cells', 'type': '[{object}]'},
        'num_properties': {'key': 'schema.numProperties', 'type': 'int'},
        'properties': {'key': 'schema.properties', 'type': '[MetricSchemaPropertyDto]'},
    }

    def __init__(
        self,
        *,
        metric_id: Optional[str] = None,
        metric_type: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        label: Optional[str] = None,
        num_cells: Optional[int] = None,
        data_location: Optional[str] = None,
        cells: Optional[List[Dict[str, object]]] = None,
        num_properties: Optional[int] = None,
        properties: Optional[List["MetricSchemaPropertyDto"]] = None,
        **kwargs
    ):
        super(MetricDto, self).__init__(**kwargs)
        self.metric_id = metric_id
        self.metric_type = metric_type
        self.created_utc = created_utc
        self.name = name
        self.description = description
        self.label = label
        self.num_cells = num_cells
        self.data_location = data_location
        self.cells = cells
        self.num_properties = num_properties
        self.properties = properties


class MetricSchemaDto(msrest.serialization.Model):
    """MetricSchemaDto.

    :param num_properties:
    :type num_properties: int
    :param properties:
    :type properties: list[~azure_machine_learning_workspaces.models.MetricSchemaPropertyDto]
    """

    _attribute_map = {
        'num_properties': {'key': 'numProperties', 'type': 'int'},
        'properties': {'key': 'properties', 'type': '[MetricSchemaPropertyDto]'},
    }

    def __init__(
        self,
        *,
        num_properties: Optional[int] = None,
        properties: Optional[List["MetricSchemaPropertyDto"]] = None,
        **kwargs
    ):
        super(MetricSchemaDto, self).__init__(**kwargs)
        self.num_properties = num_properties
        self.properties = properties


class MetricSchemaPropertyDto(msrest.serialization.Model):
    """MetricSchemaPropertyDto.

    :param property_id:
    :type property_id: str
    :param name:
    :type name: str
    :param type:
    :type type: str
    """

    _attribute_map = {
        'property_id': {'key': 'propertyId', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        property_id: Optional[str] = None,
        name: Optional[str] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        super(MetricSchemaPropertyDto, self).__init__(**kwargs)
        self.property_id = property_id
        self.name = name
        self.type = type


class MirComputeConfiguration(ComputeConfiguration):
    """MirComputeConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MirComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = 'AMLCompute'  # type: str


class MlAssistConfiguration(msrest.serialization.Model):
    """Labeling MLAssist configuration definition.

    :param inferencing_compute_binding: Compute binding definition.
    :type inferencing_compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param training_compute_binding: Compute binding definition.
    :type training_compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param ml_assist_enabled: Indicates whether MLAssist feature is enabled.
    :type ml_assist_enabled: bool
    """

    _attribute_map = {
        'inferencing_compute_binding': {'key': 'inferencingComputeBinding', 'type': 'ComputeBinding'},
        'training_compute_binding': {'key': 'trainingComputeBinding', 'type': 'ComputeBinding'},
        'ml_assist_enabled': {'key': 'mlAssistEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        inferencing_compute_binding: Optional["ComputeBinding"] = None,
        training_compute_binding: Optional["ComputeBinding"] = None,
        ml_assist_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(MlAssistConfiguration, self).__init__(**kwargs)
        self.inferencing_compute_binding = inferencing_compute_binding
        self.training_compute_binding = training_compute_binding
        self.ml_assist_enabled = ml_assist_enabled


class Model(msrest.serialization.Model):
    """An Azure Machine Learning Model.

    All required parameters must be populated in order to send to Azure.

    :param id: The Model Id.
    :type id: str
    :param name: Required. The Model name.
    :type name: str
    :param framework: The Model framework.
    :type framework: str
    :param framework_version: The Model framework version.
    :type framework_version: str
    :param version: The Model version assigned by Model Management Service.
    :type version: long
    :param datasets: The list of datasets associated with the model.
    :type datasets: list[~azure_machine_learning_workspaces.models.DatasetReference]
    :param url: Required. The URL of the Model. Usually a SAS URL.
    :type url: str
    :param mime_type: Required. The MIME type of Model content. For more details about MIME type,
     please open https://www.iana.org/assignments/media-types/media-types.xhtml.
    :type mime_type: str
    :param description: The Model description text.
    :type description: str
    :param created_time: The Model creation time (UTC).
    :type created_time: ~datetime.datetime
    :param modified_time: The Model last modified time (UTC).
    :type modified_time: ~datetime.datetime
    :param unpack: Indicates whether we need to unpack the Model during docker Image creation.
    :type unpack: bool
    :param parent_model_id: The Parent Model Id.
    :type parent_model_id: str
    :param run_id: The RunId that created this model.
    :type run_id: str
    :param experiment_name: The name of the experiment where this model was created.
    :type experiment_name: str
    :param kv_tags: The Model tag dictionary. Items are mutable.
    :type kv_tags: dict[str, str]
    :param properties: The Model property dictionary. Properties are immutable.
    :type properties: dict[str, str]
    :param derived_model_ids: Models derived from this model.
    :type derived_model_ids: list[str]
    :param sample_input_data: Sample Input Data for the Model. A reference to a dataset in the
     workspace in the format aml://dataset/{datasetId}.
    :type sample_input_data: str
    :param sample_output_data: Sample Output Data for the Model. A reference to a dataset in the
     workspace in the format aml://dataset/{datasetId}.
    :type sample_output_data: str
    :param resource_requirements: Resource requirements for the model.
    :type resource_requirements:
     ~azure_machine_learning_workspaces.models.ContainerResourceRequirements
    """

    _validation = {
        'name': {'required': True},
        'url': {'required': True},
        'mime_type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'framework': {'key': 'framework', 'type': 'str'},
        'framework_version': {'key': 'frameworkVersion', 'type': 'str'},
        'version': {'key': 'version', 'type': 'long'},
        'datasets': {'key': 'datasets', 'type': '[DatasetReference]'},
        'url': {'key': 'url', 'type': 'str'},
        'mime_type': {'key': 'mimeType', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_time': {'key': 'createdTime', 'type': 'iso-8601'},
        'modified_time': {'key': 'modifiedTime', 'type': 'iso-8601'},
        'unpack': {'key': 'unpack', 'type': 'bool'},
        'parent_model_id': {'key': 'parentModelId', 'type': 'str'},
        'run_id': {'key': 'runId', 'type': 'str'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'kv_tags': {'key': 'kvTags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'derived_model_ids': {'key': 'derivedModelIds', 'type': '[str]'},
        'sample_input_data': {'key': 'sampleInputData', 'type': 'str'},
        'sample_output_data': {'key': 'sampleOutputData', 'type': 'str'},
        'resource_requirements': {'key': 'resourceRequirements', 'type': 'ContainerResourceRequirements'},
    }

    def __init__(
        self,
        *,
        name: str,
        url: str,
        mime_type: str,
        id: Optional[str] = None,
        framework: Optional[str] = None,
        framework_version: Optional[str] = None,
        version: Optional[int] = None,
        datasets: Optional[List["DatasetReference"]] = None,
        description: Optional[str] = None,
        created_time: Optional[datetime.datetime] = None,
        modified_time: Optional[datetime.datetime] = None,
        unpack: Optional[bool] = None,
        parent_model_id: Optional[str] = None,
        run_id: Optional[str] = None,
        experiment_name: Optional[str] = None,
        kv_tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        derived_model_ids: Optional[List[str]] = None,
        sample_input_data: Optional[str] = None,
        sample_output_data: Optional[str] = None,
        resource_requirements: Optional["ContainerResourceRequirements"] = None,
        **kwargs
    ):
        super(Model, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.framework = framework
        self.framework_version = framework_version
        self.version = version
        self.datasets = datasets
        self.url = url
        self.mime_type = mime_type
        self.description = description
        self.created_time = created_time
        self.modified_time = modified_time
        self.unpack = unpack
        self.parent_model_id = parent_model_id
        self.run_id = run_id
        self.experiment_name = experiment_name
        self.kv_tags = kv_tags
        self.properties = properties
        self.derived_model_ids = derived_model_ids
        self.sample_input_data = sample_input_data
        self.sample_output_data = sample_output_data
        self.resource_requirements = resource_requirements


class ModelContainerResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param latest_versions: Latest model versions for each stage.
    :type latest_versions: list[~azure_machine_learning_workspaces.models.ModelVersionResource]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'latest_versions': {'key': 'properties.latestVersions', 'type': '[ModelVersionResource]'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        latest_versions: Optional[List["ModelVersionResource"]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ModelContainerResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.latest_versions = latest_versions
        self.description = description
        self.tags = tags
        self.properties = properties


class ModelContainerResourceArmPaginatedResult(msrest.serialization.Model):
    """ModelContainerResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.ModelContainerResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ModelContainerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ModelContainerResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(ModelContainerResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ModelDockerSection(msrest.serialization.Model):
    """ModelDockerSection.

    :param base_image: Base image used for Docker-based runs. Mutually exclusive with
     BaseDockerfile.
    :type base_image: str
    :param base_dockerfile: Base Dockerfile used for Docker-based runs. Mutually exclusive with
     BaseImage.
    :type base_dockerfile: str
    :param base_image_registry: Image registry that contains the base image.
    :type base_image_registry: ~azure_machine_learning_workspaces.models.ContainerRegistry
    """

    _attribute_map = {
        'base_image': {'key': 'baseImage', 'type': 'str'},
        'base_dockerfile': {'key': 'baseDockerfile', 'type': 'str'},
        'base_image_registry': {'key': 'baseImageRegistry', 'type': 'ContainerRegistry'},
    }

    def __init__(
        self,
        *,
        base_image: Optional[str] = None,
        base_dockerfile: Optional[str] = None,
        base_image_registry: Optional["ContainerRegistry"] = None,
        **kwargs
    ):
        super(ModelDockerSection, self).__init__(**kwargs)
        self.base_image = base_image
        self.base_dockerfile = base_dockerfile
        self.base_image_registry = base_image_registry


class ModelDockerSectionBaseImageRegistry(ContainerRegistry):
    """Image registry that contains the base image.

    :param address:
    :type address: str
    :param username:
    :type username: str
    :param password:
    :type password: str
    """

    _attribute_map = {
        'address': {'key': 'address', 'type': 'str'},
        'username': {'key': 'username', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional[str] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs
    ):
        super(ModelDockerSectionBaseImageRegistry, self).__init__(address=address, username=username, password=password, **kwargs)


class ModelDockerSectionResponse(msrest.serialization.Model):
    """ModelDockerSectionResponse.

    :param base_image: Base image used for Docker-based runs. Mutually exclusive with
     BaseDockerfile.
    :type base_image: str
    :param base_dockerfile: Base Dockerfile used for Docker-based runs. Mutually exclusive with
     BaseImage.
    :type base_dockerfile: str
    :param base_image_registry: Image registry that contains the base image.
    :type base_image_registry: ~azure_machine_learning_workspaces.models.ContainerRegistryResponse
    """

    _attribute_map = {
        'base_image': {'key': 'baseImage', 'type': 'str'},
        'base_dockerfile': {'key': 'baseDockerfile', 'type': 'str'},
        'base_image_registry': {'key': 'baseImageRegistry', 'type': 'ContainerRegistryResponse'},
    }

    def __init__(
        self,
        *,
        base_image: Optional[str] = None,
        base_dockerfile: Optional[str] = None,
        base_image_registry: Optional["ContainerRegistryResponse"] = None,
        **kwargs
    ):
        super(ModelDockerSectionResponse, self).__init__(**kwargs)
        self.base_image = base_image
        self.base_dockerfile = base_dockerfile
        self.base_image_registry = base_image_registry


class ModelDockerSectionResponseBaseImageRegistry(ContainerRegistryResponse):
    """Image registry that contains the base image.

    :param address:
    :type address: str
    """

    _attribute_map = {
        'address': {'key': 'address', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address: Optional[str] = None,
        **kwargs
    ):
        super(ModelDockerSectionResponseBaseImageRegistry, self).__init__(address=address, **kwargs)


class ModelEnvironmentDefinitionDocker(ModelDockerSection):
    """The definition of a Docker container.

    :param base_image: Base image used for Docker-based runs. Mutually exclusive with
     BaseDockerfile.
    :type base_image: str
    :param base_dockerfile: Base Dockerfile used for Docker-based runs. Mutually exclusive with
     BaseImage.
    :type base_dockerfile: str
    :param base_image_registry: Image registry that contains the base image.
    :type base_image_registry: ~azure_machine_learning_workspaces.models.ContainerRegistry
    """

    _attribute_map = {
        'base_image': {'key': 'baseImage', 'type': 'str'},
        'base_dockerfile': {'key': 'baseDockerfile', 'type': 'str'},
        'base_image_registry': {'key': 'baseImageRegistry', 'type': 'ContainerRegistry'},
    }

    def __init__(
        self,
        *,
        base_image: Optional[str] = None,
        base_dockerfile: Optional[str] = None,
        base_image_registry: Optional["ContainerRegistry"] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionDocker, self).__init__(base_image=base_image, base_dockerfile=base_dockerfile, base_image_registry=base_image_registry, **kwargs)


class ModelPythonSection(msrest.serialization.Model):
    """ModelPythonSection.

    :param interpreter_path: The python interpreter path to use if an environment build is not
     required. The path specified gets used to call the user script.
    :type interpreter_path: str
    :param user_managed_dependencies: True means that AzureML reuses an existing python
     environment; False means that AzureML will create a python environment based on the Conda
     dependencies specification.
    :type user_managed_dependencies: bool
    :param conda_dependencies: A JObject containing Conda dependencies.
    :type conda_dependencies: object
    :param base_conda_environment:
    :type base_conda_environment: str
    """

    _attribute_map = {
        'interpreter_path': {'key': 'interpreterPath', 'type': 'str'},
        'user_managed_dependencies': {'key': 'userManagedDependencies', 'type': 'bool'},
        'conda_dependencies': {'key': 'condaDependencies', 'type': 'object'},
        'base_conda_environment': {'key': 'baseCondaEnvironment', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        interpreter_path: Optional[str] = None,
        user_managed_dependencies: Optional[bool] = None,
        conda_dependencies: Optional[object] = None,
        base_conda_environment: Optional[str] = None,
        **kwargs
    ):
        super(ModelPythonSection, self).__init__(**kwargs)
        self.interpreter_path = interpreter_path
        self.user_managed_dependencies = user_managed_dependencies
        self.conda_dependencies = conda_dependencies
        self.base_conda_environment = base_conda_environment


class ModelEnvironmentDefinitionPython(ModelPythonSection):
    """Settings for a Python environment.

    :param interpreter_path: The python interpreter path to use if an environment build is not
     required. The path specified gets used to call the user script.
    :type interpreter_path: str
    :param user_managed_dependencies: True means that AzureML reuses an existing python
     environment; False means that AzureML will create a python environment based on the Conda
     dependencies specification.
    :type user_managed_dependencies: bool
    :param conda_dependencies: A JObject containing Conda dependencies.
    :type conda_dependencies: object
    :param base_conda_environment:
    :type base_conda_environment: str
    """

    _attribute_map = {
        'interpreter_path': {'key': 'interpreterPath', 'type': 'str'},
        'user_managed_dependencies': {'key': 'userManagedDependencies', 'type': 'bool'},
        'conda_dependencies': {'key': 'condaDependencies', 'type': 'object'},
        'base_conda_environment': {'key': 'baseCondaEnvironment', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        interpreter_path: Optional[str] = None,
        user_managed_dependencies: Optional[bool] = None,
        conda_dependencies: Optional[object] = None,
        base_conda_environment: Optional[str] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionPython, self).__init__(interpreter_path=interpreter_path, user_managed_dependencies=user_managed_dependencies, conda_dependencies=conda_dependencies, base_conda_environment=base_conda_environment, **kwargs)


class RSection(msrest.serialization.Model):
    """RSection.

    :param r_version: The version of R to be installed.
    :type r_version: str
    :param user_managed: Indicates whether the environment is managed by user or by AzureML.
    :type user_managed: bool
    :param rscript_path: The Rscript path to use if an environment build is not required.
     The path specified gets used to call the user script.
    :type rscript_path: str
    :param snapshot_date: Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17".
    :type snapshot_date: str
    :param cran_packages: The CRAN packages to use.
    :type cran_packages: list[~azure_machine_learning_workspaces.models.RCranPackage]
    :param git_hub_packages: The packages directly from GitHub.
    :type git_hub_packages: list[~azure_machine_learning_workspaces.models.RGitHubPackage]
    :param custom_url_packages: The packages from custom urls.
    :type custom_url_packages: list[str]
    :param bio_conductor_packages: The packages from Bioconductor.
    :type bio_conductor_packages: list[str]
    """

    _attribute_map = {
        'r_version': {'key': 'rVersion', 'type': 'str'},
        'user_managed': {'key': 'userManaged', 'type': 'bool'},
        'rscript_path': {'key': 'rscriptPath', 'type': 'str'},
        'snapshot_date': {'key': 'snapshotDate', 'type': 'str'},
        'cran_packages': {'key': 'cranPackages', 'type': '[RCranPackage]'},
        'git_hub_packages': {'key': 'gitHubPackages', 'type': '[RGitHubPackage]'},
        'custom_url_packages': {'key': 'customUrlPackages', 'type': '[str]'},
        'bio_conductor_packages': {'key': 'bioConductorPackages', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        r_version: Optional[str] = None,
        user_managed: Optional[bool] = None,
        rscript_path: Optional[str] = None,
        snapshot_date: Optional[str] = None,
        cran_packages: Optional[List["RCranPackage"]] = None,
        git_hub_packages: Optional[List["RGitHubPackage"]] = None,
        custom_url_packages: Optional[List[str]] = None,
        bio_conductor_packages: Optional[List[str]] = None,
        **kwargs
    ):
        super(RSection, self).__init__(**kwargs)
        self.r_version = r_version
        self.user_managed = user_managed
        self.rscript_path = rscript_path
        self.snapshot_date = snapshot_date
        self.cran_packages = cran_packages
        self.git_hub_packages = git_hub_packages
        self.custom_url_packages = custom_url_packages
        self.bio_conductor_packages = bio_conductor_packages


class ModelEnvironmentDefinitionR(RSection):
    """Settings for a R environment.

    :param r_version: The version of R to be installed.
    :type r_version: str
    :param user_managed: Indicates whether the environment is managed by user or by AzureML.
    :type user_managed: bool
    :param rscript_path: The Rscript path to use if an environment build is not required.
     The path specified gets used to call the user script.
    :type rscript_path: str
    :param snapshot_date: Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17".
    :type snapshot_date: str
    :param cran_packages: The CRAN packages to use.
    :type cran_packages: list[~azure_machine_learning_workspaces.models.RCranPackage]
    :param git_hub_packages: The packages directly from GitHub.
    :type git_hub_packages: list[~azure_machine_learning_workspaces.models.RGitHubPackage]
    :param custom_url_packages: The packages from custom urls.
    :type custom_url_packages: list[str]
    :param bio_conductor_packages: The packages from Bioconductor.
    :type bio_conductor_packages: list[str]
    """

    _attribute_map = {
        'r_version': {'key': 'rVersion', 'type': 'str'},
        'user_managed': {'key': 'userManaged', 'type': 'bool'},
        'rscript_path': {'key': 'rscriptPath', 'type': 'str'},
        'snapshot_date': {'key': 'snapshotDate', 'type': 'str'},
        'cran_packages': {'key': 'cranPackages', 'type': '[RCranPackage]'},
        'git_hub_packages': {'key': 'gitHubPackages', 'type': '[RGitHubPackage]'},
        'custom_url_packages': {'key': 'customUrlPackages', 'type': '[str]'},
        'bio_conductor_packages': {'key': 'bioConductorPackages', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        r_version: Optional[str] = None,
        user_managed: Optional[bool] = None,
        rscript_path: Optional[str] = None,
        snapshot_date: Optional[str] = None,
        cran_packages: Optional[List["RCranPackage"]] = None,
        git_hub_packages: Optional[List["RGitHubPackage"]] = None,
        custom_url_packages: Optional[List[str]] = None,
        bio_conductor_packages: Optional[List[str]] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionR, self).__init__(r_version=r_version, user_managed=user_managed, rscript_path=rscript_path, snapshot_date=snapshot_date, cran_packages=cran_packages, git_hub_packages=git_hub_packages, custom_url_packages=custom_url_packages, bio_conductor_packages=bio_conductor_packages, **kwargs)


class ModelEnvironmentDefinitionResponseDocker(ModelDockerSectionResponse):
    """The definition of a Docker container.

    :param base_image: Base image used for Docker-based runs. Mutually exclusive with
     BaseDockerfile.
    :type base_image: str
    :param base_dockerfile: Base Dockerfile used for Docker-based runs. Mutually exclusive with
     BaseImage.
    :type base_dockerfile: str
    :param base_image_registry: Image registry that contains the base image.
    :type base_image_registry: ~azure_machine_learning_workspaces.models.ContainerRegistryResponse
    """

    _attribute_map = {
        'base_image': {'key': 'baseImage', 'type': 'str'},
        'base_dockerfile': {'key': 'baseDockerfile', 'type': 'str'},
        'base_image_registry': {'key': 'baseImageRegistry', 'type': 'ContainerRegistryResponse'},
    }

    def __init__(
        self,
        *,
        base_image: Optional[str] = None,
        base_dockerfile: Optional[str] = None,
        base_image_registry: Optional["ContainerRegistryResponse"] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionResponseDocker, self).__init__(base_image=base_image, base_dockerfile=base_dockerfile, base_image_registry=base_image_registry, **kwargs)


class ModelEnvironmentDefinitionResponsePython(ModelPythonSection):
    """Settings for a Python environment.

    :param interpreter_path: The python interpreter path to use if an environment build is not
     required. The path specified gets used to call the user script.
    :type interpreter_path: str
    :param user_managed_dependencies: True means that AzureML reuses an existing python
     environment; False means that AzureML will create a python environment based on the Conda
     dependencies specification.
    :type user_managed_dependencies: bool
    :param conda_dependencies: A JObject containing Conda dependencies.
    :type conda_dependencies: object
    :param base_conda_environment:
    :type base_conda_environment: str
    """

    _attribute_map = {
        'interpreter_path': {'key': 'interpreterPath', 'type': 'str'},
        'user_managed_dependencies': {'key': 'userManagedDependencies', 'type': 'bool'},
        'conda_dependencies': {'key': 'condaDependencies', 'type': 'object'},
        'base_conda_environment': {'key': 'baseCondaEnvironment', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        interpreter_path: Optional[str] = None,
        user_managed_dependencies: Optional[bool] = None,
        conda_dependencies: Optional[object] = None,
        base_conda_environment: Optional[str] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionResponsePython, self).__init__(interpreter_path=interpreter_path, user_managed_dependencies=user_managed_dependencies, conda_dependencies=conda_dependencies, base_conda_environment=base_conda_environment, **kwargs)


class RSectionResponse(msrest.serialization.Model):
    """RSectionResponse.

    :param r_version: The version of R to be installed.
    :type r_version: str
    :param user_managed: Indicates whether the environment is managed by user or by AzureML.
    :type user_managed: bool
    :param rscript_path: The Rscript path to use if an environment build is not required.
     The path specified gets used to call the user script.
    :type rscript_path: str
    :param snapshot_date: Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17".
    :type snapshot_date: str
    :param cran_packages: The CRAN packages to use.
    :type cran_packages: list[~azure_machine_learning_workspaces.models.RCranPackage]
    :param git_hub_packages: The packages directly from GitHub.
    :type git_hub_packages: list[~azure_machine_learning_workspaces.models.RGitHubPackageResponse]
    :param custom_url_packages: The packages from custom urls.
    :type custom_url_packages: list[str]
    :param bio_conductor_packages: The packages from Bioconductor.
    :type bio_conductor_packages: list[str]
    """

    _attribute_map = {
        'r_version': {'key': 'rVersion', 'type': 'str'},
        'user_managed': {'key': 'userManaged', 'type': 'bool'},
        'rscript_path': {'key': 'rscriptPath', 'type': 'str'},
        'snapshot_date': {'key': 'snapshotDate', 'type': 'str'},
        'cran_packages': {'key': 'cranPackages', 'type': '[RCranPackage]'},
        'git_hub_packages': {'key': 'gitHubPackages', 'type': '[RGitHubPackageResponse]'},
        'custom_url_packages': {'key': 'customUrlPackages', 'type': '[str]'},
        'bio_conductor_packages': {'key': 'bioConductorPackages', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        r_version: Optional[str] = None,
        user_managed: Optional[bool] = None,
        rscript_path: Optional[str] = None,
        snapshot_date: Optional[str] = None,
        cran_packages: Optional[List["RCranPackage"]] = None,
        git_hub_packages: Optional[List["RGitHubPackageResponse"]] = None,
        custom_url_packages: Optional[List[str]] = None,
        bio_conductor_packages: Optional[List[str]] = None,
        **kwargs
    ):
        super(RSectionResponse, self).__init__(**kwargs)
        self.r_version = r_version
        self.user_managed = user_managed
        self.rscript_path = rscript_path
        self.snapshot_date = snapshot_date
        self.cran_packages = cran_packages
        self.git_hub_packages = git_hub_packages
        self.custom_url_packages = custom_url_packages
        self.bio_conductor_packages = bio_conductor_packages


class ModelEnvironmentDefinitionResponseR(RSectionResponse):
    """Settings for a R environment.

    :param r_version: The version of R to be installed.
    :type r_version: str
    :param user_managed: Indicates whether the environment is managed by user or by AzureML.
    :type user_managed: bool
    :param rscript_path: The Rscript path to use if an environment build is not required.
     The path specified gets used to call the user script.
    :type rscript_path: str
    :param snapshot_date: Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17".
    :type snapshot_date: str
    :param cran_packages: The CRAN packages to use.
    :type cran_packages: list[~azure_machine_learning_workspaces.models.RCranPackage]
    :param git_hub_packages: The packages directly from GitHub.
    :type git_hub_packages: list[~azure_machine_learning_workspaces.models.RGitHubPackageResponse]
    :param custom_url_packages: The packages from custom urls.
    :type custom_url_packages: list[str]
    :param bio_conductor_packages: The packages from Bioconductor.
    :type bio_conductor_packages: list[str]
    """

    _attribute_map = {
        'r_version': {'key': 'rVersion', 'type': 'str'},
        'user_managed': {'key': 'userManaged', 'type': 'bool'},
        'rscript_path': {'key': 'rscriptPath', 'type': 'str'},
        'snapshot_date': {'key': 'snapshotDate', 'type': 'str'},
        'cran_packages': {'key': 'cranPackages', 'type': '[RCranPackage]'},
        'git_hub_packages': {'key': 'gitHubPackages', 'type': '[RGitHubPackageResponse]'},
        'custom_url_packages': {'key': 'customUrlPackages', 'type': '[str]'},
        'bio_conductor_packages': {'key': 'bioConductorPackages', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        r_version: Optional[str] = None,
        user_managed: Optional[bool] = None,
        rscript_path: Optional[str] = None,
        snapshot_date: Optional[str] = None,
        cran_packages: Optional[List["RCranPackage"]] = None,
        git_hub_packages: Optional[List["RGitHubPackageResponse"]] = None,
        custom_url_packages: Optional[List[str]] = None,
        bio_conductor_packages: Optional[List[str]] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionResponseR, self).__init__(r_version=r_version, user_managed=user_managed, rscript_path=rscript_path, snapshot_date=snapshot_date, cran_packages=cran_packages, git_hub_packages=git_hub_packages, custom_url_packages=custom_url_packages, bio_conductor_packages=bio_conductor_packages, **kwargs)


class ModelSparkSection(msrest.serialization.Model):
    """ModelSparkSection.

    :param repositories: The list of spark repositories.
    :type repositories: list[str]
    :param packages: The Spark packages to use.
    :type packages: list[~azure_machine_learning_workspaces.models.SparkMavenPackage]
    :param precache_packages: Whether to precache the packages.
    :type precache_packages: bool
    """

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[str]'},
        'packages': {'key': 'packages', 'type': '[SparkMavenPackage]'},
        'precache_packages': {'key': 'precachePackages', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        repositories: Optional[List[str]] = None,
        packages: Optional[List["SparkMavenPackage"]] = None,
        precache_packages: Optional[bool] = None,
        **kwargs
    ):
        super(ModelSparkSection, self).__init__(**kwargs)
        self.repositories = repositories
        self.packages = packages
        self.precache_packages = precache_packages


class ModelEnvironmentDefinitionResponseSpark(ModelSparkSection):
    """The configuration for a Spark environment.

    :param repositories: The list of spark repositories.
    :type repositories: list[str]
    :param packages: The Spark packages to use.
    :type packages: list[~azure_machine_learning_workspaces.models.SparkMavenPackage]
    :param precache_packages: Whether to precache the packages.
    :type precache_packages: bool
    """

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[str]'},
        'packages': {'key': 'packages', 'type': '[SparkMavenPackage]'},
        'precache_packages': {'key': 'precachePackages', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        repositories: Optional[List[str]] = None,
        packages: Optional[List["SparkMavenPackage"]] = None,
        precache_packages: Optional[bool] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionResponseSpark, self).__init__(repositories=repositories, packages=packages, precache_packages=precache_packages, **kwargs)


class ModelEnvironmentDefinitionSpark(ModelSparkSection):
    """The configuration for a Spark environment.

    :param repositories: The list of spark repositories.
    :type repositories: list[str]
    :param packages: The Spark packages to use.
    :type packages: list[~azure_machine_learning_workspaces.models.SparkMavenPackage]
    :param precache_packages: Whether to precache the packages.
    :type precache_packages: bool
    """

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[str]'},
        'packages': {'key': 'packages', 'type': '[SparkMavenPackage]'},
        'precache_packages': {'key': 'precachePackages', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        repositories: Optional[List[str]] = None,
        packages: Optional[List["SparkMavenPackage"]] = None,
        precache_packages: Optional[bool] = None,
        **kwargs
    ):
        super(ModelEnvironmentDefinitionSpark, self).__init__(repositories=repositories, packages=packages, precache_packages=precache_packages, **kwargs)


class ModelVersionResource(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    :param stage: Model asset stage.
    :type stage: str
    :param datastore_id: The asset datastoreId.
    :type datastore_id: str
    :param asset_path: Details of an AssetUri.
    :type asset_path: ~azure_machine_learning_workspaces.models.AssetPath
    :param linked_resource_ids: Associated ARM resources. Key is the link type, value is a list of
     ARM IDs.
    :type linked_resource_ids: dict[str, list[str]]
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
        'stage': {'key': 'properties.stage', 'type': 'str'},
        'datastore_id': {'key': 'properties.datastoreId', 'type': 'str'},
        'asset_path': {'key': 'properties.assetPath', 'type': 'AssetPath'},
        'linked_resource_ids': {'key': 'properties.linkedResourceIds', 'type': '{[str]}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'tags': {'key': 'properties.tags', 'type': '{str}'},
        'properties': {'key': 'properties.properties', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        system_data: Optional["SystemData"] = None,
        stage: Optional[str] = None,
        datastore_id: Optional[str] = None,
        asset_path: Optional["AssetPath"] = None,
        linked_resource_ids: Optional[Dict[str, List[str]]] = None,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ModelVersionResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.system_data = system_data
        self.stage = stage
        self.datastore_id = datastore_id
        self.asset_path = asset_path
        self.linked_resource_ids = linked_resource_ids
        self.description = description
        self.tags = tags
        self.properties = properties


class ModelVersionResourceArmPaginatedResult(msrest.serialization.Model):
    """ModelVersionResourceArmPaginatedResult.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.ModelVersionResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ModelVersionResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ModelVersionResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(ModelVersionResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class ModifyExperimentDto(msrest.serialization.Model):
    """ModifyExperimentDto.

    :param name:
    :type name: str
    :param description:
    :type description: str
    :param archive:
    :type archive: bool
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'archive': {'key': 'archive', 'type': 'bool'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        archive: Optional[bool] = None,
        tags: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(ModifyExperimentDto, self).__init__(**kwargs)
        self.name = name
        self.description = description
        self.archive = archive
        self.tags = tags


class ModifyRunDto(msrest.serialization.Model):
    """ModifyRunDto.

    :param name:
    :type name: str
    :param data_container_id:
    :type data_container_id: str
    :param description:
    :type description: str
    :param hidden:
    :type hidden: bool
    :param run_type:
    :type run_type: str
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param script_name:
    :type script_name: str
    :param target:
    :type target: str
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param input_datasets:
    :type input_datasets: list[~azure_machine_learning_workspaces.models.Dataset]
    :param output_datasets:
    :type output_datasets: list[~azure_machine_learning_workspaces.models.OutputDatasetLineage]
    :param run_definition: Any object.
    :type run_definition: object
    :param created_from:
    :type created_from: ~azure_machine_learning_workspaces.models.CreatedFromDto
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'hidden': {'key': 'hidden', 'type': 'bool'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'script_name': {'key': 'scriptName', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[Dataset]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'created_from': {'key': 'createdFrom', 'type': 'CreatedFromDto'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        data_container_id: Optional[str] = None,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        run_type: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        script_name: Optional[str] = None,
        target: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        input_datasets: Optional[List["Dataset"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        created_from: Optional["CreatedFromDto"] = None,
        **kwargs
    ):
        super(ModifyRunDto, self).__init__(**kwargs)
        self.name = name
        self.data_container_id = data_container_id
        self.description = description
        self.hidden = hidden
        self.run_type = run_type
        self.properties = properties
        self.script_name = script_name
        self.target = target
        self.tags = tags
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.created_from = created_from


class Mpi(DistributionConfiguration):
    """Mpi.

    All required parameters must be populated in order to send to Azure.

    :param distribution_type: Required. Specifies the type of distibution framework.Constant filled
     by server.  Possible values include: "PyTorch", "Tensorflow", "Mpi".
    :type distribution_type: str or ~azure_machine_learning_workspaces.models.DistributionType
    :param process_count_per_node:
    :type process_count_per_node: int
    :param node_count: Number of nodes. Overwrites the node count in compute binding.
    :type node_count: int
    """

    _validation = {
        'distribution_type': {'required': True},
    }

    _attribute_map = {
        'distribution_type': {'key': 'distributionType', 'type': 'str'},
        'process_count_per_node': {'key': 'processCountPerNode', 'type': 'int'},
        'node_count': {'key': 'nodeCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        process_count_per_node: Optional[int] = None,
        node_count: Optional[int] = None,
        **kwargs
    ):
        super(Mpi, self).__init__(**kwargs)
        self.distribution_type = 'Mpi'  # type: str
        self.process_count_per_node = process_count_per_node
        self.node_count = node_count


class NodeStateCounts(msrest.serialization.Model):
    """Counts of various compute node states on the amlCompute.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar idle_node_count: Number of compute nodes in idle state.
    :vartype idle_node_count: int
    :ivar running_node_count: Number of compute nodes which are running jobs.
    :vartype running_node_count: int
    :ivar preparing_node_count: Number of compute nodes which are being prepared.
    :vartype preparing_node_count: int
    :ivar unusable_node_count: Number of compute nodes which are in unusable state.
    :vartype unusable_node_count: int
    :ivar leaving_node_count: Number of compute nodes which are leaving the amlCompute.
    :vartype leaving_node_count: int
    :ivar preempted_node_count: Number of compute nodes which are in preempted state.
    :vartype preempted_node_count: int
    """

    _validation = {
        'idle_node_count': {'readonly': True},
        'running_node_count': {'readonly': True},
        'preparing_node_count': {'readonly': True},
        'unusable_node_count': {'readonly': True},
        'leaving_node_count': {'readonly': True},
        'preempted_node_count': {'readonly': True},
    }

    _attribute_map = {
        'idle_node_count': {'key': 'idleNodeCount', 'type': 'int'},
        'running_node_count': {'key': 'runningNodeCount', 'type': 'int'},
        'preparing_node_count': {'key': 'preparingNodeCount', 'type': 'int'},
        'unusable_node_count': {'key': 'unusableNodeCount', 'type': 'int'},
        'leaving_node_count': {'key': 'leavingNodeCount', 'type': 'int'},
        'preempted_node_count': {'key': 'preemptedNodeCount', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(NodeStateCounts, self).__init__(**kwargs)
        self.idle_node_count = None
        self.running_node_count = None
        self.preparing_node_count = None
        self.unusable_node_count = None
        self.leaving_node_count = None
        self.preempted_node_count = None


class OnlineDeploymentProperties(msrest.serialization.Model):
    """OnlineDeploymentProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param scale_settings:
    :type scale_settings: ~azure_machine_learning_workspaces.models.ScaleSettings
    :param environment_overrides:
    :type environment_overrides: ~azure_machine_learning_workspaces.models.EnvironmentOverrides
    :param deployment_configuration:
    :type deployment_configuration:
     ~azure_machine_learning_workspaces.models.DeploymentConfigurationBase
    :param description: Description of the endpoint deployment.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param model_reference: Model Configuration.
    :type model_reference: ~azure_machine_learning_workspaces.models.AssetReferenceBase
    :param code_configuration:
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment specification for the endpoint deployment.
    :type environment_id: str
    :ivar provisioning_state: Provisioning state for the endpoint deployment. Possible values
     include: "Creating", "Deleting", "Scaling", "Updating", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.DeploymentProvisioningState
    """

    _validation = {
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'scale_settings': {'key': 'scaleSettings', 'type': 'ScaleSettings'},
        'environment_overrides': {'key': 'environmentOverrides', 'type': 'EnvironmentOverrides'},
        'deployment_configuration': {'key': 'deploymentConfiguration', 'type': 'DeploymentConfigurationBase'},
        'description': {'key': 'description', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'model_reference': {'key': 'modelReference', 'type': 'AssetReferenceBase'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        scale_settings: Optional["ScaleSettings"] = None,
        environment_overrides: Optional["EnvironmentOverrides"] = None,
        deployment_configuration: Optional["DeploymentConfigurationBase"] = None,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        model_reference: Optional["AssetReferenceBase"] = None,
        code_configuration: Optional["CodeConfiguration"] = None,
        environment_id: Optional[str] = None,
        **kwargs
    ):
        super(OnlineDeploymentProperties, self).__init__(**kwargs)
        self.scale_settings = scale_settings
        self.environment_overrides = environment_overrides
        self.deployment_configuration = deployment_configuration
        self.description = description
        self.properties = properties
        self.model_reference = model_reference
        self.code_configuration = code_configuration
        self.environment_id = environment_id
        self.provisioning_state = None


class OnlineDeploymentPropertiesDeploymentConfiguration(DeploymentConfigurationBase):
    """OnlineDeploymentPropertiesDeploymentConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param app_insights_enabled:
    :type app_insights_enabled: bool
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'app_insights_enabled': {'key': 'appInsightsEnabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        app_insights_enabled: Optional[bool] = None,
        **kwargs
    ):
        super(OnlineDeploymentPropertiesDeploymentConfiguration, self).__init__(app_insights_enabled=app_insights_enabled, **kwargs)
        self.compute_type = 'OnlineDeploymentProperties-deploymentConfiguration'  # type: str


class OnlineDeploymentPropertiesModelReference(AssetReferenceBase):
    """Model Configuration.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(OnlineDeploymentPropertiesModelReference, self).__init__(**kwargs)
        self.reference_type = 'OnlineDeploymentProperties-modelReference'  # type: str


class OnlineDeploymentPropertiesTrackedResource(msrest.serialization.Model):
    """OnlineDeploymentPropertiesTrackedResource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param location:
    :type location: str
    :param kind:
    :type kind: str
    :param identity:
    :type identity: ~azure_machine_learning_workspaces.models.ResourceIdentityInArm
    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required.
    :type properties: ~azure_machine_learning_workspaces.models.OnlineDeploymentProperties
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentityInArm'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'OnlineDeploymentProperties'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "OnlineDeploymentProperties",
        tags: Optional[Dict[str, str]] = None,
        location: Optional[str] = None,
        kind: Optional[str] = None,
        identity: Optional["ResourceIdentityInArm"] = None,
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(OnlineDeploymentPropertiesTrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location
        self.kind = kind
        self.identity = identity
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class OnlineDeploymentPropertiesTrackedResourceArmPaginatedResult(msrest.serialization.Model):
    """OnlineDeploymentPropertiesTrackedResourceArmPaginatedResult.

    :param value:
    :type value:
     list[~azure_machine_learning_workspaces.models.OnlineDeploymentPropertiesTrackedResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[OnlineDeploymentPropertiesTrackedResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["OnlineDeploymentPropertiesTrackedResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(OnlineDeploymentPropertiesTrackedResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class OnlineEndpointProperties(msrest.serialization.Model):
    """Online endpoint configuration.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param description: Description of the inference endpoint.
    :type description: str
    :param properties: Property dictionary. Properties can be added, but not removed or altered.
    :type properties: dict[str, str]
    :param traffic_rules: Traffic rules on how the traffic will be routed across deployments.
    :type traffic_rules: dict[str, int]
    :param compute_configuration: Reference to compute configuration.
    :type compute_configuration: ~azure_machine_learning_workspaces.models.ComputeConfiguration
    :ivar provisioning_state: State of provisioning. Possible values include: "Creating",
     "Deleting", "Succeeded", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.EndpointProvisioningState
    :ivar endpoint: Endpoint URI.
    :vartype endpoint: str
    :ivar swagger_endpoint: Endpoint Swagger URI.
    :vartype swagger_endpoint: str
    :param auth_mode: Inference endpoint authentication mode type. Possible values include:
     "AMLToken", "Key".
    :type auth_mode: str or ~azure_machine_learning_workspaces.models.EndpointAuthModeType
    :param keys:
    :type keys: ~azure_machine_learning_workspaces.models.AuthKeys
    """

    _validation = {
        'provisioning_state': {'readonly': True},
        'endpoint': {'readonly': True},
        'swagger_endpoint': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'traffic_rules': {'key': 'trafficRules', 'type': '{int}'},
        'compute_configuration': {'key': 'computeConfiguration', 'type': 'ComputeConfiguration'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'swagger_endpoint': {'key': 'swaggerEndpoint', 'type': 'str'},
        'auth_mode': {'key': 'authMode', 'type': 'str'},
        'keys': {'key': 'keys', 'type': 'AuthKeys'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        traffic_rules: Optional[Dict[str, int]] = None,
        compute_configuration: Optional["ComputeConfiguration"] = None,
        auth_mode: Optional[Union[str, "EndpointAuthModeType"]] = None,
        keys: Optional["AuthKeys"] = None,
        **kwargs
    ):
        super(OnlineEndpointProperties, self).__init__(**kwargs)
        self.description = description
        self.properties = properties
        self.traffic_rules = traffic_rules
        self.compute_configuration = compute_configuration
        self.provisioning_state = None
        self.endpoint = None
        self.swagger_endpoint = None
        self.auth_mode = auth_mode
        self.keys = keys


class OnlineEndpointPropertiesComputeConfiguration(ComputeConfiguration):
    """Reference to compute configuration.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. Constant filled by server.  Possible values include:
     "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight", "Databricks",
     "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(OnlineEndpointPropertiesComputeConfiguration, self).__init__(**kwargs)
        self.compute_type = 'OnlineEndpointProperties-computeConfiguration'  # type: str


class OnlineEndpointPropertiesTrackedResource(msrest.serialization.Model):
    """OnlineEndpointPropertiesTrackedResource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param location:
    :type location: str
    :param kind:
    :type kind: str
    :param identity:
    :type identity: ~azure_machine_learning_workspaces.models.ResourceIdentityInArm
    :ivar id: The resource URL of the entity (not URL encoded).
    :vartype id: str
    :ivar name: The name of the resource entity.
    :vartype name: str
    :ivar type: The resource provider and type.
    :vartype type: str
    :param properties: Required. Online endpoint configuration.
    :type properties: ~azure_machine_learning_workspaces.models.OnlineEndpointProperties
    :param system_data: Azure Resource Manager resource Envelope.
    :type system_data: ~azure_machine_learning_workspaces.models.SystemData
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'location': {'key': 'location', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'ResourceIdentityInArm'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'OnlineEndpointProperties'},
        'system_data': {'key': 'systemData', 'type': 'SystemData'},
    }

    def __init__(
        self,
        *,
        properties: "OnlineEndpointProperties",
        tags: Optional[Dict[str, str]] = None,
        location: Optional[str] = None,
        kind: Optional[str] = None,
        identity: Optional["ResourceIdentityInArm"] = None,
        system_data: Optional["SystemData"] = None,
        **kwargs
    ):
        super(OnlineEndpointPropertiesTrackedResource, self).__init__(**kwargs)
        self.tags = tags
        self.location = location
        self.kind = kind
        self.identity = identity
        self.id = None
        self.name = None
        self.type = None
        self.properties = properties
        self.system_data = system_data


class OnlineEndpointPropertiesTrackedResourceArmPaginatedResult(msrest.serialization.Model):
    """OnlineEndpointPropertiesTrackedResourceArmPaginatedResult.

    :param value:
    :type value:
     list[~azure_machine_learning_workspaces.models.OnlineEndpointPropertiesTrackedResource]
    :param next_link:
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[OnlineEndpointPropertiesTrackedResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["OnlineEndpointPropertiesTrackedResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(OnlineEndpointPropertiesTrackedResourceArmPaginatedResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class Operation(msrest.serialization.Model):
    """Azure Machine Learning workspace REST API operation.

    :param name: Operation name: {provider}/{resource}/{operation}.
    :type name: str
    :param display: Display name of operation.
    :type display: ~azure_machine_learning_workspaces.models.OperationDisplay
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display': {'key': 'display', 'type': 'OperationDisplay'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        display: Optional["OperationDisplay"] = None,
        **kwargs
    ):
        super(Operation, self).__init__(**kwargs)
        self.name = name
        self.display = display


class OperationDisplay(msrest.serialization.Model):
    """Display name of operation.

    :param provider: The resource provider name: Microsoft.MachineLearningExperimentation.
    :type provider: str
    :param resource: The resource on which the operation is performed.
    :type resource: str
    :param operation: The operation that users can perform.
    :type operation: str
    :param description: The description for the operation.
    :type description: str
    """

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        provider: Optional[str] = None,
        resource: Optional[str] = None,
        operation: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(OperationDisplay, self).__init__(**kwargs)
        self.provider = provider
        self.resource = resource
        self.operation = operation
        self.description = description


class OperationListResult(msrest.serialization.Model):
    """An array of operations supported by the resource provider.

    :param value: List of AML workspace operations supported by the AML workspace resource
     provider.
    :type value: list[~azure_machine_learning_workspaces.models.Operation]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Operation]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Operation"]] = None,
        **kwargs
    ):
        super(OperationListResult, self).__init__(**kwargs)
        self.value = value


class OutputDatasetLineage(msrest.serialization.Model):
    """OutputDatasetLineage.

    :param output_type:  Possible values include: "RunOutput", "Reference".
    :type output_type: str or ~azure_machine_learning_workspaces.models.DatasetOutputType
    :param output_name:
    :type output_name: str
    :param mechanism:  Possible values include: "Upload", "Mount".
    :type mechanism: str or ~azure_machine_learning_workspaces.models.DatasetOutputMechanism
    :param saved_id:
    :type saved_id: str
    :param registered_id:
    :type registered_id: str
    :param registered_version:
    :type registered_version: str
    """

    _attribute_map = {
        'output_type': {'key': 'outputType', 'type': 'str'},
        'output_name': {'key': 'outputDetails.outputName', 'type': 'str'},
        'mechanism': {'key': 'outputDetails.mechanism', 'type': 'str'},
        'saved_id': {'key': 'identifier.savedId', 'type': 'str'},
        'registered_id': {'key': 'identifier.registeredId', 'type': 'str'},
        'registered_version': {'key': 'identifier.registeredVersion', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        output_type: Optional[Union[str, "DatasetOutputType"]] = None,
        output_name: Optional[str] = None,
        mechanism: Optional[Union[str, "DatasetOutputMechanism"]] = None,
        saved_id: Optional[str] = None,
        registered_id: Optional[str] = None,
        registered_version: Optional[str] = None,
        **kwargs
    ):
        super(OutputDatasetLineage, self).__init__(**kwargs)
        self.output_type = output_type
        self.output_name = output_name
        self.mechanism = mechanism
        self.saved_id = saved_id
        self.registered_id = registered_id
        self.registered_version = registered_version


class OutputPathAssetReference(AssetReferenceBase):
    """OutputPathAssetReference.

    All required parameters must be populated in order to send to Azure.

    :param reference_type: Required. Specifies the type of asset reference.Constant filled by
     server.  Possible values include: "Id", "DataPath", "OutputPath".
    :type reference_type: str or ~azure_machine_learning_workspaces.models.ReferenceType
    :param path:
    :type path: str
    :param job_id:
    :type job_id: str
    """

    _validation = {
        'reference_type': {'required': True},
    }

    _attribute_map = {
        'reference_type': {'key': 'referenceType', 'type': 'str'},
        'path': {'key': 'path', 'type': 'str'},
        'job_id': {'key': 'jobId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        path: Optional[str] = None,
        job_id: Optional[str] = None,
        **kwargs
    ):
        super(OutputPathAssetReference, self).__init__(**kwargs)
        self.reference_type = 'OutputPath'  # type: str
        self.path = path
        self.job_id = job_id


class PaginatedArtifactContentInformationDto(msrest.serialization.Model):
    """PaginatedArtifactContentInformationDto.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.ArtifactContentInformationDto]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ArtifactContentInformationDto]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ArtifactContentInformationDto"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedArtifactContentInformationDto, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedArtifactDto(msrest.serialization.Model):
    """PaginatedArtifactDto.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.ArtifactDto]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ArtifactDto]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ArtifactDto"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedArtifactDto, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedBaseEvent(msrest.serialization.Model):
    """PaginatedBaseEvent.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.BaseEvent]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[BaseEvent]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["BaseEvent"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedBaseEvent, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedComputeResourcesList(msrest.serialization.Model):
    """Paginated list of Machine Learning compute objects wrapped in ARM resource envelope.

    :param value: An array of Machine Learning compute objects wrapped in ARM resource envelope.
    :type value: list[~azure_machine_learning_workspaces.models.ComputeResource]
    :param next_link: A continuation link (absolute URI) to the next page of results in the list.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ComputeResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ComputeResource"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedComputeResourcesList, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class PaginatedExperimentDto(msrest.serialization.Model):
    """PaginatedExperimentDto.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.ExperimentDto]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ExperimentDto]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["ExperimentDto"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedExperimentDto, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedLinkedWorkspaceList(msrest.serialization.Model):
    """Paginated list of Machine Learning Linked Workspace objects wrapped in ARM resource envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: An array of Machine Learning Linked Workspace objects wrapped in ARM resource
     envelope.
    :vartype value: list[~azure_machine_learning_workspaces.models.LinkedWorkspace]
    :param next_link: A continuation link (absolute URI) to the next page of results in the list.
    :type next_link: str
    """

    _validation = {
        'value': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[LinkedWorkspace]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedLinkedWorkspaceList, self).__init__(**kwargs)
        self.value = None
        self.next_link = next_link


class PaginatedRunDto(msrest.serialization.Model):
    """PaginatedRunDto.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.RunDto]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[RunDto]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["RunDto"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedRunDto, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedRunMetricDto(msrest.serialization.Model):
    """PaginatedRunMetricDto.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.RunMetricDto]
    :param continuation_token:
    :type continuation_token: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[RunMetricDto]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["RunMetricDto"]] = None,
        continuation_token: Optional[str] = None,
        **kwargs
    ):
        super(PaginatedRunMetricDto, self).__init__(**kwargs)
        self.value = value
        self.continuation_token = continuation_token


class PaginatedServiceList(msrest.serialization.Model):
    """Paginated list of Machine Learning service objects wrapped in ARM resource envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: An array of Machine Learning compute objects wrapped in ARM resource envelope.
    :vartype value: list[~azure_machine_learning_workspaces.models.ServiceResource]
    :ivar next_link: A continuation link (absolute URI) to the next page of results in the list.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ServiceResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PaginatedServiceList, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class ParameterSamplingConfiguration(msrest.serialization.Model):
    """class for all hyperparameter sampling algorithms.

    :param parameter_space: A dictionary containing each parameter and its distribution. The
     dictionary key is the name of the parameter.
    :type parameter_space: object
    :param properties: A dictionary with additional properties for the algorithm.
    :type properties: dict[str, str]
    :param sampling_type: Type of the hyperparameter sampling algorithms. Possible values include:
     "Grid", "Random", "Bayesian".
    :type sampling_type: str or ~azure_machine_learning_workspaces.models.ParameterSamplingType
    """

    _attribute_map = {
        'parameter_space': {'key': 'parameterSpace', 'type': 'object'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'sampling_type': {'key': 'samplingType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        parameter_space: Optional[object] = None,
        properties: Optional[Dict[str, str]] = None,
        sampling_type: Optional[Union[str, "ParameterSamplingType"]] = None,
        **kwargs
    ):
        super(ParameterSamplingConfiguration, self).__init__(**kwargs)
        self.parameter_space = parameter_space
        self.properties = properties
        self.sampling_type = sampling_type


class Password(msrest.serialization.Model):
    """Password.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name:
    :vartype name: str
    :ivar value:
    :vartype value: str
    """

    _validation = {
        'name': {'readonly': True},
        'value': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Password, self).__init__(**kwargs)
        self.name = None
        self.value = None


class PipelineJob(JobBase):
    """Pipeline Job definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param pipeline_graph_id: Yaml based code asset Id.
    :type pipeline_graph_id: str
    :param pipeline_parameters: Parameters to pipeline execution.
    :type pipeline_parameters: dict[str, str]
    :param continue_on_step_failure: Flag when set, continue pipeline execution if a step fails.
    :type continue_on_step_failure: bool
    :param regenerate_outputs: Whether to force regeneration of all step outputs and disallow data
     reuse for this run.
    :type regenerate_outputs: bool
    :param parent_run_id: Run id to set the parent run of this pipeline run.
    :type parent_run_id: str
    :param default_datastore: The default datastore to use for data connections.
    :type default_datastore: str
    :param default_source_directory: The default script directory for steps which execute a script.
    :type default_source_directory: str
    :param resolve_closure: Whether to resolve closure or not (automatically bring in dependent
     steps).
    :type resolve_closure: bool
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'pipeline_graph_id': {'key': 'pipelineGraphId', 'type': 'str'},
        'pipeline_parameters': {'key': 'pipelineParameters', 'type': '{str}'},
        'continue_on_step_failure': {'key': 'continueOnStepFailure', 'type': 'bool'},
        'regenerate_outputs': {'key': 'regenerateOutputs', 'type': 'bool'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'default_datastore': {'key': 'defaultDatastore', 'type': 'str'},
        'default_source_directory': {'key': 'defaultSourceDirectory', 'type': 'str'},
        'resolve_closure': {'key': 'resolveClosure', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        pipeline_graph_id: Optional[str] = None,
        pipeline_parameters: Optional[Dict[str, str]] = None,
        continue_on_step_failure: Optional[bool] = None,
        regenerate_outputs: Optional[bool] = None,
        parent_run_id: Optional[str] = None,
        default_datastore: Optional[str] = None,
        default_source_directory: Optional[str] = None,
        resolve_closure: Optional[bool] = None,
        **kwargs
    ):
        super(PipelineJob, self).__init__(description=description, tags=tags, properties=properties, **kwargs)
        self.job_type = 'Pipeline'  # type: str
        self.pipeline_graph_id = pipeline_graph_id
        self.pipeline_parameters = pipeline_parameters
        self.continue_on_step_failure = continue_on_step_failure
        self.regenerate_outputs = regenerate_outputs
        self.parent_run_id = parent_run_id
        self.default_datastore = default_datastore
        self.default_source_directory = default_source_directory
        self.resolve_closure = resolve_closure


class PrivateEndpoint(msrest.serialization.Model):
    """The Private Endpoint resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The ARM identifier for Private Endpoint.
    :vartype id: str
    """

    _validation = {
        'id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PrivateEndpoint, self).__init__(**kwargs)
        self.id = None


class PrivateEndpointConnection(MachineLearningResource):
    """The Private Endpoint Connection resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    :param private_endpoint: The resource of private end point.
    :type private_endpoint: ~azure_machine_learning_workspaces.models.PrivateEndpoint
    :param private_link_service_connection_state: A collection of information about the state of
     the connection between service consumer and provider.
    :type private_link_service_connection_state:
     ~azure_machine_learning_workspaces.models.PrivateLinkServiceConnectionState
    :ivar provisioning_state: The provisioning state of the private endpoint connection resource.
     Possible values include: "Succeeded", "Creating", "Deleting", "Failed".
    :vartype provisioning_state: str or
     ~azure_machine_learning_workspaces.models.PrivateEndpointConnectionProvisioningState
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
        'private_endpoint': {'key': 'properties.privateEndpoint', 'type': 'PrivateEndpoint'},
        'private_link_service_connection_state': {'key': 'properties.privateLinkServiceConnectionState', 'type': 'PrivateLinkServiceConnectionState'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        private_endpoint: Optional["PrivateEndpoint"] = None,
        private_link_service_connection_state: Optional["PrivateLinkServiceConnectionState"] = None,
        **kwargs
    ):
        super(PrivateEndpointConnection, self).__init__(location=location, tags=tags, sku=sku, type_identity_type=type_identity_type, user_assigned_identities=user_assigned_identities, **kwargs)
        self.private_endpoint = private_endpoint
        self.private_link_service_connection_state = private_link_service_connection_state
        self.provisioning_state = None


class PrivateLinkResource(MachineLearningResource):
    """A private link resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    :ivar group_id: The private link resource group id.
    :vartype group_id: str
    :ivar required_members: The private link resource required member names.
    :vartype required_members: list[str]
    :param required_zone_names: The private link resource Private link DNS zone name.
    :type required_zone_names: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
        'group_id': {'readonly': True},
        'required_members': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
        'group_id': {'key': 'properties.groupId', 'type': 'str'},
        'required_members': {'key': 'properties.requiredMembers', 'type': '[str]'},
        'required_zone_names': {'key': 'properties.requiredZoneNames', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        required_zone_names: Optional[List[str]] = None,
        **kwargs
    ):
        super(PrivateLinkResource, self).__init__(location=location, tags=tags, sku=sku, type_identity_type=type_identity_type, user_assigned_identities=user_assigned_identities, **kwargs)
        self.group_id = None
        self.required_members = None
        self.required_zone_names = required_zone_names


class PrivateLinkResourceListResult(msrest.serialization.Model):
    """A list of private link resources.

    :param value: Array of private link resources.
    :type value: list[~azure_machine_learning_workspaces.models.PrivateLinkResource]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[PrivateLinkResource]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["PrivateLinkResource"]] = None,
        **kwargs
    ):
        super(PrivateLinkResourceListResult, self).__init__(**kwargs)
        self.value = value


class PrivateLinkServiceConnectionState(msrest.serialization.Model):
    """A collection of information about the state of the connection between service consumer and provider.

    :param status: Indicates whether the connection has been Approved/Rejected/Removed by the owner
     of the service. Possible values include: "Pending", "Approved", "Rejected", "Disconnected",
     "Timeout".
    :type status: str or
     ~azure_machine_learning_workspaces.models.PrivateEndpointServiceConnectionStatus
    :param description: The reason for approval/rejection of the connection.
    :type description: str
    :param actions_required: A message indicating if changes on the service provider require any
     updates on the consumer.
    :type actions_required: str
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'actions_required': {'key': 'actionsRequired', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        status: Optional[Union[str, "PrivateEndpointServiceConnectionStatus"]] = None,
        description: Optional[str] = None,
        actions_required: Optional[str] = None,
        **kwargs
    ):
        super(PrivateLinkServiceConnectionState, self).__init__(**kwargs)
        self.status = status
        self.description = description
        self.actions_required = actions_required


class ProgressMetrics(msrest.serialization.Model):
    """Progress metrics definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar total_datapoint_count: The total datapoint count.
    :vartype total_datapoint_count: long
    :ivar completed_datapoint_count: The completed datapoint count.
    :vartype completed_datapoint_count: long
    :ivar skipped_datapoint_count: The skipped datapoint count.
    :vartype skipped_datapoint_count: long
    :ivar incremental_dataset_last_refresh_time: The time of last successful incremental dataset
     refresh in UTC.
    :vartype incremental_dataset_last_refresh_time: ~datetime.datetime
    """

    _validation = {
        'total_datapoint_count': {'readonly': True},
        'completed_datapoint_count': {'readonly': True},
        'skipped_datapoint_count': {'readonly': True},
        'incremental_dataset_last_refresh_time': {'readonly': True},
    }

    _attribute_map = {
        'total_datapoint_count': {'key': 'totalDatapointCount', 'type': 'long'},
        'completed_datapoint_count': {'key': 'completedDatapointCount', 'type': 'long'},
        'skipped_datapoint_count': {'key': 'skippedDatapointCount', 'type': 'long'},
        'incremental_dataset_last_refresh_time': {'key': 'incrementalDatasetLastRefreshTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ProgressMetrics, self).__init__(**kwargs)
        self.total_datapoint_count = None
        self.completed_datapoint_count = None
        self.skipped_datapoint_count = None
        self.incremental_dataset_last_refresh_time = None


class PythonProperties(msrest.serialization.Model):
    """Class to represent configuration settings for Python and Conda.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: Python specification type must be either Pip Requirements or a Conda Environment
     File. Possible values include: "CondaEnvironment", "PipRequirements".
    :vartype type: str or ~azure_machine_learning_workspaces.models.PythonSpecificationType
    :param conda_file: Standard configuration file used by conda that lets you install any kind of
     package, including Python, R, and C/C++ packages
    
    
     .. raw:: html
    
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-
     install-a-conda-environment" />.
    :type conda_file: str
    :param pip_requirements: Specifies a list of Python packages that should be installed.
     This property will not be used if CondaFile is supplied and Type is
     PythonSpecificationType.CondaEnvironment
    Microsoft.MachineLearning.ManagementFrontEnd.Contracts.Assets.EnvironmentSpecificationVersion.PythonProperties.Type:code:`<seealso
     href="https://repo2docker.readthedocs.io/en/latest/config_files.html#requirements-txt-install-
     a-python-environment" />`.
    :type pip_requirements: str
    """

    _validation = {
        'type': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'conda_file': {'key': 'condaFile', 'type': 'str'},
        'pip_requirements': {'key': 'pipRequirements', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        conda_file: Optional[str] = None,
        pip_requirements: Optional[str] = None,
        **kwargs
    ):
        super(PythonProperties, self).__init__(**kwargs)
        self.type = None
        self.conda_file = conda_file
        self.pip_requirements = pip_requirements


class PyTorch(DistributionConfiguration):
    """PyTorch.

    All required parameters must be populated in order to send to Azure.

    :param distribution_type: Required. Specifies the type of distibution framework.Constant filled
     by server.  Possible values include: "PyTorch", "Tensorflow", "Mpi".
    :type distribution_type: str or ~azure_machine_learning_workspaces.models.DistributionType
    :param communication_backend:  Possible values include: "Nccl", "Gloo".
    :type communication_backend: str or
     ~azure_machine_learning_workspaces.models.CommunicationBackend
    :param node_count: Number of nodes. Overwrites the node count in compute binding.
    :type node_count: int
    """

    _validation = {
        'distribution_type': {'required': True},
    }

    _attribute_map = {
        'distribution_type': {'key': 'distributionType', 'type': 'str'},
        'communication_backend': {'key': 'communicationBackend', 'type': 'str'},
        'node_count': {'key': 'nodeCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        communication_backend: Optional[Union[str, "CommunicationBackend"]] = None,
        node_count: Optional[int] = None,
        **kwargs
    ):
        super(PyTorch, self).__init__(**kwargs)
        self.distribution_type = 'PyTorch'  # type: str
        self.communication_backend = communication_backend
        self.node_count = node_count


class QueryParamsDto(msrest.serialization.Model):
    """QueryParamsDto.

    :param filter:
    :type filter: str
    :param continuation_token:
    :type continuation_token: str
    :param orderby:
    :type orderby: str
    :param top:
    :type top: int
    """

    _attribute_map = {
        'filter': {'key': 'filter', 'type': 'str'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'orderby': {'key': 'orderby', 'type': 'str'},
        'top': {'key': 'top', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        filter: Optional[str] = None,
        continuation_token: Optional[str] = None,
        orderby: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs
    ):
        super(QueryParamsDto, self).__init__(**kwargs)
        self.filter = filter
        self.continuation_token = continuation_token
        self.orderby = orderby
        self.top = top


class QueueingInfoDto(msrest.serialization.Model):
    """QueueingInfoDto.

    :param code:
    :type code: str
    :param message:
    :type message: str
    :param last_refresh_timestamp:
    :type last_refresh_timestamp: ~datetime.datetime
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'last_refresh_timestamp': {'key': 'lastRefreshTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        last_refresh_timestamp: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(QueueingInfoDto, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.last_refresh_timestamp = last_refresh_timestamp


class QuotaBaseProperties(msrest.serialization.Model):
    """The properties for Quota update or retrieval.

    :param id: Specifies the resource ID.
    :type id: str
    :param type: Specifies the resource type.
    :type type: str
    :param limit: The maximum permitted quota of the resource.
    :type limit: long
    :param unit: An enum describing the unit of quota measurement. Possible values include:
     "Count".
    :type unit: str or ~azure_machine_learning_workspaces.models.QuotaUnit
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'limit': {'key': 'limit', 'type': 'long'},
        'unit': {'key': 'unit', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        type: Optional[str] = None,
        limit: Optional[int] = None,
        unit: Optional[Union[str, "QuotaUnit"]] = None,
        **kwargs
    ):
        super(QuotaBaseProperties, self).__init__(**kwargs)
        self.id = id
        self.type = type
        self.limit = limit
        self.unit = unit


class QuotaUpdateParameters(msrest.serialization.Model):
    """Quota update parameters.

    :param value: The list for update quota.
    :type value: list[~azure_machine_learning_workspaces.models.QuotaBaseProperties]
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[QuotaBaseProperties]'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["QuotaBaseProperties"]] = None,
        **kwargs
    ):
        super(QuotaUpdateParameters, self).__init__(**kwargs)
        self.value = value


class RCranPackage(msrest.serialization.Model):
    """RCranPackage.

    :param name: The package name.
    :type name: str
    :param repository: The repository name.
    :type repository: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'repository': {'key': 'repository', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        repository: Optional[str] = None,
        **kwargs
    ):
        super(RCranPackage, self).__init__(**kwargs)
        self.name = name
        self.repository = repository


class RegenerateEndpointKeysRequest(msrest.serialization.Model):
    """RegenerateEndpointKeysRequest.

    :param key_type: Specification for which type of key to generate. Primary or Secondary.
     Possible values include: "Primary", "Secondary".
    :type key_type: str or ~azure_machine_learning_workspaces.models.KeyType
    :param key_value: The value the key is set to.
    :type key_value: str
    """

    _attribute_map = {
        'key_type': {'key': 'keyType', 'type': 'str'},
        'key_value': {'key': 'keyValue', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_type: Optional[Union[str, "KeyType"]] = None,
        key_value: Optional[str] = None,
        **kwargs
    ):
        super(RegenerateEndpointKeysRequest, self).__init__(**kwargs)
        self.key_type = key_type
        self.key_value = key_value


class RegistryListCredentialsResult(msrest.serialization.Model):
    """RegistryListCredentialsResult.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar location:
    :vartype location: str
    :ivar username:
    :vartype username: str
    :param passwords:
    :type passwords: list[~azure_machine_learning_workspaces.models.Password]
    """

    _validation = {
        'location': {'readonly': True},
        'username': {'readonly': True},
    }

    _attribute_map = {
        'location': {'key': 'location', 'type': 'str'},
        'username': {'key': 'username', 'type': 'str'},
        'passwords': {'key': 'passwords', 'type': '[Password]'},
    }

    def __init__(
        self,
        *,
        passwords: Optional[List["Password"]] = None,
        **kwargs
    ):
        super(RegistryListCredentialsResult, self).__init__(**kwargs)
        self.location = None
        self.username = None
        self.passwords = passwords


class ResourceId(msrest.serialization.Model):
    """Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. The ID of the resource.
    :type id: str
    """

    _validation = {
        'id': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: str,
        **kwargs
    ):
        super(ResourceId, self).__init__(**kwargs)
        self.id = id


class ResourceIdentityInArm(msrest.serialization.Model):
    """ResourceIdentityInArm.

    :param type:
    :type type: str
    :param principal_id:
    :type principal_id: str
    :param tenant_id:
    :type tenant_id: str
    :param user_assigned_identities: Dictionary of :code:`<UserAssignedIdentityMeta>`.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentityMeta]
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{UserAssignedIdentityMeta}'},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        principal_id: Optional[str] = None,
        tenant_id: Optional[str] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentityMeta"]] = None,
        **kwargs
    ):
        super(ResourceIdentityInArm, self).__init__(**kwargs)
        self.type = type
        self.principal_id = principal_id
        self.tenant_id = tenant_id
        self.user_assigned_identities = user_assigned_identities


class ResourceName(msrest.serialization.Model):
    """The Resource Name.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The name of the resource.
    :vartype value: str
    :ivar localized_value: The localized name of the resource.
    :vartype localized_value: str
    """

    _validation = {
        'value': {'readonly': True},
        'localized_value': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
        'localized_value': {'key': 'localizedValue', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ResourceName, self).__init__(**kwargs)
        self.value = None
        self.localized_value = None


class ResourceQuota(msrest.serialization.Model):
    """The quota assigned to a resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar name: Name of the resource.
    :vartype name: ~azure_machine_learning_workspaces.models.ResourceName
    :ivar limit: The maximum permitted quota of the resource.
    :vartype limit: long
    :ivar unit: An enum describing the unit of quota measurement. Possible values include: "Count".
    :vartype unit: str or ~azure_machine_learning_workspaces.models.QuotaUnit
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'readonly': True},
        'name': {'readonly': True},
        'limit': {'readonly': True},
        'unit': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'ResourceName'},
        'limit': {'key': 'limit', 'type': 'long'},
        'unit': {'key': 'unit', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ResourceQuota, self).__init__(**kwargs)
        self.id = None
        self.type = None
        self.name = None
        self.limit = None
        self.unit = None


class ResourceSkuLocationInfo(msrest.serialization.Model):
    """ResourceSkuLocationInfo.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar location: Location of the SKU.
    :vartype location: str
    :ivar zones: List of availability zones where the SKU is supported.
    :vartype zones: list[str]
    :ivar zone_details: Details of capabilities available to a SKU in specific zones.
    :vartype zone_details: list[~azure_machine_learning_workspaces.models.ResourceSkuZoneDetails]
    """

    _validation = {
        'location': {'readonly': True},
        'zones': {'readonly': True},
        'zone_details': {'readonly': True},
    }

    _attribute_map = {
        'location': {'key': 'location', 'type': 'str'},
        'zones': {'key': 'zones', 'type': '[str]'},
        'zone_details': {'key': 'zoneDetails', 'type': '[ResourceSkuZoneDetails]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ResourceSkuLocationInfo, self).__init__(**kwargs)
        self.location = None
        self.zones = None
        self.zone_details = None


class ResourceSkuZoneDetails(msrest.serialization.Model):
    """Describes The zonal capabilities of a SKU.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The set of zones that the SKU is available in with the specified capabilities.
    :vartype name: list[str]
    :ivar capabilities: A list of capabilities that are available for the SKU in the specified list
     of zones.
    :vartype capabilities: list[~azure_machine_learning_workspaces.models.SkuCapability]
    """

    _validation = {
        'name': {'readonly': True},
        'capabilities': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': '[str]'},
        'capabilities': {'key': 'capabilities', 'type': '[SkuCapability]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ResourceSkuZoneDetails, self).__init__(**kwargs)
        self.name = None
        self.capabilities = None


class Restriction(msrest.serialization.Model):
    """The restriction because of which SKU cannot be used.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The type of restrictions. As of now only possible value for this is location.
    :vartype type: str
    :ivar values: The value of restrictions. If the restriction type is set to location. This would
     be different locations where the SKU is restricted.
    :vartype values: list[str]
    :param reason_code: The reason for the restriction. Possible values include: "NotSpecified",
     "NotAvailableForRegion", "NotAvailableForSubscription".
    :type reason_code: str or ~azure_machine_learning_workspaces.models.ReasonCode
    """

    _validation = {
        'type': {'readonly': True},
        'values': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'values': {'key': 'values', 'type': '[str]'},
        'reason_code': {'key': 'reasonCode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        reason_code: Optional[Union[str, "ReasonCode"]] = None,
        **kwargs
    ):
        super(Restriction, self).__init__(**kwargs)
        self.type = None
        self.values = None
        self.reason_code = reason_code


class RGitHubPackage(msrest.serialization.Model):
    """RGitHubPackage.

    :param repository: Repository address in the format username/repo[/subdir][@ref|#pull].
    :type repository: str
    :param auth_token: Personal access token to install from a private repo.
    :type auth_token: str
    """

    _attribute_map = {
        'repository': {'key': 'repository', 'type': 'str'},
        'auth_token': {'key': 'authToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        repository: Optional[str] = None,
        auth_token: Optional[str] = None,
        **kwargs
    ):
        super(RGitHubPackage, self).__init__(**kwargs)
        self.repository = repository
        self.auth_token = auth_token


class RGitHubPackageResponse(msrest.serialization.Model):
    """RGitHubPackageResponse.

    :param repository: Repository address in the format username/repo[/subdir][@ref|#pull].
    :type repository: str
    """

    _attribute_map = {
        'repository': {'key': 'repository', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        repository: Optional[str] = None,
        **kwargs
    ):
        super(RGitHubPackageResponse, self).__init__(**kwargs)
        self.repository = repository


class RootError(msrest.serialization.Model):
    """RootError.

    :param code:
    :type code: str
    :param severity:
    :type severity: int
    :param message:
    :type message: str
    :param message_format:
    :type message_format: str
    :param message_parameters: Dictionary of :code:`<string>`.
    :type message_parameters: dict[str, str]
    :param reference_code:
    :type reference_code: str
    :param details_uri:
    :type details_uri: str
    :param target:
    :type target: str
    :param details:
    :type details: list[~azure_machine_learning_workspaces.models.RootError]
    :param inner_error:
    :type inner_error: ~azure_machine_learning_workspaces.models.InnerErrorResponse
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'int'},
        'message': {'key': 'message', 'type': 'str'},
        'message_format': {'key': 'messageFormat', 'type': 'str'},
        'message_parameters': {'key': 'messageParameters', 'type': '{str}'},
        'reference_code': {'key': 'referenceCode', 'type': 'str'},
        'details_uri': {'key': 'detailsUri', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[RootError]'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponse'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        severity: Optional[int] = None,
        message: Optional[str] = None,
        message_format: Optional[str] = None,
        message_parameters: Optional[Dict[str, str]] = None,
        reference_code: Optional[str] = None,
        details_uri: Optional[str] = None,
        target: Optional[str] = None,
        details: Optional[List["RootError"]] = None,
        inner_error: Optional["InnerErrorResponse"] = None,
        **kwargs
    ):
        super(RootError, self).__init__(**kwargs)
        self.code = code
        self.severity = severity
        self.message = message
        self.message_format = message_format
        self.message_parameters = message_parameters
        self.reference_code = reference_code
        self.details_uri = details_uri
        self.target = target
        self.details = details
        self.inner_error = inner_error


class RootErrorautogenerated(msrest.serialization.Model):
    """The root error.

    :param code: The service-defined error code. Supported error codes: ServiceError, UserError,
     ValidationError, AzureStorageError, TransientError, RequestThrottled.
    :type code: str
    :param message: A human-readable representation of the error.
    :type message: str
    :param message_format: An unformatted version of the message with no variable substitution.
    :type message_format: str
    :param message_parameters: Value substitutions corresponding to the contents of MessageFormat.
    :type message_parameters: dict[str, str]
    :param reference_code: This code can optionally be set by the system generating the error. It
     should be used to classify the problem and identify the module and code area where the failure
     occured.
    :type reference_code: str
    :param details_uri: A URI which points to more details about the context of the error.
    :type details_uri: str
    :param target: The target of the error (e.g., the name of the property in error).
    :type target: str
    :param details: The related errors that occurred during the request.
    :type details: list[~azure_machine_learning_workspaces.models.RootErrorautogenerated]
    :param inner_error: A nested list of inner errors. When evaluating errors, clients MUST
     traverse through all of the nested "innerErrors" and choose the deepest one that they
     understand.
    :type inner_error: ~azure_machine_learning_workspaces.models.InnerErrorResponseautogenerated
    :param debug_info: An internal representation of the error. May be null for non-AzureML
     services.
    :type debug_info: ~azure_machine_learning_workspaces.models.DebugInfoResponse
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'message_format': {'key': 'messageFormat', 'type': 'str'},
        'message_parameters': {'key': 'messageParameters', 'type': '{str}'},
        'reference_code': {'key': 'referenceCode', 'type': 'str'},
        'details_uri': {'key': 'detailsUri', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[RootErrorautogenerated]'},
        'inner_error': {'key': 'innerError', 'type': 'InnerErrorResponseautogenerated'},
        'debug_info': {'key': 'debugInfo', 'type': 'DebugInfoResponse'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        message_format: Optional[str] = None,
        message_parameters: Optional[Dict[str, str]] = None,
        reference_code: Optional[str] = None,
        details_uri: Optional[str] = None,
        target: Optional[str] = None,
        details: Optional[List["RootErrorautogenerated"]] = None,
        inner_error: Optional["InnerErrorResponseautogenerated"] = None,
        debug_info: Optional["DebugInfoResponse"] = None,
        **kwargs
    ):
        super(RootErrorautogenerated, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.message_format = message_format
        self.message_parameters = message_parameters
        self.reference_code = reference_code
        self.details_uri = details_uri
        self.target = target
        self.details = details
        self.inner_error = inner_error
        self.debug_info = debug_info


class RunCountsDto(msrest.serialization.Model):
    """RunCountsDto.

    :param provisioning:
    :type provisioning: int
    :param queued:
    :type queued: int
    :param not_started:
    :type not_started: int
    :param starting:
    :type starting: int
    :param preparing:
    :type preparing: int
    :param running:
    :type running: int
    :param completed:
    :type completed: int
    :param failed:
    :type failed: int
    :param canceled:
    :type canceled: int
    :param not_responding:
    :type not_responding: int
    """

    _attribute_map = {
        'provisioning': {'key': 'provisioning', 'type': 'int'},
        'queued': {'key': 'queued', 'type': 'int'},
        'not_started': {'key': 'notStarted', 'type': 'int'},
        'starting': {'key': 'starting', 'type': 'int'},
        'preparing': {'key': 'preparing', 'type': 'int'},
        'running': {'key': 'running', 'type': 'int'},
        'completed': {'key': 'completed', 'type': 'int'},
        'failed': {'key': 'failed', 'type': 'int'},
        'canceled': {'key': 'canceled', 'type': 'int'},
        'not_responding': {'key': 'notResponding', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        provisioning: Optional[int] = None,
        queued: Optional[int] = None,
        not_started: Optional[int] = None,
        starting: Optional[int] = None,
        preparing: Optional[int] = None,
        running: Optional[int] = None,
        completed: Optional[int] = None,
        failed: Optional[int] = None,
        canceled: Optional[int] = None,
        not_responding: Optional[int] = None,
        **kwargs
    ):
        super(RunCountsDto, self).__init__(**kwargs)
        self.provisioning = provisioning
        self.queued = queued
        self.not_started = not_started
        self.starting = starting
        self.preparing = preparing
        self.running = running
        self.completed = completed
        self.failed = failed
        self.canceled = canceled
        self.not_responding = not_responding


class RunDetailsDto(msrest.serialization.Model):
    """RunDetailsDto.

    :param run_id:
    :type run_id: str
    :param target:
    :type target: str
    :param status:
    :type status: str
    :param start_time_utc:
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc:
    :type end_time_utc: ~datetime.datetime
    :param error: The error response.
    :type error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated
    :param warnings:
    :type warnings: list[~azure_machine_learning_workspaces.models.RunDetailsWarningDto]
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param input_datasets: A list of dataset used as input to the run.
    :type input_datasets: list[~azure_machine_learning_workspaces.models.Dataset]
    :param output_datasets:
    :type output_datasets: list[~azure_machine_learning_workspaces.models.OutputDatasetLineage]
    :param run_definition: Any object.
    :type run_definition: object
    :param log_files: Dictionary of :code:`<string>`.
    :type log_files: dict[str, str]
    """

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated'},
        'warnings': {'key': 'warnings', 'type': '[RunDetailsWarningDto]'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'input_datasets': {'key': 'inputDatasets', 'type': '[Dataset]'},
        'output_datasets': {'key': 'outputDatasets', 'type': '[OutputDatasetLineage]'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'log_files': {'key': 'logFiles', 'type': '{str}'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        target: Optional[str] = None,
        status: Optional[str] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        error: Optional["ErrorResponseautogenerated"] = None,
        warnings: Optional[List["RunDetailsWarningDto"]] = None,
        properties: Optional[Dict[str, str]] = None,
        input_datasets: Optional[List["Dataset"]] = None,
        output_datasets: Optional[List["OutputDatasetLineage"]] = None,
        run_definition: Optional[object] = None,
        log_files: Optional[Dict[str, str]] = None,
        **kwargs
    ):
        super(RunDetailsDto, self).__init__(**kwargs)
        self.run_id = run_id
        self.target = target
        self.status = status
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.error = error
        self.warnings = warnings
        self.properties = properties
        self.input_datasets = input_datasets
        self.output_datasets = output_datasets
        self.run_definition = run_definition
        self.log_files = log_files


class RunDetailsWarningDto(msrest.serialization.Model):
    """RunDetailsWarningDto.

    :param source:
    :type source: str
    :param message:
    :type message: str
    """

    _attribute_map = {
        'source': {'key': 'source', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        super(RunDetailsWarningDto, self).__init__(**kwargs)
        self.source = source
        self.message = message


class RunDto(msrest.serialization.Model):
    """RunDto.

    :param run_number:
    :type run_number: int
    :param root_run_id:
    :type root_run_id: str
    :param experiment_id:
    :type experiment_id: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param user_id:
    :type user_id: str
    :param token:
    :type token: str
    :param token_expiry_time_utc:
    :type token_expiry_time_utc: ~datetime.datetime
    :param run_id:
    :type run_id: str
    :param parent_run_id:
    :type parent_run_id: str
    :param status:
    :type status: str
    :param start_time_utc:
    :type start_time_utc: ~datetime.datetime
    :param end_time_utc:
    :type end_time_utc: ~datetime.datetime
    :param heartbeat_enabled:
    :type heartbeat_enabled: bool
    :param options:
    :type options: ~azure_machine_learning_workspaces.models.RunOptions
    :param name:
    :type name: str
    :param data_container_id:
    :type data_container_id: str
    :param description:
    :type description: str
    :param hidden:
    :type hidden: bool
    :param run_type:
    :type run_type: str
    :param parent_run_uuid:
    :type parent_run_uuid: str
    :param root_run_uuid:
    :type root_run_uuid: str
    :param run_uuid:
    :type run_uuid: str
    :param properties: Dictionary of :code:`<string>`.
    :type properties: dict[str, str]
    :param script_name:
    :type script_name: str
    :param target:
    :type target: str
    :param tags: A set of tags. Dictionary of :code:`<string>`.
    :type tags: dict[str, str]
    :param run_definition: Any object.
    :type run_definition: object
    :param created_from:
    :type created_from: ~azure_machine_learning_workspaces.models.CreatedFromDto
    :param created_by:
    :type created_by: ~azure_machine_learning_workspaces.models.CreatedByDto
    :param cancel_uri:
    :type cancel_uri: str
    :param complete_uri:
    :type complete_uri: str
    :param diagnostics_uri:
    :type diagnostics_uri: str
    :param error: The error response.
    :type error: ~azure_machine_learning_workspaces.models.ErrorResponseautogenerated
    :param warnings:
    :type warnings: list[~azure_machine_learning_workspaces.models.RunDetailsWarningDto]
    :param queueing_info:
    :type queueing_info: ~azure_machine_learning_workspaces.models.QueueingInfoDto
    """

    _attribute_map = {
        'run_number': {'key': 'runNumber', 'type': 'int'},
        'root_run_id': {'key': 'rootRunId', 'type': 'str'},
        'experiment_id': {'key': 'experimentId', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'user_id': {'key': 'userId', 'type': 'str'},
        'token': {'key': 'token', 'type': 'str'},
        'token_expiry_time_utc': {'key': 'tokenExpiryTimeUtc', 'type': 'iso-8601'},
        'run_id': {'key': 'runId', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'start_time_utc': {'key': 'startTimeUtc', 'type': 'iso-8601'},
        'end_time_utc': {'key': 'endTimeUtc', 'type': 'iso-8601'},
        'heartbeat_enabled': {'key': 'heartbeatEnabled', 'type': 'bool'},
        'options': {'key': 'options', 'type': 'RunOptions'},
        'name': {'key': 'name', 'type': 'str'},
        'data_container_id': {'key': 'dataContainerId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'hidden': {'key': 'hidden', 'type': 'bool'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'parent_run_uuid': {'key': 'parentRunUuid', 'type': 'str'},
        'root_run_uuid': {'key': 'rootRunUuid', 'type': 'str'},
        'run_uuid': {'key': 'runUuid', 'type': 'str'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'script_name': {'key': 'scriptName', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'run_definition': {'key': 'runDefinition', 'type': 'object'},
        'created_from': {'key': 'createdFrom', 'type': 'CreatedFromDto'},
        'created_by': {'key': 'createdBy', 'type': 'CreatedByDto'},
        'cancel_uri': {'key': 'cancelUri', 'type': 'str'},
        'complete_uri': {'key': 'completeUri', 'type': 'str'},
        'diagnostics_uri': {'key': 'diagnosticsUri', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorResponseautogenerated'},
        'warnings': {'key': 'warnings', 'type': '[RunDetailsWarningDto]'},
        'queueing_info': {'key': 'queueingInfo', 'type': 'QueueingInfoDto'},
    }

    def __init__(
        self,
        *,
        run_number: Optional[int] = None,
        root_run_id: Optional[str] = None,
        experiment_id: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        user_id: Optional[str] = None,
        token: Optional[str] = None,
        token_expiry_time_utc: Optional[datetime.datetime] = None,
        run_id: Optional[str] = None,
        parent_run_id: Optional[str] = None,
        status: Optional[str] = None,
        start_time_utc: Optional[datetime.datetime] = None,
        end_time_utc: Optional[datetime.datetime] = None,
        heartbeat_enabled: Optional[bool] = None,
        options: Optional["RunOptions"] = None,
        name: Optional[str] = None,
        data_container_id: Optional[str] = None,
        description: Optional[str] = None,
        hidden: Optional[bool] = None,
        run_type: Optional[str] = None,
        parent_run_uuid: Optional[str] = None,
        root_run_uuid: Optional[str] = None,
        run_uuid: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        script_name: Optional[str] = None,
        target: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        run_definition: Optional[object] = None,
        created_from: Optional["CreatedFromDto"] = None,
        created_by: Optional["CreatedByDto"] = None,
        cancel_uri: Optional[str] = None,
        complete_uri: Optional[str] = None,
        diagnostics_uri: Optional[str] = None,
        error: Optional["ErrorResponseautogenerated"] = None,
        warnings: Optional[List["RunDetailsWarningDto"]] = None,
        queueing_info: Optional["QueueingInfoDto"] = None,
        **kwargs
    ):
        super(RunDto, self).__init__(**kwargs)
        self.run_number = run_number
        self.root_run_id = root_run_id
        self.experiment_id = experiment_id
        self.created_utc = created_utc
        self.user_id = user_id
        self.token = token
        self.token_expiry_time_utc = token_expiry_time_utc
        self.run_id = run_id
        self.parent_run_id = parent_run_id
        self.status = status
        self.start_time_utc = start_time_utc
        self.end_time_utc = end_time_utc
        self.heartbeat_enabled = heartbeat_enabled
        self.options = options
        self.name = name
        self.data_container_id = data_container_id
        self.description = description
        self.hidden = hidden
        self.run_type = run_type
        self.parent_run_uuid = parent_run_uuid
        self.root_run_uuid = root_run_uuid
        self.run_uuid = run_uuid
        self.properties = properties
        self.script_name = script_name
        self.target = target
        self.tags = tags
        self.run_definition = run_definition
        self.created_from = created_from
        self.created_by = created_by
        self.cancel_uri = cancel_uri
        self.complete_uri = complete_uri
        self.diagnostics_uri = diagnostics_uri
        self.error = error
        self.warnings = warnings
        self.queueing_info = queueing_info


class RunMetricDto(msrest.serialization.Model):
    """RunMetricDto.

    :param run_id:
    :type run_id: str
    :param metric_id:
    :type metric_id: str
    :param metric_type:
    :type metric_type: str
    :param created_utc:
    :type created_utc: ~datetime.datetime
    :param name:
    :type name: str
    :param description:
    :type description: str
    :param label:
    :type label: str
    :param num_cells:
    :type num_cells: int
    :param data_location:
    :type data_location: str
    :param cells:
    :type cells: list[dict[str, object]]
    :param schema:
    :type schema: ~azure_machine_learning_workspaces.models.MetricSchemaDto
    """

    _attribute_map = {
        'run_id': {'key': 'runId', 'type': 'str'},
        'metric_id': {'key': 'metricId', 'type': 'str'},
        'metric_type': {'key': 'metricType', 'type': 'str'},
        'created_utc': {'key': 'createdUtc', 'type': 'iso-8601'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
        'num_cells': {'key': 'numCells', 'type': 'int'},
        'data_location': {'key': 'dataLocation', 'type': 'str'},
        'cells': {'key': 'cells', 'type': '[{object}]'},
        'schema': {'key': 'schema', 'type': 'MetricSchemaDto'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        metric_id: Optional[str] = None,
        metric_type: Optional[str] = None,
        created_utc: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        label: Optional[str] = None,
        num_cells: Optional[int] = None,
        data_location: Optional[str] = None,
        cells: Optional[List[Dict[str, object]]] = None,
        schema: Optional["MetricSchemaDto"] = None,
        **kwargs
    ):
        super(RunMetricDto, self).__init__(**kwargs)
        self.run_id = run_id
        self.metric_id = metric_id
        self.metric_type = metric_type
        self.created_utc = created_utc
        self.name = name
        self.description = description
        self.label = label
        self.num_cells = num_cells
        self.data_location = data_location
        self.cells = cells
        self.schema = schema


class RunOptions(msrest.serialization.Model):
    """RunOptions.

    :param generate_data_container_id_if_not_specified:
    :type generate_data_container_id_if_not_specified: bool
    """

    _attribute_map = {
        'generate_data_container_id_if_not_specified': {'key': 'generateDataContainerIdIfNotSpecified', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        generate_data_container_id_if_not_specified: Optional[bool] = None,
        **kwargs
    ):
        super(RunOptions, self).__init__(**kwargs)
        self.generate_data_container_id_if_not_specified = generate_data_container_id_if_not_specified


class SasSection(msrest.serialization.Model):
    """SasSection.

    :param sas_token: Storage container SAS token.
    :type sas_token: str
    """

    _attribute_map = {
        'sas_token': {'key': 'sasToken', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        sas_token: Optional[str] = None,
        **kwargs
    ):
        super(SasSection, self).__init__(**kwargs)
        self.sas_token = sas_token


class ScaleSettings(msrest.serialization.Model):
    """ScaleSettings.

    :param minimum:
    :type minimum: int
    :param maximum:
    :type maximum: int
    :param instance_count:
    :type instance_count: int
    :param scale_type:  Possible values include: "Automatic", "Manual", "None".
    :type scale_type: str or ~azure_machine_learning_workspaces.models.ScaleTypeMode
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'int'},
        'maximum': {'key': 'maximum', 'type': 'int'},
        'instance_count': {'key': 'instanceCount', 'type': 'int'},
        'scale_type': {'key': 'scaleType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        minimum: Optional[int] = None,
        maximum: Optional[int] = None,
        instance_count: Optional[int] = None,
        scale_type: Optional[Union[str, "ScaleTypeMode"]] = None,
        **kwargs
    ):
        super(ScaleSettings, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.instance_count = instance_count
        self.scale_type = scale_type


class ScaleSettingsautogenerated(msrest.serialization.Model):
    """scale settings for AML Compute.

    All required parameters must be populated in order to send to Azure.

    :param max_node_count: Required. Max number of nodes to use.
    :type max_node_count: int
    :param min_node_count: Min number of nodes to use.
    :type min_node_count: int
    :param node_idle_time_before_scale_down: Node Idle Time before scaling down amlCompute. This
     string needs to be in the RFC Format.
    :type node_idle_time_before_scale_down: ~datetime.timedelta
    """

    _validation = {
        'max_node_count': {'required': True},
    }

    _attribute_map = {
        'max_node_count': {'key': 'maxNodeCount', 'type': 'int'},
        'min_node_count': {'key': 'minNodeCount', 'type': 'int'},
        'node_idle_time_before_scale_down': {'key': 'nodeIdleTimeBeforeScaleDown', 'type': 'duration'},
    }

    def __init__(
        self,
        *,
        max_node_count: int,
        min_node_count: Optional[int] = 0,
        node_idle_time_before_scale_down: Optional[datetime.timedelta] = None,
        **kwargs
    ):
        super(ScaleSettingsautogenerated, self).__init__(**kwargs)
        self.max_node_count = max_node_count
        self.min_node_count = min_node_count
        self.node_idle_time_before_scale_down = node_idle_time_before_scale_down


class ServicePrincipalCredentials(msrest.serialization.Model):
    """Service principal credentials.

    All required parameters must be populated in order to send to Azure.

    :param client_id: Required. Client Id.
    :type client_id: str
    :param client_secret: Required. Client secret.
    :type client_secret: str
    """

    _validation = {
        'client_id': {'required': True},
        'client_secret': {'required': True},
    }

    _attribute_map = {
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret': {'key': 'clientSecret', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        client_id: str,
        client_secret: str,
        **kwargs
    ):
        super(ServicePrincipalCredentials, self).__init__(**kwargs)
        self.client_id = client_id
        self.client_secret = client_secret


class ServicePrincipalSection(msrest.serialization.Model):
    """ServicePrincipalSection.

    All required parameters must be populated in order to send to Azure.

    :param authority_url: Authority URL used for authentication.
    :type authority_url: str
    :param resource_uri: Resource the service principal has access to.
    :type resource_uri: str
    :param tenant_id: Required. ID of the tenant to which the service principal belongs.
    :type tenant_id: str
    :param client_id: Required. Service principal client ID.
    :type client_id: str
    :param client_secret: Service principal secret.
    :type client_secret: str
    """

    _validation = {
        'tenant_id': {'required': True},
        'client_id': {'required': True},
    }

    _attribute_map = {
        'authority_url': {'key': 'authorityUrl', 'type': 'str'},
        'resource_uri': {'key': 'resourceUri', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret': {'key': 'clientSecret', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tenant_id: str,
        client_id: str,
        authority_url: Optional[str] = None,
        resource_uri: Optional[str] = None,
        client_secret: Optional[str] = None,
        **kwargs
    ):
        super(ServicePrincipalSection, self).__init__(**kwargs)
        self.authority_url = authority_url
        self.resource_uri = resource_uri
        self.tenant_id = tenant_id
        self.client_id = client_id
        self.client_secret = client_secret


class ServiceResource(MachineLearningResource):
    """Machine Learning service object wrapped into ARM resource envelope.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    :param properties: Service properties.
    :type properties: ~azure_machine_learning_workspaces.models.ServiceResponseBase
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
        'properties': {'key': 'properties', 'type': 'ServiceResponseBase'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        properties: Optional["ServiceResponseBase"] = None,
        **kwargs
    ):
        super(ServiceResource, self).__init__(location=location, tags=tags, sku=sku, type_identity_type=type_identity_type, user_assigned_identities=user_assigned_identities, **kwargs)
        self.properties = properties


class ServiceResponseBaseError(ErrorResponseautogenerated2):
    """The error details.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message.
    :vartype message: str
    :ivar details: An array of error detail objects.
    :vartype details: list[~azure_machine_learning_workspaces.models.ErrorDetail]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'details': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ServiceResponseBaseError, self).__init__(**kwargs)


class SharedPrivateLinkResource(msrest.serialization.Model):
    """SharedPrivateLinkResource.

    :param name: Unique name of the private link.
    :type name: str
    :param private_link_resource_id: The resource id that private link links to.
    :type private_link_resource_id: str
    :param group_id: The private link resource group id.
    :type group_id: str
    :param request_message: Request message.
    :type request_message: str
    :param status: Indicates whether the connection has been Approved/Rejected/Removed by the owner
     of the service. Possible values include: "Pending", "Approved", "Rejected", "Disconnected",
     "Timeout".
    :type status: str or
     ~azure_machine_learning_workspaces.models.PrivateEndpointServiceConnectionStatus
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'private_link_resource_id': {'key': 'properties.privateLinkResourceId', 'type': 'str'},
        'group_id': {'key': 'properties.groupId', 'type': 'str'},
        'request_message': {'key': 'properties.requestMessage', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        private_link_resource_id: Optional[str] = None,
        group_id: Optional[str] = None,
        request_message: Optional[str] = None,
        status: Optional[Union[str, "PrivateEndpointServiceConnectionStatus"]] = None,
        **kwargs
    ):
        super(SharedPrivateLinkResource, self).__init__(**kwargs)
        self.name = name
        self.private_link_resource_id = private_link_resource_id
        self.group_id = group_id
        self.request_message = request_message
        self.status = status


class Sku(msrest.serialization.Model):
    """Sku of the resource.

    :param name: Name of the sku.
    :type name: str
    :param tier: Tier of the sku like Basic or Enterprise.
    :type tier: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'tier': {'key': 'tier', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        tier: Optional[str] = None,
        **kwargs
    ):
        super(Sku, self).__init__(**kwargs)
        self.name = name
        self.tier = tier


class SkuCapability(msrest.serialization.Model):
    """Features/user capabilities associated with the sku.

    :param name: Capability/Feature ID.
    :type name: str
    :param value: Details about the feature/capability.
    :type value: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs
    ):
        super(SkuCapability, self).__init__(**kwargs)
        self.name = name
        self.value = value


class SkuListResult(msrest.serialization.Model):
    """List of skus with features.

    :param value:
    :type value: list[~azure_machine_learning_workspaces.models.WorkspaceSku]
    :param next_link: The URI to fetch the next page of Workspace Skus. Call ListNext() with this
     URI to fetch the next page of Workspace Skus.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[WorkspaceSku]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["WorkspaceSku"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(SkuListResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class SparkMavenPackage(msrest.serialization.Model):
    """SparkMavenPackage.

    :param group:
    :type group: str
    :param artifact:
    :type artifact: str
    :param version:
    :type version: str
    """

    _attribute_map = {
        'group': {'key': 'group', 'type': 'str'},
        'artifact': {'key': 'artifact', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        group: Optional[str] = None,
        artifact: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        super(SparkMavenPackage, self).__init__(**kwargs)
        self.group = group
        self.artifact = artifact
        self.version = version


class SQLAdminSection(msrest.serialization.Model):
    """SQLAdminSection.

    All required parameters must be populated in order to send to Azure.

    :param user_id: Required. SQL database user name.
    :type user_id: str
    :param password: SQL database password.
    :type password: str
    """

    _validation = {
        'user_id': {'required': True, 'pattern': r'\w'},
    }

    _attribute_map = {
        'user_id': {'key': 'userId', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        user_id: str,
        password: Optional[str] = None,
        **kwargs
    ):
        super(SQLAdminSection, self).__init__(**kwargs)
        self.user_id = user_id
        self.password = password


class SSLConfiguration(msrest.serialization.Model):
    """SSLConfiguration.

    :param ssl_enabled:
    :type ssl_enabled: bool
    :param ssl_certificate:
    :type ssl_certificate: str
    :param ssl_key:
    :type ssl_key: str
    :param c_name:
    :type c_name: str
    """

    _attribute_map = {
        'ssl_enabled': {'key': 'sslEnabled', 'type': 'bool'},
        'ssl_certificate': {'key': 'sslCertificate', 'type': 'str'},
        'ssl_key': {'key': 'sslKey', 'type': 'str'},
        'c_name': {'key': 'cName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        ssl_enabled: Optional[bool] = None,
        ssl_certificate: Optional[str] = None,
        ssl_key: Optional[str] = None,
        c_name: Optional[str] = None,
        **kwargs
    ):
        super(SSLConfiguration, self).__init__(**kwargs)
        self.ssl_enabled = ssl_enabled
        self.ssl_certificate = ssl_certificate
        self.ssl_key = ssl_key
        self.c_name = c_name


class SSLConfigurationautogenerated(msrest.serialization.Model):
    """The ssl configuration for scoring.

    :param status: Enable or disable ssl for scoring. Possible values include: "Disabled",
     "Enabled".
    :type status: str or ~azure_machine_learning_workspaces.models.SSLConfigurationStatus
    :param cert: Cert data.
    :type cert: str
    :param key: Key data.
    :type key: str
    :param cname: CNAME of the cert.
    :type cname: str
    """

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
        'cert': {'key': 'cert', 'type': 'str'},
        'key': {'key': 'key', 'type': 'str'},
        'cname': {'key': 'cname', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        status: Optional[Union[str, "SSLConfigurationStatus"]] = None,
        cert: Optional[str] = None,
        key: Optional[str] = None,
        cname: Optional[str] = None,
        **kwargs
    ):
        super(SSLConfigurationautogenerated, self).__init__(**kwargs)
        self.status = status
        self.cert = cert
        self.key = key
        self.cname = cname


class StatusMessage(msrest.serialization.Model):
    """Active message associated with project.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar level: Severity level of message. Possible values include: "Error", "Information",
     "Warning".
    :vartype level: str or ~azure_machine_learning_workspaces.models.StatusMessageLevel
    :ivar code: Service-defined message code.
    :vartype code: str
    :ivar message: A human-readable representation of the message code.
    :vartype message: str
    :ivar created_time_utc: Time in UTC at which the message was created.
    :vartype created_time_utc: ~datetime.datetime
    """

    _validation = {
        'level': {'readonly': True},
        'code': {'readonly': True},
        'message': {'readonly': True},
        'created_time_utc': {'readonly': True},
    }

    _attribute_map = {
        'level': {'key': 'level', 'type': 'str'},
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'created_time_utc': {'key': 'createdTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StatusMessage, self).__init__(**kwargs)
        self.level = None
        self.code = None
        self.message = None
        self.created_time_utc = None


class SweepJob(ComputeJobBase):
    """SweepJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~azure_machine_learning_workspaces.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated job endpoints.
    :vartype interaction_endpoints:
     ~azure_machine_learning_workspaces.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param properties: The asset property dictionary.
    :type properties: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. Compute binding definition.
    :type compute_binding: ~azure_machine_learning_workspaces.models.ComputeBinding
    :param output:
    :type output: ~azure_machine_learning_workspaces.models.JobOutput
    :param status: The status of a job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~azure_machine_learning_workspaces.models.JobStatus
    :param parameter_sampling_configuration: class for all hyperparameter sampling algorithms.
    :type parameter_sampling_configuration:
     ~azure_machine_learning_workspaces.models.ParameterSamplingConfiguration
    :param termination_configuration:
    :type termination_configuration:
     ~azure_machine_learning_workspaces.models.TerminationConfiguration
    :param evaluation_configuration:
    :type evaluation_configuration:
     ~azure_machine_learning_workspaces.models.EvaluationConfiguration
    :param trial_job:
    :type trial_job: ~azure_machine_learning_workspaces.models.TrialJob
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'properties': {'key': 'properties', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'ComputeBinding'},
        'output': {'key': 'output', 'type': 'JobOutput'},
        'status': {'key': 'status', 'type': 'str'},
        'parameter_sampling_configuration': {'key': 'parameterSamplingConfiguration', 'type': 'ParameterSamplingConfiguration'},
        'termination_configuration': {'key': 'terminationConfiguration', 'type': 'TerminationConfiguration'},
        'evaluation_configuration': {'key': 'evaluationConfiguration', 'type': 'EvaluationConfiguration'},
        'trial_job': {'key': 'trialJob', 'type': 'TrialJob'},
    }

    def __init__(
        self,
        *,
        compute_binding: "ComputeBinding",
        description: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        experiment_name: Optional[str] = None,
        output: Optional["JobOutput"] = None,
        status: Optional[Union[str, "JobStatus"]] = None,
        parameter_sampling_configuration: Optional["ParameterSamplingConfiguration"] = None,
        termination_configuration: Optional["TerminationConfiguration"] = None,
        evaluation_configuration: Optional["EvaluationConfiguration"] = None,
        trial_job: Optional["TrialJob"] = None,
        **kwargs
    ):
        super(SweepJob, self).__init__(description=description, tags=tags, properties=properties, experiment_name=experiment_name, compute_binding=compute_binding, output=output, **kwargs)
        self.job_type = 'Sweep'  # type: str
        self.status = status
        self.parameter_sampling_configuration = parameter_sampling_configuration
        self.termination_configuration = termination_configuration
        self.evaluation_configuration = evaluation_configuration
        self.trial_job = trial_job


class SystemData(msrest.serialization.Model):
    """Azure Resource Manager resource Envelope.

    :param created_at: the timestamp of resource creation (UTC).
    :type created_at: ~datetime.datetime
    :param created_by: a string identifier for the identity that created the resource.
    :type created_by: str
    :param created_by_type: the type of identity that created the resource: user, application,
     managedIdentity, key. Possible values include: "User", "Application", "ManagedIdentity", "Key".
    :type created_by_type: str or ~azure_machine_learning_workspaces.models.UserType
    :param last_modified_at: the timestamp of resource last modification (UTC).
    :type last_modified_at: ~datetime.datetime
    :param last_modified_by: a string identifier for the identity that last modified the resource.
    :type last_modified_by: str
    :param last_modified_by_type: the type of identity that last modified the resource: user,
     application, managedIdentity, key. Possible values include: "User", "Application",
     "ManagedIdentity", "Key".
    :type last_modified_by_type: str or ~azure_machine_learning_workspaces.models.UserType
    """

    _attribute_map = {
        'created_at': {'key': 'createdAt', 'type': 'iso-8601'},
        'created_by': {'key': 'createdBy', 'type': 'str'},
        'created_by_type': {'key': 'createdByType', 'type': 'str'},
        'last_modified_at': {'key': 'lastModifiedAt', 'type': 'iso-8601'},
        'last_modified_by': {'key': 'lastModifiedBy', 'type': 'str'},
        'last_modified_by_type': {'key': 'lastModifiedByType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        created_at: Optional[datetime.datetime] = None,
        created_by: Optional[str] = None,
        created_by_type: Optional[Union[str, "UserType"]] = None,
        last_modified_at: Optional[datetime.datetime] = None,
        last_modified_by: Optional[str] = None,
        last_modified_by_type: Optional[Union[str, "UserType"]] = None,
        **kwargs
    ):
        super(SystemData, self).__init__(**kwargs)
        self.created_at = created_at
        self.created_by = created_by
        self.created_by_type = created_by_type
        self.last_modified_at = last_modified_at
        self.last_modified_by = last_modified_by
        self.last_modified_by_type = last_modified_by_type


class SystemService(msrest.serialization.Model):
    """A system service running on a compute.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar system_service_type: The type of this system service.
    :vartype system_service_type: str
    :ivar public_ip_address: Public IP address.
    :vartype public_ip_address: str
    :ivar version: The version for this type.
    :vartype version: str
    """

    _validation = {
        'system_service_type': {'readonly': True},
        'public_ip_address': {'readonly': True},
        'version': {'readonly': True},
    }

    _attribute_map = {
        'system_service_type': {'key': 'systemServiceType', 'type': 'str'},
        'public_ip_address': {'key': 'publicIpAddress', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SystemService, self).__init__(**kwargs)
        self.system_service_type = None
        self.public_ip_address = None
        self.version = None


class Tensorflow(DistributionConfiguration):
    """Tensorflow.

    All required parameters must be populated in order to send to Azure.

    :param distribution_type: Required. Specifies the type of distibution framework.Constant filled
     by server.  Possible values include: "PyTorch", "Tensorflow", "Mpi".
    :type distribution_type: str or ~azure_machine_learning_workspaces.models.DistributionType
    :param worker_count: Number of workers. Overwrites the node count in compute binding.
    :type worker_count: int
    :param parameter_server_count:
    :type parameter_server_count: int
    """

    _validation = {
        'distribution_type': {'required': True},
    }

    _attribute_map = {
        'distribution_type': {'key': 'distributionType', 'type': 'str'},
        'worker_count': {'key': 'workerCount', 'type': 'int'},
        'parameter_server_count': {'key': 'parameterServerCount', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        worker_count: Optional[int] = None,
        parameter_server_count: Optional[int] = None,
        **kwargs
    ):
        super(Tensorflow, self).__init__(**kwargs)
        self.distribution_type = 'Tensorflow'  # type: str
        self.worker_count = worker_count
        self.parameter_server_count = parameter_server_count


class TerminationConfiguration(msrest.serialization.Model):
    """TerminationConfiguration.

    :param max_total_runs:
    :type max_total_runs: int
    :param max_concurrent_runs:
    :type max_concurrent_runs: int
    :param max_duration_minutes:
    :type max_duration_minutes: int
    :param early_termination_policy_configuration: Early termination policies enable canceling
     poor-performing runs before they complete.
    :type early_termination_policy_configuration:
     ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyConfiguration
    """

    _attribute_map = {
        'max_total_runs': {'key': 'maxTotalRuns', 'type': 'int'},
        'max_concurrent_runs': {'key': 'maxConcurrentRuns', 'type': 'int'},
        'max_duration_minutes': {'key': 'maxDurationMinutes', 'type': 'int'},
        'early_termination_policy_configuration': {'key': 'earlyTerminationPolicyConfiguration', 'type': 'EarlyTerminationPolicyConfiguration'},
    }

    def __init__(
        self,
        *,
        max_total_runs: Optional[int] = None,
        max_concurrent_runs: Optional[int] = None,
        max_duration_minutes: Optional[int] = None,
        early_termination_policy_configuration: Optional["EarlyTerminationPolicyConfiguration"] = None,
        **kwargs
    ):
        super(TerminationConfiguration, self).__init__(**kwargs)
        self.max_total_runs = max_total_runs
        self.max_concurrent_runs = max_concurrent_runs
        self.max_duration_minutes = max_duration_minutes
        self.early_termination_policy_configuration = early_termination_policy_configuration


class TerminationConfigurationEarlyTerminationPolicyConfiguration(EarlyTerminationPolicyConfiguration):
    """Early termination policies enable canceling poor-performing runs before they complete.

    All required parameters must be populated in order to send to Azure.

    :param policy_type: Required. Name of policy configuration.Constant filled by server.  Possible
     values include: "Bandit", "MedianStopping", "TruncationSelection".
    :type policy_type: str or ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyType
    :param evaluation_interval:
    :type evaluation_interval: int
    :param delay_evaluation:
    :type delay_evaluation: int
    """

    _validation = {
        'policy_type': {'required': True},
    }

    _attribute_map = {
        'policy_type': {'key': 'policyType', 'type': 'str'},
        'evaluation_interval': {'key': 'evaluationInterval', 'type': 'int'},
        'delay_evaluation': {'key': 'delayEvaluation', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        evaluation_interval: Optional[int] = None,
        delay_evaluation: Optional[int] = None,
        **kwargs
    ):
        super(TerminationConfigurationEarlyTerminationPolicyConfiguration, self).__init__(evaluation_interval=evaluation_interval, delay_evaluation=delay_evaluation, **kwargs)
        self.policy_type = 'TerminationConfiguration-earlyTerminationPolicyConfiguration'  # type: str


class TokenResult(msrest.serialization.Model):
    """TokenResult.

    :param token:
    :type token: str
    :param expiry_time_utc:
    :type expiry_time_utc: ~datetime.datetime
    """

    _attribute_map = {
        'token': {'key': 'token', 'type': 'str'},
        'expiry_time_utc': {'key': 'expiryTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        token: Optional[str] = None,
        expiry_time_utc: Optional[datetime.datetime] = None,
        **kwargs
    ):
        super(TokenResult, self).__init__(**kwargs)
        self.token = token
        self.expiry_time_utc = expiry_time_utc


class TrialJob(msrest.serialization.Model):
    """TrialJob.

    :param code_configuration:
    :type code_configuration: ~azure_machine_learning_workspaces.models.CodeConfiguration
    :param environment_id: Environment id of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: dict[str, ~azure_machine_learning_workspaces.models.DataBinding]
    """

    _attribute_map = {
        'code_configuration': {'key': 'codeConfiguration', 'type': 'CodeConfiguration'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': '{DataBinding}'},
    }

    def __init__(
        self,
        *,
        code_configuration: Optional["CodeConfiguration"] = None,
        environment_id: Optional[str] = None,
        data_bindings: Optional[Dict[str, "DataBinding"]] = None,
        **kwargs
    ):
        super(TrialJob, self).__init__(**kwargs)
        self.code_configuration = code_configuration
        self.environment_id = environment_id
        self.data_bindings = data_bindings


class TruncationSelectionPolicyConfiguration(EarlyTerminationPolicyConfiguration):
    """Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.

    All required parameters must be populated in order to send to Azure.

    :param policy_type: Required. Name of policy configuration.Constant filled by server.  Possible
     values include: "Bandit", "MedianStopping", "TruncationSelection".
    :type policy_type: str or ~azure_machine_learning_workspaces.models.EarlyTerminationPolicyType
    :param evaluation_interval:
    :type evaluation_interval: int
    :param delay_evaluation:
    :type delay_evaluation: int
    :param truncation_percentage:
    :type truncation_percentage: int
    :param exclude_finished_jobs:
    :type exclude_finished_jobs: bool
    """

    _validation = {
        'policy_type': {'required': True},
    }

    _attribute_map = {
        'policy_type': {'key': 'policyType', 'type': 'str'},
        'evaluation_interval': {'key': 'evaluationInterval', 'type': 'int'},
        'delay_evaluation': {'key': 'delayEvaluation', 'type': 'int'},
        'truncation_percentage': {'key': 'truncationPercentage', 'type': 'int'},
        'exclude_finished_jobs': {'key': 'excludeFinishedJobs', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        evaluation_interval: Optional[int] = None,
        delay_evaluation: Optional[int] = None,
        truncation_percentage: Optional[int] = None,
        exclude_finished_jobs: Optional[bool] = None,
        **kwargs
    ):
        super(TruncationSelectionPolicyConfiguration, self).__init__(evaluation_interval=evaluation_interval, delay_evaluation=delay_evaluation, **kwargs)
        self.policy_type = 'TruncationSelection'  # type: str
        self.truncation_percentage = truncation_percentage
        self.exclude_finished_jobs = exclude_finished_jobs


class UpdateWorkspaceQuotas(msrest.serialization.Model):
    """The properties for update Quota response.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :param limit: The maximum permitted quota of the resource.
    :type limit: long
    :ivar unit: An enum describing the unit of quota measurement. Possible values include: "Count".
    :vartype unit: str or ~azure_machine_learning_workspaces.models.QuotaUnit
    :param status: Status of update workspace quota. Possible values include: "Undefined",
     "Success", "Failure", "InvalidQuotaBelowClusterMinimum",
     "InvalidQuotaExceedsSubscriptionLimit", "InvalidVMFamilyName", "OperationNotSupportedForSku",
     "OperationNotEnabledForRegion".
    :type status: str or ~azure_machine_learning_workspaces.models.Status
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'readonly': True},
        'unit': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'limit': {'key': 'limit', 'type': 'long'},
        'unit': {'key': 'unit', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        limit: Optional[int] = None,
        status: Optional[Union[str, "Status"]] = None,
        **kwargs
    ):
        super(UpdateWorkspaceQuotas, self).__init__(**kwargs)
        self.id = None
        self.type = None
        self.limit = limit
        self.unit = None
        self.status = status


class UpdateWorkspaceQuotasResult(msrest.serialization.Model):
    """The result of update workspace quota.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The list of workspace quota update result.
    :vartype value: list[~azure_machine_learning_workspaces.models.UpdateWorkspaceQuotas]
    :ivar next_link: The URI to fetch the next page of workspace quota update result. Call
     ListNext() with this to fetch the next page of Workspace Quota update result.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[UpdateWorkspaceQuotas]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UpdateWorkspaceQuotasResult, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class Usage(msrest.serialization.Model):
    """Describes AML Resource Usage.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar type: Specifies the resource type.
    :vartype type: str
    :ivar unit: An enum describing the unit of usage measurement. Possible values include: "Count".
    :vartype unit: str or ~azure_machine_learning_workspaces.models.UsageUnit
    :ivar current_value: The current usage of the resource.
    :vartype current_value: long
    :ivar limit: The maximum permitted usage of the resource.
    :vartype limit: long
    :ivar name: The name of the type of usage.
    :vartype name: ~azure_machine_learning_workspaces.models.UsageName
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'readonly': True},
        'unit': {'readonly': True},
        'current_value': {'readonly': True},
        'limit': {'readonly': True},
        'name': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'unit': {'key': 'unit', 'type': 'str'},
        'current_value': {'key': 'currentValue', 'type': 'long'},
        'limit': {'key': 'limit', 'type': 'long'},
        'name': {'key': 'name', 'type': 'UsageName'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Usage, self).__init__(**kwargs)
        self.id = None
        self.type = None
        self.unit = None
        self.current_value = None
        self.limit = None
        self.name = None


class UsageName(msrest.serialization.Model):
    """The Usage Names.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar value: The name of the resource.
    :vartype value: str
    :ivar localized_value: The localized name of the resource.
    :vartype localized_value: str
    """

    _validation = {
        'value': {'readonly': True},
        'localized_value': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
        'localized_value': {'key': 'localizedValue', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UsageName, self).__init__(**kwargs)
        self.value = None
        self.localized_value = None


class UserAccountCredentials(msrest.serialization.Model):
    """Settings for user account that gets created on each on the nodes of a compute.

    All required parameters must be populated in order to send to Azure.

    :param admin_user_name: Required. Name of the administrator user account which can be used to
     SSH to nodes.
    :type admin_user_name: str
    :param admin_user_ssh_public_key: SSH public key of the administrator user account.
    :type admin_user_ssh_public_key: str
    :param admin_user_password: Password of the administrator user account.
    :type admin_user_password: str
    """

    _validation = {
        'admin_user_name': {'required': True},
    }

    _attribute_map = {
        'admin_user_name': {'key': 'adminUserName', 'type': 'str'},
        'admin_user_ssh_public_key': {'key': 'adminUserSshPublicKey', 'type': 'str'},
        'admin_user_password': {'key': 'adminUserPassword', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        admin_user_name: str,
        admin_user_ssh_public_key: Optional[str] = None,
        admin_user_password: Optional[str] = None,
        **kwargs
    ):
        super(UserAccountCredentials, self).__init__(**kwargs)
        self.admin_user_name = admin_user_name
        self.admin_user_ssh_public_key = admin_user_ssh_public_key
        self.admin_user_password = admin_user_password


class UserAssignedIdentity(msrest.serialization.Model):
    """User Assigned Identity.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar principal_id: The principal ID of the user assigned identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of the user assigned identity.
    :vartype tenant_id: str
    :ivar client_id: The clientId(aka appId) of the user assigned identity.
    :vartype client_id: str
    """

    _validation = {
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
        'client_id': {'readonly': True},
    }

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UserAssignedIdentity, self).__init__(**kwargs)
        self.principal_id = None
        self.tenant_id = None
        self.client_id = None


class UserAssignedIdentityMeta(msrest.serialization.Model):
    """UserAssignedIdentityMeta.

    :param principal_id:
    :type principal_id: str
    :param client_id:
    :type client_id: str
    :param client_secret_url:
    :type client_secret_url: str
    :param resource_id:
    :type resource_id: str
    :param tenant_id:
    :type tenant_id: str
    """

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
        'client_secret_url': {'key': 'clientSecretUrl', 'type': 'str'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        principal_id: Optional[str] = None,
        client_id: Optional[str] = None,
        client_secret_url: Optional[str] = None,
        resource_id: Optional[str] = None,
        tenant_id: Optional[str] = None,
        **kwargs
    ):
        super(UserAssignedIdentityMeta, self).__init__(**kwargs)
        self.principal_id = principal_id
        self.client_id = client_id
        self.client_secret_url = client_secret_url
        self.resource_id = resource_id
        self.tenant_id = tenant_id


class VirtualMachine(Compute):
    """A Machine Learning compute based on Azure Virtual Machines.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param compute_location: Location for the underlying compute.
    :type compute_location: str
    :ivar provisioning_state: The provision state of the cluster. Valid values are Unknown,
     Updating, Provisioning, Succeeded, and Failed. Possible values include: "Unknown", "Updating",
     "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param description: The description of the Machine Learning compute.
    :type description: str
    :ivar created_on: The date and time when the compute was created.
    :vartype created_on: ~datetime.datetime
    :ivar modified_on: The date and time when the compute was last modified.
    :vartype modified_on: ~datetime.datetime
    :param resource_id: ARM resource id of the underlying compute.
    :type resource_id: str
    :ivar provisioning_errors: Errors during provisioning.
    :vartype provisioning_errors:
     list[~azure_machine_learning_workspaces.models.MachineLearningServiceError]
    :ivar is_attached_compute: Indicating whether the compute was provisioned by user and brought
     from outside if true, or machine learning service provisioned it if false.
    :vartype is_attached_compute: bool
    :param virtual_machine_size: Virtual Machine size.
    :type virtual_machine_size: str
    :param ssh_port: Port open for ssh connections.
    :type ssh_port: int
    :param address: Public IP address of the virtual machine.
    :type address: str
    :param administrator_account: Admin credentials for virtual machine.
    :type administrator_account:
     ~azure_machine_learning_workspaces.models.VirtualMachineSshCredentials
    """

    _validation = {
        'compute_type': {'required': True},
        'provisioning_state': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'provisioning_errors': {'readonly': True},
        'is_attached_compute': {'readonly': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'compute_location': {'key': 'computeLocation', 'type': 'str'},
        'provisioning_state': {'key': 'provisioningState', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'created_on': {'key': 'createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'modifiedOn', 'type': 'iso-8601'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'provisioning_errors': {'key': 'provisioningErrors', 'type': '[MachineLearningServiceError]'},
        'is_attached_compute': {'key': 'isAttachedCompute', 'type': 'bool'},
        'virtual_machine_size': {'key': 'properties.virtualMachineSize', 'type': 'str'},
        'ssh_port': {'key': 'properties.sshPort', 'type': 'int'},
        'address': {'key': 'properties.address', 'type': 'str'},
        'administrator_account': {'key': 'properties.administratorAccount', 'type': 'VirtualMachineSshCredentials'},
    }

    def __init__(
        self,
        *,
        compute_location: Optional[str] = None,
        description: Optional[str] = None,
        resource_id: Optional[str] = None,
        virtual_machine_size: Optional[str] = None,
        ssh_port: Optional[int] = None,
        address: Optional[str] = None,
        administrator_account: Optional["VirtualMachineSshCredentials"] = None,
        **kwargs
    ):
        super(VirtualMachine, self).__init__(compute_location=compute_location, description=description, resource_id=resource_id, **kwargs)
        self.compute_type = 'VirtualMachine'  # type: str
        self.virtual_machine_size = virtual_machine_size
        self.ssh_port = ssh_port
        self.address = address
        self.administrator_account = administrator_account


class VirtualMachineImage(msrest.serialization.Model):
    """Virtual Machine image for Windows AML Compute.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Virtual Machine image path.
    :type id: str
    """

    _validation = {
        'id': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: str,
        **kwargs
    ):
        super(VirtualMachineImage, self).__init__(**kwargs)
        self.id = id


class VirtualMachineSecrets(ComputeSecrets):
    """Secrets related to a Machine Learning compute based on AKS.

    All required parameters must be populated in order to send to Azure.

    :param compute_type: Required. The type of compute.Constant filled by server.  Possible values
     include: "AMLCompute", "AKS", "ACI", "DataFactory", "VirtualMachine", "HDInsight",
     "Databricks", "DataLakeAnalytics".
    :type compute_type: str or ~azure_machine_learning_workspaces.models.ComputeType
    :param administrator_account: Admin credentials for virtual machine.
    :type administrator_account:
     ~azure_machine_learning_workspaces.models.VirtualMachineSshCredentials
    """

    _validation = {
        'compute_type': {'required': True},
    }

    _attribute_map = {
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'administrator_account': {'key': 'administratorAccount', 'type': 'VirtualMachineSshCredentials'},
    }

    def __init__(
        self,
        *,
        administrator_account: Optional["VirtualMachineSshCredentials"] = None,
        **kwargs
    ):
        super(VirtualMachineSecrets, self).__init__(**kwargs)
        self.compute_type = 'VirtualMachine'  # type: str
        self.administrator_account = administrator_account


class VirtualMachineSize(msrest.serialization.Model):
    """Describes the properties of a VM size.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the virtual machine size.
    :vartype name: str
    :ivar family: The family name of the virtual machine size.
    :vartype family: str
    :ivar v_cp_us: The number of vCPUs supported by the virtual machine size.
    :vartype v_cp_us: int
    :ivar gpus: The number of gPUs supported by the virtual machine size.
    :vartype gpus: int
    :ivar os_vhd_size_mb: The OS VHD disk size, in MB, allowed by the virtual machine size.
    :vartype os_vhd_size_mb: int
    :ivar max_resource_volume_mb: The resource volume size, in MB, allowed by the virtual machine
     size.
    :vartype max_resource_volume_mb: int
    :ivar memory_gb: The amount of memory, in GB, supported by the virtual machine size.
    :vartype memory_gb: float
    :ivar low_priority_capable: Specifies if the virtual machine size supports low priority VMs.
    :vartype low_priority_capable: bool
    :ivar premium_io: Specifies if the virtual machine size supports premium IO.
    :vartype premium_io: bool
    :param estimated_vm_prices: The estimated price information for using a VM.
    :type estimated_vm_prices: ~azure_machine_learning_workspaces.models.EstimatedVmPrices
    """

    _validation = {
        'name': {'readonly': True},
        'family': {'readonly': True},
        'v_cp_us': {'readonly': True},
        'gpus': {'readonly': True},
        'os_vhd_size_mb': {'readonly': True},
        'max_resource_volume_mb': {'readonly': True},
        'memory_gb': {'readonly': True},
        'low_priority_capable': {'readonly': True},
        'premium_io': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'family': {'key': 'family', 'type': 'str'},
        'v_cp_us': {'key': 'vCPUs', 'type': 'int'},
        'gpus': {'key': 'gpus', 'type': 'int'},
        'os_vhd_size_mb': {'key': 'osVhdSizeMB', 'type': 'int'},
        'max_resource_volume_mb': {'key': 'maxResourceVolumeMB', 'type': 'int'},
        'memory_gb': {'key': 'memoryGB', 'type': 'float'},
        'low_priority_capable': {'key': 'lowPriorityCapable', 'type': 'bool'},
        'premium_io': {'key': 'premiumIO', 'type': 'bool'},
        'estimated_vm_prices': {'key': 'estimatedVMPrices', 'type': 'EstimatedVmPrices'},
    }

    def __init__(
        self,
        *,
        estimated_vm_prices: Optional["EstimatedVmPrices"] = None,
        **kwargs
    ):
        super(VirtualMachineSize, self).__init__(**kwargs)
        self.name = None
        self.family = None
        self.v_cp_us = None
        self.gpus = None
        self.os_vhd_size_mb = None
        self.max_resource_volume_mb = None
        self.memory_gb = None
        self.low_priority_capable = None
        self.premium_io = None
        self.estimated_vm_prices = estimated_vm_prices


class VirtualMachineSizeListResult(msrest.serialization.Model):
    """The List Virtual Machine size operation response.

    :param aml_compute: The list of virtual machine sizes supported by AmlCompute.
    :type aml_compute: list[~azure_machine_learning_workspaces.models.VirtualMachineSize]
    """

    _attribute_map = {
        'aml_compute': {'key': 'amlCompute', 'type': '[VirtualMachineSize]'},
    }

    def __init__(
        self,
        *,
        aml_compute: Optional[List["VirtualMachineSize"]] = None,
        **kwargs
    ):
        super(VirtualMachineSizeListResult, self).__init__(**kwargs)
        self.aml_compute = aml_compute


class VirtualMachineSshCredentials(msrest.serialization.Model):
    """Admin credentials for virtual machine.

    :param username: Username of admin account.
    :type username: str
    :param password: Password of admin account.
    :type password: str
    :param public_key_data: Public key data.
    :type public_key_data: str
    :param private_key_data: Private key data.
    :type private_key_data: str
    """

    _attribute_map = {
        'username': {'key': 'username', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'public_key_data': {'key': 'publicKeyData', 'type': 'str'},
        'private_key_data': {'key': 'privateKeyData', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        public_key_data: Optional[str] = None,
        private_key_data: Optional[str] = None,
        **kwargs
    ):
        super(VirtualMachineSshCredentials, self).__init__(**kwargs)
        self.username = username
        self.password = password
        self.public_key_data = public_key_data
        self.private_key_data = private_key_data


class VnetConfiguration(msrest.serialization.Model):
    """VnetConfiguration.

    :param vnet_name: vnetName.
    :type vnet_name: str
    :param subnet_name: subnetName.
    :type subnet_name: str
    """

    _attribute_map = {
        'vnet_name': {'key': 'vnetName', 'type': 'str'},
        'subnet_name': {'key': 'subnetName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        vnet_name: Optional[str] = None,
        subnet_name: Optional[str] = None,
        **kwargs
    ):
        super(VnetConfiguration, self).__init__(**kwargs)
        self.vnet_name = vnet_name
        self.subnet_name = subnet_name


class Workspace(MachineLearningResource):
    """An object that represents a machine learning workspace.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Specifies the resource ID.
    :vartype id: str
    :ivar name: Specifies the name of the resource.
    :vartype name: str
    :param location: Specifies the location of the resource.
    :type location: str
    :ivar type: Specifies the type of the resource.
    :vartype type: str
    :param tags: A set of tags. Contains resource tags defined as key/value pairs.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :ivar principal_id: The principal ID of resource identity.
    :vartype principal_id: str
    :ivar tenant_id: The tenant ID of resource.
    :vartype tenant_id: str
    :param type_identity_type: The identity type. Possible values include: "SystemAssigned",
     "SystemAssigned,UserAssigned", "UserAssigned", "None".
    :type type_identity_type: str or ~azure_machine_learning_workspaces.models.ResourceIdentityType
    :param user_assigned_identities: The user assigned identities associated with the resource.
    :type user_assigned_identities: dict[str,
     ~azure_machine_learning_workspaces.models.UserAssignedIdentity]
    :ivar workspace_id: The immutable id associated with this workspace.
    :vartype workspace_id: str
    :param description: The description of this workspace.
    :type description: str
    :param friendly_name: The friendly name for this workspace. This name in mutable.
    :type friendly_name: str
    :ivar creation_time: The creation time of the machine learning workspace in ISO8601 format.
    :vartype creation_time: ~datetime.datetime
    :param key_vault: ARM id of the key vault associated with this workspace. This cannot be
     changed once the workspace has been created.
    :type key_vault: str
    :param application_insights: ARM id of the application insights associated with this workspace.
     This cannot be changed once the workspace has been created.
    :type application_insights: str
    :param container_registry: ARM id of the container registry associated with this workspace.
     This cannot be changed once the workspace has been created.
    :type container_registry: str
    :param storage_account: ARM id of the storage account associated with this workspace. This
     cannot be changed once the workspace has been created.
    :type storage_account: str
    :param discovery_url: Url for the discovery service to identify regional endpoints for machine
     learning experimentation services.
    :type discovery_url: str
    :ivar provisioning_state: The current deployment state of workspace resource. The
     provisioningState is to indicate states for resource provisioning. Possible values include:
     "Unknown", "Updating", "Creating", "Deleting", "Succeeded", "Failed", "Canceled".
    :vartype provisioning_state: str or ~azure_machine_learning_workspaces.models.ProvisioningState
    :param hbi_workspace: The flag to signal HBI data in the workspace and reduce diagnostic data
     collected by the service.
    :type hbi_workspace: bool
    :ivar service_provisioned_resource_group: The name of the managed resource group created by
     workspace RP in customer subscription if the workspace is CMK workspace.
    :vartype service_provisioned_resource_group: str
    :ivar private_link_count: Count of private connections in the workspace.
    :vartype private_link_count: int
    :param image_build_compute: The compute name for image build.
    :type image_build_compute: str
    :param allow_public_access_when_behind_vnet: The flag to indicate whether to allow public
     access when behind VNet.
    :type allow_public_access_when_behind_vnet: bool
    :ivar private_endpoint_connections: The list of private endpoint connections in the workspace.
    :vartype private_endpoint_connections:
     list[~azure_machine_learning_workspaces.models.PrivateEndpointConnection]
    :param shared_private_link_resources: The list of shared private link resources in this
     workspace.
    :type shared_private_link_resources:
     list[~azure_machine_learning_workspaces.models.SharedPrivateLinkResource]
    :param status: Indicates whether or not the encryption is enabled for the workspace. Possible
     values include: "Enabled", "Disabled".
    :type status: str or ~azure_machine_learning_workspaces.models.EncryptionStatus
    :param key_vault_properties: Customer Key vault properties.
    :type key_vault_properties: ~azure_machine_learning_workspaces.models.KeyVaultProperties
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
        'workspace_id': {'readonly': True},
        'creation_time': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'service_provisioned_resource_group': {'readonly': True},
        'private_link_count': {'readonly': True},
        'private_endpoint_connections': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'principal_id': {'key': 'identity.principalId', 'type': 'str'},
        'tenant_id': {'key': 'identity.tenantId', 'type': 'str'},
        'type_identity_type': {'key': 'identity.type', 'type': 'str'},
        'user_assigned_identities': {'key': 'identity.userAssignedIdentities', 'type': '{UserAssignedIdentity}'},
        'workspace_id': {'key': 'properties.workspaceId', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'friendly_name': {'key': 'properties.friendlyName', 'type': 'str'},
        'creation_time': {'key': 'properties.creationTime', 'type': 'iso-8601'},
        'key_vault': {'key': 'properties.keyVault', 'type': 'str'},
        'application_insights': {'key': 'properties.applicationInsights', 'type': 'str'},
        'container_registry': {'key': 'properties.containerRegistry', 'type': 'str'},
        'storage_account': {'key': 'properties.storageAccount', 'type': 'str'},
        'discovery_url': {'key': 'properties.discoveryUrl', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'hbi_workspace': {'key': 'properties.hbiWorkspace', 'type': 'bool'},
        'service_provisioned_resource_group': {'key': 'properties.serviceProvisionedResourceGroup', 'type': 'str'},
        'private_link_count': {'key': 'properties.privateLinkCount', 'type': 'int'},
        'image_build_compute': {'key': 'properties.imageBuildCompute', 'type': 'str'},
        'allow_public_access_when_behind_vnet': {'key': 'properties.allowPublicAccessWhenBehindVnet', 'type': 'bool'},
        'private_endpoint_connections': {'key': 'properties.privateEndpointConnections', 'type': '[PrivateEndpointConnection]'},
        'shared_private_link_resources': {'key': 'properties.sharedPrivateLinkResources', 'type': '[SharedPrivateLinkResource]'},
        'status': {'key': 'encryption.status', 'type': 'str'},
        'key_vault_properties': {'key': 'encryption.keyVaultProperties', 'type': 'KeyVaultProperties'},
    }

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        type_identity_type: Optional[Union[str, "ResourceIdentityType"]] = None,
        user_assigned_identities: Optional[Dict[str, "UserAssignedIdentity"]] = None,
        description: Optional[str] = None,
        friendly_name: Optional[str] = None,
        key_vault: Optional[str] = None,
        application_insights: Optional[str] = None,
        container_registry: Optional[str] = None,
        storage_account: Optional[str] = None,
        discovery_url: Optional[str] = None,
        hbi_workspace: Optional[bool] = False,
        image_build_compute: Optional[str] = None,
        allow_public_access_when_behind_vnet: Optional[bool] = False,
        shared_private_link_resources: Optional[List["SharedPrivateLinkResource"]] = None,
        status: Optional[Union[str, "EncryptionStatus"]] = None,
        key_vault_properties: Optional["KeyVaultProperties"] = None,
        **kwargs
    ):
        super(Workspace, self).__init__(location=location, tags=tags, sku=sku, type_identity_type=type_identity_type, user_assigned_identities=user_assigned_identities, **kwargs)
        self.workspace_id = None
        self.description = description
        self.friendly_name = friendly_name
        self.creation_time = None
        self.key_vault = key_vault
        self.application_insights = application_insights
        self.container_registry = container_registry
        self.storage_account = storage_account
        self.discovery_url = discovery_url
        self.provisioning_state = None
        self.hbi_workspace = hbi_workspace
        self.service_provisioned_resource_group = None
        self.private_link_count = None
        self.image_build_compute = image_build_compute
        self.allow_public_access_when_behind_vnet = allow_public_access_when_behind_vnet
        self.private_endpoint_connections = None
        self.shared_private_link_resources = shared_private_link_resources
        self.status = status
        self.key_vault_properties = key_vault_properties


class WorkspaceListResult(msrest.serialization.Model):
    """The result of a request to list machine learning workspaces.

    :param value: The list of machine learning workspaces. Since this list may be incomplete, the
     nextLink field should be used to request the next list of machine learning workspaces.
    :type value: list[~azure_machine_learning_workspaces.models.Workspace]
    :param next_link: The URI that can be used to request the next list of machine learning
     workspaces.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Workspace]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        value: Optional[List["Workspace"]] = None,
        next_link: Optional[str] = None,
        **kwargs
    ):
        super(WorkspaceListResult, self).__init__(**kwargs)
        self.value = value
        self.next_link = next_link


class WorkspaceSku(msrest.serialization.Model):
    """Describes Workspace Sku details and features.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar locations: The set of locations that the SKU is available. This will be supported and
     registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.).
    :vartype locations: list[str]
    :ivar location_info: A list of locations and availability zones in those locations where the
     SKU is available.
    :vartype location_info: list[~azure_machine_learning_workspaces.models.ResourceSkuLocationInfo]
    :ivar tier: Sku Tier like Basic or Enterprise.
    :vartype tier: str
    :ivar resource_type:
    :vartype resource_type: str
    :ivar name:
    :vartype name: str
    :ivar capabilities: List of features/user capabilities associated with the sku.
    :vartype capabilities: list[~azure_machine_learning_workspaces.models.SkuCapability]
    :param restrictions: The restrictions because of which SKU cannot be used. This is empty if
     there are no restrictions.
    :type restrictions: list[~azure_machine_learning_workspaces.models.Restriction]
    """

    _validation = {
        'locations': {'readonly': True},
        'location_info': {'readonly': True},
        'tier': {'readonly': True},
        'resource_type': {'readonly': True},
        'name': {'readonly': True},
        'capabilities': {'readonly': True},
    }

    _attribute_map = {
        'locations': {'key': 'locations', 'type': '[str]'},
        'location_info': {'key': 'locationInfo', 'type': '[ResourceSkuLocationInfo]'},
        'tier': {'key': 'tier', 'type': 'str'},
        'resource_type': {'key': 'resourceType', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'capabilities': {'key': 'capabilities', 'type': '[SkuCapability]'},
        'restrictions': {'key': 'restrictions', 'type': '[Restriction]'},
    }

    def __init__(
        self,
        *,
        restrictions: Optional[List["Restriction"]] = None,
        **kwargs
    ):
        super(WorkspaceSku, self).__init__(**kwargs)
        self.locations = None
        self.location_info = None
        self.tier = None
        self.resource_type = None
        self.name = None
        self.capabilities = None
        self.restrictions = restrictions


class WorkspaceUpdateParameters(msrest.serialization.Model):
    """The parameters for updating a machine learning workspace.

    :param tags: A set of tags. The resource tags for the machine learning workspace.
    :type tags: dict[str, str]
    :param sku: The sku of the workspace.
    :type sku: ~azure_machine_learning_workspaces.models.Sku
    :param description: The description of this workspace.
    :type description: str
    :param friendly_name: The friendly name for this workspace.
    :type friendly_name: str
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'sku': {'key': 'sku', 'type': 'Sku'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'friendly_name': {'key': 'properties.friendlyName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tags: Optional[Dict[str, str]] = None,
        sku: Optional["Sku"] = None,
        description: Optional[str] = None,
        friendly_name: Optional[str] = None,
        **kwargs
    ):
        super(WorkspaceUpdateParameters, self).__init__(**kwargs)
        self.tags = tags
        self.sku = sku
        self.description = description
        self.friendly_name = friendly_name
